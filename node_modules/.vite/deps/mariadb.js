import {
  require_buffer,
  require_stream,
  require_string_decoder
} from "./chunk-VLWXKSR6.js";
import {
  require_fs,
  require_os
} from "./chunk-EJGJ2FCK.js";
import {
  require_crypto
} from "./chunk-NL3QLVH6.js";
import {
  __commonJS,
  __privateAdd,
  __privateGet,
  __privateMethod,
  __privateSet,
  __privateWrapper,
  __publicField
} from "./chunk-7T46AFYU.js";

// node_modules/mariadb/package.json
var require_package = __commonJS({
  "node_modules/mariadb/package.json"(exports, module) {
    module.exports = {
      name: "mariadb",
      version: "3.4.4",
      description: "fast mariadb or mysql connector.",
      main: "promise.js",
      types: "types/index.d.ts",
      typesVersions: {
        "*": {
          callback: ["types/callback.d.ts"],
          "*": ["types/index.d.ts"]
        }
      },
      directories: {
        lib: "lib",
        test: "test"
      },
      private: false,
      scripts: {
        test: "npm run test:types-prettier && npm run test:prettier && npm run test:types && npm run test:lint && npm run test:base",
        "test:base": 'mocha --no-parallel --timeout 5000 "test/**/*.js"',
        "test:lint": 'eslint "*.js" "{lib,test}/**/*.js"',
        "test:types": 'eslint "types/*.ts"',
        "test:types-prettier": 'prettier --write "types/*.ts"',
        "test:prettier": 'prettier --write "*.js" "{tools,lib,test,benchmarks}/**/*.js"',
        coverage: "npm run coverage:test && npm run coverage:create && npm run coverage:send",
        "coverage:test": 'nyc mocha --no-parallel --timeout 5000 "test/**/*.js"',
        "coverage:report": "npm run coverage:create && npm run coverage:send",
        "coverage:create": "nyc report --reporter=text-lcov > coverage.lcov",
        "coverage:send": "./codecov --disable=gcov",
        benchmark: "node benchmarks/benchmarks-all.js",
        generate: "node ./tools/generate-mariadb.js"
      },
      repository: {
        type: "git",
        url: "git+https://github.com/mariadb-corporation/mariadb-connector-nodejs.git"
      },
      keywords: [
        "mariadb",
        "mysql",
        "client",
        "driver",
        "connector"
      ],
      files: [
        "lib",
        "types/index.d.ts",
        "types/callback.d.ts",
        "types/share.d.ts",
        "promise.js",
        "check-node.js",
        "callback.js"
      ],
      engines: {
        node: ">= 14"
      },
      author: "Diego Dupin <diego.dupin@mariadb.com>",
      license: "LGPL-2.1-or-later",
      dependencies: {
        denque: "^2.1.0",
        "iconv-lite": "^0.6.3",
        "lru-cache": "^10.3.0"
      },
      devDependencies: {
        "@types/geojson": "^7946.0.14",
        "@types/node": "^22.5.4",
        "@typescript-eslint/eslint-plugin": "^7.18.0",
        "@typescript-eslint/parser": "^7.18.0",
        benchmark: "^2.1.4",
        chai: "^4.4.1",
        chalk: "^4.1.2",
        "error-stack-parser": "^2.1.4",
        eslint: "^8.48.0",
        "eslint-config-prettier": "^9.0.0",
        "eslint-plugin-markdown": "^3.0.1",
        "eslint-plugin-prettier": "^5.0.0",
        mocha: "^10.2.0",
        "mocha-lcov-reporter": "^1.3.0",
        nyc: "^15.1.0",
        prettier: "^3.0.3",
        typescript: "^5.6.2",
        winston: "^3.10.0"
      },
      bugs: {
        url: "https://jira.mariadb.org/projects/CONJS/"
      },
      homepage: "https://github.com/mariadb-corporation/mariadb-connector-nodejs#readme"
    };
  }
});

// node_modules/mariadb/check-node.js
var require_check_node = __commonJS({
  "node_modules/mariadb/check-node.js"(exports, module) {
    "use strict";
    var hasMinVersion = function(nodeVersionStr, connectorRequirement2) {
      const versNode = nodeVersionStr.split(".");
      const versReq = connectorRequirement2.split(".");
      const majorNode = Number(versNode[0]);
      const majorReq = Number(versReq[0]);
      if (majorNode > majorReq) return true;
      if (majorNode < majorReq) return false;
      if (versReq.length === 1) return true;
      const minorNode = Number(versNode[1]);
      const minorReq = Number(versReq[1]);
      return minorNode >= minorReq;
    };
    module.exports.hasMinVersion = hasMinVersion;
    var requirement = require_package().engines.node;
    var connectorRequirement = requirement.replace(">=", "").trim();
    var currentNodeVersion = process.version.replace("v", "");
    if (!hasMinVersion(currentNodeVersion, connectorRequirement)) {
      console.error(`please upgrade node: mariadb requires at least version ${connectorRequirement}`);
      process.exit(1);
    }
  }
});

// browser-external:events
var require_events = __commonJS({
  "browser-external:events"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "events" has been externalized for browser compatibility. Cannot access "events.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/denque/index.js
var require_denque = __commonJS({
  "node_modules/denque/index.js"(exports, module) {
    "use strict";
    function Denque(array, options) {
      var options = options || {};
      this._capacity = options.capacity;
      this._head = 0;
      this._tail = 0;
      if (Array.isArray(array)) {
        this._fromArray(array);
      } else {
        this._capacityMask = 3;
        this._list = new Array(4);
      }
    }
    Denque.prototype.peekAt = function peekAt(index) {
      var i = index;
      if (i !== (i | 0)) {
        return void 0;
      }
      var len = this.size();
      if (i >= len || i < -len) return void 0;
      if (i < 0) i += len;
      i = this._head + i & this._capacityMask;
      return this._list[i];
    };
    Denque.prototype.get = function get(i) {
      return this.peekAt(i);
    };
    Denque.prototype.peek = function peek() {
      if (this._head === this._tail) return void 0;
      return this._list[this._head];
    };
    Denque.prototype.peekFront = function peekFront() {
      return this.peek();
    };
    Denque.prototype.peekBack = function peekBack() {
      return this.peekAt(-1);
    };
    Object.defineProperty(Denque.prototype, "length", {
      get: function length() {
        return this.size();
      }
    });
    Denque.prototype.size = function size() {
      if (this._head === this._tail) return 0;
      if (this._head < this._tail) return this._tail - this._head;
      else return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.unshift = function unshift(item) {
      if (arguments.length === 0) return this.size();
      var len = this._list.length;
      this._head = this._head - 1 + len & this._capacityMask;
      this._list[this._head] = item;
      if (this._tail === this._head) this._growArray();
      if (this._capacity && this.size() > this._capacity) this.pop();
      if (this._head < this._tail) return this._tail - this._head;
      else return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.shift = function shift() {
      var head = this._head;
      if (head === this._tail) return void 0;
      var item = this._list[head];
      this._list[head] = void 0;
      this._head = head + 1 & this._capacityMask;
      if (head < 2 && this._tail > 1e4 && this._tail <= this._list.length >>> 2) this._shrinkArray();
      return item;
    };
    Denque.prototype.push = function push(item) {
      if (arguments.length === 0) return this.size();
      var tail = this._tail;
      this._list[tail] = item;
      this._tail = tail + 1 & this._capacityMask;
      if (this._tail === this._head) {
        this._growArray();
      }
      if (this._capacity && this.size() > this._capacity) {
        this.shift();
      }
      if (this._head < this._tail) return this._tail - this._head;
      else return this._capacityMask + 1 - (this._head - this._tail);
    };
    Denque.prototype.pop = function pop() {
      var tail = this._tail;
      if (tail === this._head) return void 0;
      var len = this._list.length;
      this._tail = tail - 1 + len & this._capacityMask;
      var item = this._list[this._tail];
      this._list[this._tail] = void 0;
      if (this._head < 2 && tail > 1e4 && tail <= len >>> 2) this._shrinkArray();
      return item;
    };
    Denque.prototype.removeOne = function removeOne(index) {
      var i = index;
      if (i !== (i | 0)) {
        return void 0;
      }
      if (this._head === this._tail) return void 0;
      var size = this.size();
      var len = this._list.length;
      if (i >= size || i < -size) return void 0;
      if (i < 0) i += size;
      i = this._head + i & this._capacityMask;
      var item = this._list[i];
      var k;
      if (index < size / 2) {
        for (k = index; k > 0; k--) {
          this._list[i] = this._list[i = i - 1 + len & this._capacityMask];
        }
        this._list[i] = void 0;
        this._head = this._head + 1 + len & this._capacityMask;
      } else {
        for (k = size - 1 - index; k > 0; k--) {
          this._list[i] = this._list[i = i + 1 + len & this._capacityMask];
        }
        this._list[i] = void 0;
        this._tail = this._tail - 1 + len & this._capacityMask;
      }
      return item;
    };
    Denque.prototype.remove = function remove(index, count) {
      var i = index;
      var removed;
      var del_count = count;
      if (i !== (i | 0)) {
        return void 0;
      }
      if (this._head === this._tail) return void 0;
      var size = this.size();
      var len = this._list.length;
      if (i >= size || i < -size || count < 1) return void 0;
      if (i < 0) i += size;
      if (count === 1 || !count) {
        removed = new Array(1);
        removed[0] = this.removeOne(i);
        return removed;
      }
      if (i === 0 && i + count >= size) {
        removed = this.toArray();
        this.clear();
        return removed;
      }
      if (i + count > size) count = size - i;
      var k;
      removed = new Array(count);
      for (k = 0; k < count; k++) {
        removed[k] = this._list[this._head + i + k & this._capacityMask];
      }
      i = this._head + i & this._capacityMask;
      if (index + count === size) {
        this._tail = this._tail - count + len & this._capacityMask;
        for (k = count; k > 0; k--) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
        }
        return removed;
      }
      if (index === 0) {
        this._head = this._head + count + len & this._capacityMask;
        for (k = count - 1; k > 0; k--) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
        }
        return removed;
      }
      if (i < size / 2) {
        this._head = this._head + index + count + len & this._capacityMask;
        for (k = index; k > 0; k--) {
          this.unshift(this._list[i = i - 1 + len & this._capacityMask]);
        }
        i = this._head - 1 + len & this._capacityMask;
        while (del_count > 0) {
          this._list[i = i - 1 + len & this._capacityMask] = void 0;
          del_count--;
        }
        if (index < 0) this._tail = i;
      } else {
        this._tail = i;
        i = i + count + len & this._capacityMask;
        for (k = size - (count + index); k > 0; k--) {
          this.push(this._list[i++]);
        }
        i = this._tail;
        while (del_count > 0) {
          this._list[i = i + 1 + len & this._capacityMask] = void 0;
          del_count--;
        }
      }
      if (this._head < 2 && this._tail > 1e4 && this._tail <= len >>> 2) this._shrinkArray();
      return removed;
    };
    Denque.prototype.splice = function splice(index, count) {
      var i = index;
      if (i !== (i | 0)) {
        return void 0;
      }
      var size = this.size();
      if (i < 0) i += size;
      if (i > size) return void 0;
      if (arguments.length > 2) {
        var k;
        var temp;
        var removed;
        var arg_len = arguments.length;
        var len = this._list.length;
        var arguments_index = 2;
        if (!size || i < size / 2) {
          temp = new Array(i);
          for (k = 0; k < i; k++) {
            temp[k] = this._list[this._head + k & this._capacityMask];
          }
          if (count === 0) {
            removed = [];
            if (i > 0) {
              this._head = this._head + i + len & this._capacityMask;
            }
          } else {
            removed = this.remove(i, count);
            this._head = this._head + i + len & this._capacityMask;
          }
          while (arg_len > arguments_index) {
            this.unshift(arguments[--arg_len]);
          }
          for (k = i; k > 0; k--) {
            this.unshift(temp[k - 1]);
          }
        } else {
          temp = new Array(size - (i + count));
          var leng = temp.length;
          for (k = 0; k < leng; k++) {
            temp[k] = this._list[this._head + i + count + k & this._capacityMask];
          }
          if (count === 0) {
            removed = [];
            if (i != size) {
              this._tail = this._head + i + len & this._capacityMask;
            }
          } else {
            removed = this.remove(i, count);
            this._tail = this._tail - leng + len & this._capacityMask;
          }
          while (arguments_index < arg_len) {
            this.push(arguments[arguments_index++]);
          }
          for (k = 0; k < leng; k++) {
            this.push(temp[k]);
          }
        }
        return removed;
      } else {
        return this.remove(i, count);
      }
    };
    Denque.prototype.clear = function clear() {
      this._list = new Array(this._list.length);
      this._head = 0;
      this._tail = 0;
    };
    Denque.prototype.isEmpty = function isEmpty() {
      return this._head === this._tail;
    };
    Denque.prototype.toArray = function toArray() {
      return this._copyArray(false);
    };
    Denque.prototype._fromArray = function _fromArray(array) {
      var length = array.length;
      var capacity = this._nextPowerOf2(length);
      this._list = new Array(capacity);
      this._capacityMask = capacity - 1;
      this._tail = length;
      for (var i = 0; i < length; i++) this._list[i] = array[i];
    };
    Denque.prototype._copyArray = function _copyArray(fullCopy, size) {
      var src = this._list;
      var capacity = src.length;
      var length = this.length;
      size = size | length;
      if (size == length && this._head < this._tail) {
        return this._list.slice(this._head, this._tail);
      }
      var dest = new Array(size);
      var k = 0;
      var i;
      if (fullCopy || this._head > this._tail) {
        for (i = this._head; i < capacity; i++) dest[k++] = src[i];
        for (i = 0; i < this._tail; i++) dest[k++] = src[i];
      } else {
        for (i = this._head; i < this._tail; i++) dest[k++] = src[i];
      }
      return dest;
    };
    Denque.prototype._growArray = function _growArray() {
      if (this._head != 0) {
        var newList = this._copyArray(true, this._list.length << 1);
        this._tail = this._list.length;
        this._head = 0;
        this._list = newList;
      } else {
        this._tail = this._list.length;
        this._list.length <<= 1;
      }
      this._capacityMask = this._capacityMask << 1 | 1;
    };
    Denque.prototype._shrinkArray = function _shrinkArray() {
      this._list.length >>>= 1;
      this._capacityMask >>>= 1;
    };
    Denque.prototype._nextPowerOf2 = function _nextPowerOf2(num) {
      var log2 = Math.log(num) / Math.log(2);
      var nextPow2 = 1 << log2 + 1;
      return Math.max(nextPow2, 4);
    };
    module.exports = Denque;
  }
});

// browser-external:net
var require_net = __commonJS({
  "browser-external:net"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "net" has been externalized for browser compatibility. Cannot access "net.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/mariadb/lib/const/error-code.js
var require_error_code = __commonJS({
  "node_modules/mariadb/lib/const/error-code.js"(exports, module) {
    "use strict";
    var codes = {};
    codes[120] = "HA_ERR_KEY_NOT_FOUND";
    codes[121] = "HA_ERR_FOUND_DUPP_KEY";
    codes[122] = "HA_ERR_INTERNAL_ERROR";
    codes[123] = "HA_ERR_RECORD_CHANGED";
    codes[124] = "HA_ERR_WRONG_INDEX";
    codes[126] = "HA_ERR_CRASHED";
    codes[127] = "HA_ERR_WRONG_IN_RECORD";
    codes[128] = "HA_ERR_OUT_OF_MEM";
    codes[130] = "HA_ERR_NOT_A_TABLE";
    codes[131] = "HA_ERR_WRONG_COMMAND";
    codes[132] = "HA_ERR_OLD_FILE";
    codes[133] = "HA_ERR_NO_ACTIVE_RECORD";
    codes[134] = "HA_ERR_RECORD_DELETED";
    codes[135] = "HA_ERR_RECORD_FILE_FULL";
    codes[136] = "HA_ERR_INDEX_FILE_FULL";
    codes[137] = "HA_ERR_END_OF_FILE";
    codes[138] = "HA_ERR_UNSUPPORTED";
    codes[139] = "HA_ERR_TO_BIG_ROW";
    codes[140] = "HA_WRONG_CREATE_OPTION";
    codes[141] = "HA_ERR_FOUND_DUPP_UNIQUE";
    codes[142] = "HA_ERR_UNKNOWN_CHARSET";
    codes[143] = "HA_ERR_WRONG_MRG_TABLE_DEF";
    codes[144] = "HA_ERR_CRASHED_ON_REPAIR";
    codes[145] = "HA_ERR_CRASHED_ON_USAGE";
    codes[146] = "HA_ERR_LOCK_WAIT_TIMEOUT";
    codes[147] = "HA_ERR_LOCK_TABLE_FULL";
    codes[148] = "HA_ERR_READ_ONLY_TRANSACTION";
    codes[149] = "HA_ERR_LOCK_DEADLOCK";
    codes[150] = "HA_ERR_CANNOT_ADD_FOREIGN";
    codes[151] = "HA_ERR_NO_REFERENCED_ROW";
    codes[152] = "HA_ERR_ROW_IS_REFERENCED";
    codes[153] = "HA_ERR_NO_SAVEPOINT";
    codes[154] = "HA_ERR_NON_UNIQUE_BLOCK_SIZE";
    codes[155] = "HA_ERR_NO_SUCH_TABLE";
    codes[156] = "HA_ERR_TABLE_EXIST";
    codes[157] = "HA_ERR_NO_CONNECTION";
    codes[158] = "HA_ERR_NULL_IN_SPATIAL";
    codes[159] = "HA_ERR_TABLE_DEF_CHANGED";
    codes[160] = "HA_ERR_NO_PARTITION_FOUND";
    codes[161] = "HA_ERR_RBR_LOGGING_FAILED";
    codes[162] = "HA_ERR_DROP_INDEX_FK";
    codes[163] = "HA_ERR_FOREIGN_DUPLICATE_KEY";
    codes[164] = "HA_ERR_TABLE_NEEDS_UPGRADE";
    codes[165] = "HA_ERR_TABLE_READONLY";
    codes[166] = "HA_ERR_AUTOINC_READ_FAILED";
    codes[167] = "HA_ERR_AUTOINC_ERANGE";
    codes[168] = "HA_ERR_GENERIC";
    codes[169] = "HA_ERR_RECORD_IS_THE_SAME";
    codes[170] = "HA_ERR_LOGGING_IMPOSSIBLE";
    codes[171] = "HA_ERR_CORRUPT_EVENT";
    codes[172] = "HA_ERR_NEW_FILE";
    codes[173] = "HA_ERR_ROWS_EVENT_APPLY";
    codes[174] = "HA_ERR_INITIALIZATION";
    codes[175] = "HA_ERR_FILE_TOO_SHORT";
    codes[176] = "HA_ERR_WRONG_CRC";
    codes[177] = "HA_ERR_TOO_MANY_CONCURRENT_TRXS";
    codes[178] = "HA_ERR_NOT_IN_LOCK_PARTITIONS";
    codes[179] = "HA_ERR_INDEX_COL_TOO_LONG";
    codes[180] = "HA_ERR_INDEX_CORRUPT";
    codes[181] = "HA_ERR_UNDO_REC_TOO_BIG";
    codes[182] = "HA_FTS_INVALID_DOCID";
    codes[184] = "HA_ERR_TABLESPACE_EXISTS";
    codes[185] = "HA_ERR_TOO_MANY_FIELDS";
    codes[186] = "HA_ERR_ROW_IN_WRONG_PARTITION";
    codes[187] = "HA_ERR_ROW_NOT_VISIBLE";
    codes[188] = "HA_ERR_ABORTED_BY_USER";
    codes[189] = "HA_ERR_DISK_FULL";
    codes[190] = "HA_ERR_INCOMPATIBLE_DEFINITION";
    codes[191] = "HA_ERR_FTS_TOO_MANY_WORDS_IN_PHRASE";
    codes[192] = "HA_ERR_DECRYPTION_FAILED";
    codes[193] = "HA_ERR_FK_DEPTH_EXCEEDED";
    codes[194] = "HA_ERR_TABLESPACE_MISSING";
    codes[195] = "HA_ERR_SEQUENCE_INVALID_DATA";
    codes[196] = "HA_ERR_SEQUENCE_RUN_OUT";
    codes[197] = "HA_ERR_COMMIT_ERROR";
    codes[198] = "HA_ERR_PARTITION_LIST";
    codes[1e3] = "ER_HASHCHK";
    codes[1001] = "ER_NISAMCHK";
    codes[1002] = "ER_NO";
    codes[1003] = "ER_YES";
    codes[1004] = "ER_CANT_CREATE_FILE";
    codes[1005] = "ER_CANT_CREATE_TABLE";
    codes[1006] = "ER_CANT_CREATE_DB";
    codes[1007] = "ER_DB_CREATE_EXISTS";
    codes[1008] = "ER_DB_DROP_EXISTS";
    codes[1009] = "ER_DB_DROP_DELETE";
    codes[1010] = "ER_DB_DROP_RMDIR";
    codes[1011] = "ER_CANT_DELETE_FILE";
    codes[1012] = "ER_CANT_FIND_SYSTEM_REC";
    codes[1013] = "ER_CANT_GET_STAT";
    codes[1014] = "ER_CANT_GET_WD";
    codes[1015] = "ER_CANT_LOCK";
    codes[1016] = "ER_CANT_OPEN_FILE";
    codes[1017] = "ER_FILE_NOT_FOUND";
    codes[1018] = "ER_CANT_READ_DIR";
    codes[1019] = "ER_CANT_SET_WD";
    codes[1020] = "ER_CHECKREAD";
    codes[1021] = "ER_DISK_FULL";
    codes[1022] = "ER_DUP_KEY";
    codes[1023] = "ER_ERROR_ON_CLOSE";
    codes[1024] = "ER_ERROR_ON_READ";
    codes[1025] = "ER_ERROR_ON_RENAME";
    codes[1026] = "ER_ERROR_ON_WRITE";
    codes[1027] = "ER_FILE_USED";
    codes[1028] = "ER_FILSORT_ABORT";
    codes[1029] = "ER_FORM_NOT_FOUND";
    codes[1030] = "ER_GET_ERRNO";
    codes[1031] = "ER_ILLEGAL_HA";
    codes[1032] = "ER_KEY_NOT_FOUND";
    codes[1033] = "ER_NOT_FORM_FILE";
    codes[1034] = "ER_NOT_KEYFILE";
    codes[1035] = "ER_OLD_KEYFILE";
    codes[1036] = "ER_OPEN_AS_READONLY";
    codes[1037] = "ER_OUTOFMEMORY";
    codes[1038] = "ER_OUT_OF_SORTMEMORY";
    codes[1039] = "ER_UNEXPECTED_EOF";
    codes[1040] = "ER_CON_COUNT_ERROR";
    codes[1041] = "ER_OUT_OF_RESOURCES";
    codes[1042] = "ER_BAD_HOST_ERROR";
    codes[1043] = "ER_HANDSHAKE_ERROR";
    codes[1044] = "ER_DBACCESS_DENIED_ERROR";
    codes[1045] = "ER_ACCESS_DENIED_ERROR";
    codes[1046] = "ER_NO_DB_ERROR";
    codes[1047] = "ER_UNKNOWN_COM_ERROR";
    codes[1048] = "ER_BAD_NULL_ERROR";
    codes[1049] = "ER_BAD_DB_ERROR";
    codes[1050] = "ER_TABLE_EXISTS_ERROR";
    codes[1051] = "ER_BAD_TABLE_ERROR";
    codes[1052] = "ER_NON_UNIQ_ERROR";
    codes[1053] = "ER_SERVER_SHUTDOWN";
    codes[1054] = "ER_BAD_FIELD_ERROR";
    codes[1055] = "ER_WRONG_FIELD_WITH_GROUP";
    codes[1056] = "ER_WRONG_GROUP_FIELD";
    codes[1057] = "ER_WRONG_SUM_SELECT";
    codes[1058] = "ER_WRONG_VALUE_COUNT";
    codes[1059] = "ER_TOO_LONG_IDENT";
    codes[1060] = "ER_DUP_FIELDNAME";
    codes[1061] = "ER_DUP_KEYNAME";
    codes[1062] = "ER_DUP_ENTRY";
    codes[1063] = "ER_WRONG_FIELD_SPEC";
    codes[1064] = "ER_PARSE_ERROR";
    codes[1065] = "ER_EMPTY_QUERY";
    codes[1066] = "ER_NONUNIQ_TABLE";
    codes[1067] = "ER_INVALID_DEFAULT";
    codes[1068] = "ER_MULTIPLE_PRI_KEY";
    codes[1069] = "ER_TOO_MANY_KEYS";
    codes[1070] = "ER_TOO_MANY_KEY_PARTS";
    codes[1071] = "ER_TOO_LONG_KEY";
    codes[1072] = "ER_KEY_COLUMN_DOES_NOT_EXIST";
    codes[1073] = "ER_BLOB_USED_AS_KEY";
    codes[1074] = "ER_TOO_BIG_FIELDLENGTH";
    codes[1075] = "ER_WRONG_AUTO_KEY";
    codes[1076] = "ER_BINLOG_CANT_DELETE_GTID_DOMAIN";
    codes[1077] = "ER_NORMAL_SHUTDOWN";
    codes[1078] = "ER_GOT_SIGNAL";
    codes[1079] = "ER_SHUTDOWN_COMPLETE";
    codes[1080] = "ER_FORCING_CLOSE";
    codes[1081] = "ER_IPSOCK_ERROR";
    codes[1082] = "ER_NO_SUCH_INDEX";
    codes[1083] = "ER_WRONG_FIELD_TERMINATORS";
    codes[1084] = "ER_BLOBS_AND_NO_TERMINATED";
    codes[1085] = "ER_TEXTFILE_NOT_READABLE";
    codes[1086] = "ER_FILE_EXISTS_ERROR";
    codes[1087] = "ER_LOAD_INFO";
    codes[1088] = "ER_ALTER_INFO";
    codes[1089] = "ER_WRONG_SUB_KEY";
    codes[1090] = "ER_CANT_REMOVE_ALL_FIELDS";
    codes[1091] = "ER_CANT_DROP_FIELD_OR_KEY";
    codes[1092] = "ER_INSERT_INFO";
    codes[1093] = "ER_UPDATE_TABLE_USED";
    codes[1094] = "ER_NO_SUCH_THREAD";
    codes[1095] = "ER_KILL_DENIED_ERROR";
    codes[1096] = "ER_NO_TABLES_USED";
    codes[1097] = "ER_TOO_BIG_SET";
    codes[1098] = "ER_NO_UNIQUE_LOGFILE";
    codes[1099] = "ER_TABLE_NOT_LOCKED_FOR_WRITE";
    codes[1100] = "ER_TABLE_NOT_LOCKED";
    codes[1101] = "ER_UNUSED_17";
    codes[1102] = "ER_WRONG_DB_NAME";
    codes[1103] = "ER_WRONG_TABLE_NAME";
    codes[1104] = "ER_TOO_BIG_SELECT";
    codes[1105] = "ER_UNKNOWN_ERROR";
    codes[1106] = "ER_UNKNOWN_PROCEDURE";
    codes[1107] = "ER_WRONG_PARAMCOUNT_TO_PROCEDURE";
    codes[1108] = "ER_WRONG_PARAMETERS_TO_PROCEDURE";
    codes[1109] = "ER_UNKNOWN_TABLE";
    codes[1110] = "ER_FIELD_SPECIFIED_TWICE";
    codes[1111] = "ER_INVALID_GROUP_FUNC_USE";
    codes[1112] = "ER_UNSUPPORTED_EXTENSION";
    codes[1113] = "ER_TABLE_MUST_HAVE_COLUMNS";
    codes[1114] = "ER_RECORD_FILE_FULL";
    codes[1115] = "ER_UNKNOWN_CHARACTER_SET";
    codes[1116] = "ER_TOO_MANY_TABLES";
    codes[1117] = "ER_TOO_MANY_FIELDS";
    codes[1118] = "ER_TOO_BIG_ROWSIZE";
    codes[1119] = "ER_STACK_OVERRUN";
    codes[1120] = "ER_WRONG_OUTER_JOIN";
    codes[1121] = "ER_NULL_COLUMN_IN_INDEX";
    codes[1122] = "ER_CANT_FIND_UDF";
    codes[1123] = "ER_CANT_INITIALIZE_UDF";
    codes[1124] = "ER_UDF_NO_PATHS";
    codes[1125] = "ER_UDF_EXISTS";
    codes[1126] = "ER_CANT_OPEN_LIBRARY";
    codes[1127] = "ER_CANT_FIND_DL_ENTRY";
    codes[1128] = "ER_FUNCTION_NOT_DEFINED";
    codes[1129] = "ER_HOST_IS_BLOCKED";
    codes[1130] = "ER_HOST_NOT_PRIVILEGED";
    codes[1131] = "ER_PASSWORD_ANONYMOUS_USER";
    codes[1132] = "ER_PASSWORD_NOT_ALLOWED";
    codes[1133] = "ER_PASSWORD_NO_MATCH";
    codes[1134] = "ER_UPDATE_INFO";
    codes[1135] = "ER_CANT_CREATE_THREAD";
    codes[1136] = "ER_WRONG_VALUE_COUNT_ON_ROW";
    codes[1137] = "ER_CANT_REOPEN_TABLE";
    codes[1138] = "ER_INVALID_USE_OF_NULL";
    codes[1139] = "ER_REGEXP_ERROR";
    codes[1140] = "ER_MIX_OF_GROUP_FUNC_AND_FIELDS";
    codes[1141] = "ER_NONEXISTING_GRANT";
    codes[1142] = "ER_TABLEACCESS_DENIED_ERROR";
    codes[1143] = "ER_COLUMNACCESS_DENIED_ERROR";
    codes[1144] = "ER_ILLEGAL_GRANT_FOR_TABLE";
    codes[1145] = "ER_GRANT_WRONG_HOST_OR_USER";
    codes[1146] = "ER_NO_SUCH_TABLE";
    codes[1147] = "ER_NONEXISTING_TABLE_GRANT";
    codes[1148] = "ER_NOT_ALLOWED_COMMAND";
    codes[1149] = "ER_SYNTAX_ERROR";
    codes[1150] = "ER_DELAYED_CANT_CHANGE_LOCK";
    codes[1151] = "ER_TOO_MANY_DELAYED_THREADS";
    codes[1152] = "ER_ABORTING_CONNECTION";
    codes[1153] = "ER_NET_PACKET_TOO_LARGE";
    codes[1154] = "ER_NET_READ_ERROR_FROM_PIPE";
    codes[1155] = "ER_NET_FCNTL_ERROR";
    codes[1156] = "ER_NET_PACKETS_OUT_OF_ORDER";
    codes[1157] = "ER_NET_UNCOMPRESS_ERROR";
    codes[1158] = "ER_NET_READ_ERROR";
    codes[1159] = "ER_NET_READ_INTERRUPTED";
    codes[1160] = "ER_NET_ERROR_ON_WRITE";
    codes[1161] = "ER_NET_WRITE_INTERRUPTED";
    codes[1162] = "ER_TOO_LONG_STRING";
    codes[1163] = "ER_TABLE_CANT_HANDLE_BLOB";
    codes[1164] = "ER_TABLE_CANT_HANDLE_AUTO_INCREMENT";
    codes[1165] = "ER_DELAYED_INSERT_TABLE_LOCKED";
    codes[1166] = "ER_WRONG_COLUMN_NAME";
    codes[1167] = "ER_WRONG_KEY_COLUMN";
    codes[1168] = "ER_WRONG_MRG_TABLE";
    codes[1169] = "ER_DUP_UNIQUE";
    codes[1170] = "ER_BLOB_KEY_WITHOUT_LENGTH";
    codes[1171] = "ER_PRIMARY_CANT_HAVE_NULL";
    codes[1172] = "ER_TOO_MANY_ROWS";
    codes[1173] = "ER_REQUIRES_PRIMARY_KEY";
    codes[1174] = "ER_NO_RAID_COMPILED";
    codes[1175] = "ER_UPDATE_WITHOUT_KEY_IN_SAFE_MODE";
    codes[1176] = "ER_KEY_DOES_NOT_EXISTS";
    codes[1177] = "ER_CHECK_NO_SUCH_TABLE";
    codes[1178] = "ER_CHECK_NOT_IMPLEMENTED";
    codes[1179] = "ER_CANT_DO_THIS_DURING_AN_TRANSACTION";
    codes[1180] = "ER_ERROR_DURING_COMMIT";
    codes[1181] = "ER_ERROR_DURING_ROLLBACK";
    codes[1182] = "ER_ERROR_DURING_FLUSH_LOGS";
    codes[1183] = "ER_ERROR_DURING_CHECKPOINT";
    codes[1184] = "ER_NEW_ABORTING_CONNECTION";
    codes[1185] = "ER_UNUSED_10";
    codes[1186] = "ER_FLUSH_MASTER_BINLOG_CLOSED";
    codes[1187] = "ER_INDEX_REBUILD";
    codes[1188] = "ER_MASTER";
    codes[1189] = "ER_MASTER_NET_READ";
    codes[1190] = "ER_MASTER_NET_WRITE";
    codes[1191] = "ER_FT_MATCHING_KEY_NOT_FOUND";
    codes[1192] = "ER_LOCK_OR_ACTIVE_TRANSACTION";
    codes[1193] = "ER_UNKNOWN_SYSTEM_VARIABLE";
    codes[1194] = "ER_CRASHED_ON_USAGE";
    codes[1195] = "ER_CRASHED_ON_REPAIR";
    codes[1196] = "ER_WARNING_NOT_COMPLETE_ROLLBACK";
    codes[1197] = "ER_TRANS_CACHE_FULL";
    codes[1198] = "ER_SLAVE_MUST_STOP";
    codes[1199] = "ER_SLAVE_NOT_RUNNING";
    codes[1200] = "ER_BAD_SLAVE";
    codes[1201] = "ER_MASTER_INFO";
    codes[1202] = "ER_SLAVE_THREAD";
    codes[1203] = "ER_TOO_MANY_USER_CONNECTIONS";
    codes[1204] = "ER_SET_CONSTANTS_ONLY";
    codes[1205] = "ER_LOCK_WAIT_TIMEOUT";
    codes[1206] = "ER_LOCK_TABLE_FULL";
    codes[1207] = "ER_READ_ONLY_TRANSACTION";
    codes[1208] = "ER_DROP_DB_WITH_READ_LOCK";
    codes[1209] = "ER_CREATE_DB_WITH_READ_LOCK";
    codes[1210] = "ER_WRONG_ARGUMENTS";
    codes[1211] = "ER_NO_PERMISSION_TO_CREATE_USER";
    codes[1212] = "ER_UNION_TABLES_IN_DIFFERENT_DIR";
    codes[1213] = "ER_LOCK_DEADLOCK";
    codes[1214] = "ER_TABLE_CANT_HANDLE_FT";
    codes[1215] = "ER_CANNOT_ADD_FOREIGN";
    codes[1216] = "ER_NO_REFERENCED_ROW";
    codes[1217] = "ER_ROW_IS_REFERENCED";
    codes[1218] = "ER_CONNECT_TO_MASTER";
    codes[1219] = "ER_QUERY_ON_MASTER";
    codes[1220] = "ER_ERROR_WHEN_EXECUTING_COMMAND";
    codes[1221] = "ER_WRONG_USAGE";
    codes[1222] = "ER_WRONG_NUMBER_OF_COLUMNS_IN_SELECT";
    codes[1223] = "ER_CANT_UPDATE_WITH_READLOCK";
    codes[1224] = "ER_MIXING_NOT_ALLOWED";
    codes[1225] = "ER_DUP_ARGUMENT";
    codes[1226] = "ER_USER_LIMIT_REACHED";
    codes[1227] = "ER_SPECIFIC_ACCESS_DENIED_ERROR";
    codes[1228] = "ER_LOCAL_VARIABLE";
    codes[1229] = "ER_GLOBAL_VARIABLE";
    codes[1230] = "ER_NO_DEFAULT";
    codes[1231] = "ER_WRONG_VALUE_FOR_VAR";
    codes[1232] = "ER_WRONG_TYPE_FOR_VAR";
    codes[1233] = "ER_VAR_CANT_BE_READ";
    codes[1234] = "ER_CANT_USE_OPTION_HERE";
    codes[1235] = "ER_NOT_SUPPORTED_YET";
    codes[1236] = "ER_MASTER_FATAL_ERROR_READING_BINLOG";
    codes[1237] = "ER_SLAVE_IGNORED_TABLE";
    codes[1238] = "ER_INCORRECT_GLOBAL_LOCAL_VAR";
    codes[1239] = "ER_WRONG_FK_DEF";
    codes[1240] = "ER_KEY_REF_DO_NOT_MATCH_TABLE_REF";
    codes[1241] = "ER_OPERAND_COLUMNS";
    codes[1242] = "ER_SUBQUERY_NO_1_ROW";
    codes[1243] = "ER_UNKNOWN_STMT_HANDLER";
    codes[1244] = "ER_CORRUPT_HELP_DB";
    codes[1245] = "ER_CYCLIC_REFERENCE";
    codes[1246] = "ER_AUTO_CONVERT";
    codes[1247] = "ER_ILLEGAL_REFERENCE";
    codes[1248] = "ER_DERIVED_MUST_HAVE_ALIAS";
    codes[1249] = "ER_SELECT_REDUCED";
    codes[1250] = "ER_TABLENAME_NOT_ALLOWED_HERE";
    codes[1251] = "ER_NOT_SUPPORTED_AUTH_MODE";
    codes[1252] = "ER_SPATIAL_CANT_HAVE_NULL";
    codes[1253] = "ER_COLLATION_CHARSET_MISMATCH";
    codes[1254] = "ER_SLAVE_WAS_RUNNING";
    codes[1255] = "ER_SLAVE_WAS_NOT_RUNNING";
    codes[1256] = "ER_TOO_BIG_FOR_UNCOMPRESS";
    codes[1257] = "ER_ZLIB_Z_MEM_ERROR";
    codes[1258] = "ER_ZLIB_Z_BUF_ERROR";
    codes[1259] = "ER_ZLIB_Z_DATA_ERROR";
    codes[1260] = "ER_CUT_VALUE_GROUP_CONCAT";
    codes[1261] = "ER_WARN_TOO_FEW_RECORDS";
    codes[1262] = "ER_WARN_TOO_MANY_RECORDS";
    codes[1263] = "ER_WARN_NULL_TO_NOTNULL";
    codes[1264] = "ER_WARN_DATA_OUT_OF_RANGE";
    codes[1265] = "WARN_DATA_TRUNCATED";
    codes[1266] = "ER_WARN_USING_OTHER_HANDLER";
    codes[1267] = "ER_CANT_AGGREGATE_2COLLATIONS";
    codes[1268] = "ER_DROP_USER";
    codes[1269] = "ER_REVOKE_GRANTS";
    codes[1270] = "ER_CANT_AGGREGATE_3COLLATIONS";
    codes[1271] = "ER_CANT_AGGREGATE_NCOLLATIONS";
    codes[1272] = "ER_VARIABLE_IS_NOT_STRUCT";
    codes[1273] = "ER_UNKNOWN_COLLATION";
    codes[1274] = "ER_SLAVE_IGNORED_SSL_PARAMS";
    codes[1275] = "ER_SERVER_IS_IN_SECURE_AUTH_MODE";
    codes[1276] = "ER_WARN_FIELD_RESOLVED";
    codes[1277] = "ER_BAD_SLAVE_UNTIL_COND";
    codes[1278] = "ER_MISSING_SKIP_SLAVE";
    codes[1279] = "ER_UNTIL_COND_IGNORED";
    codes[1280] = "ER_WRONG_NAME_FOR_INDEX";
    codes[1281] = "ER_WRONG_NAME_FOR_CATALOG";
    codes[1282] = "ER_WARN_QC_RESIZE";
    codes[1283] = "ER_BAD_FT_COLUMN";
    codes[1284] = "ER_UNKNOWN_KEY_CACHE";
    codes[1285] = "ER_WARN_HOSTNAME_WONT_WORK";
    codes[1286] = "ER_UNKNOWN_STORAGE_ENGINE";
    codes[1287] = "ER_WARN_DEPRECATED_SYNTAX";
    codes[1288] = "ER_NON_UPDATABLE_TABLE";
    codes[1289] = "ER_FEATURE_DISABLED";
    codes[1290] = "ER_OPTION_PREVENTS_STATEMENT";
    codes[1291] = "ER_DUPLICATED_VALUE_IN_TYPE";
    codes[1292] = "ER_TRUNCATED_WRONG_VALUE";
    codes[1293] = "ER_TOO_MUCH_AUTO_TIMESTAMP_COLS";
    codes[1294] = "ER_INVALID_ON_UPDATE";
    codes[1295] = "ER_UNSUPPORTED_PS";
    codes[1296] = "ER_GET_ERRMSG";
    codes[1297] = "ER_GET_TEMPORARY_ERRMSG";
    codes[1298] = "ER_UNKNOWN_TIME_ZONE";
    codes[1299] = "ER_WARN_INVALID_TIMESTAMP";
    codes[1300] = "ER_INVALID_CHARACTER_STRING";
    codes[1301] = "ER_WARN_ALLOWED_PACKET_OVERFLOWED";
    codes[1302] = "ER_CONFLICTING_DECLARATIONS";
    codes[1303] = "ER_SP_NO_RECURSIVE_CREATE";
    codes[1304] = "ER_SP_ALREADY_EXISTS";
    codes[1305] = "ER_SP_DOES_NOT_EXIST";
    codes[1306] = "ER_SP_DROP_FAILED";
    codes[1307] = "ER_SP_STORE_FAILED";
    codes[1308] = "ER_SP_LILABEL_MISMATCH";
    codes[1309] = "ER_SP_LABEL_REDEFINE";
    codes[1310] = "ER_SP_LABEL_MISMATCH";
    codes[1311] = "ER_SP_UNINIT_VAR";
    codes[1312] = "ER_SP_BADSELECT";
    codes[1313] = "ER_SP_BADRETURN";
    codes[1314] = "ER_SP_BADSTATEMENT";
    codes[1315] = "ER_UPDATE_LOG_DEPRECATED_IGNORED";
    codes[1316] = "ER_UPDATE_LOG_DEPRECATED_TRANSLATED";
    codes[1317] = "ER_QUERY_INTERRUPTED";
    codes[1318] = "ER_SP_WRONG_NO_OF_ARGS";
    codes[1319] = "ER_SP_COND_MISMATCH";
    codes[1320] = "ER_SP_NORETURN";
    codes[1321] = "ER_SP_NORETURNEND";
    codes[1322] = "ER_SP_BAD_CURSOR_QUERY";
    codes[1323] = "ER_SP_BAD_CURSOR_SELECT";
    codes[1324] = "ER_SP_CURSOR_MISMATCH";
    codes[1325] = "ER_SP_CURSOR_ALREADY_OPEN";
    codes[1326] = "ER_SP_CURSOR_NOT_OPEN";
    codes[1327] = "ER_SP_UNDECLARED_VAR";
    codes[1328] = "ER_SP_WRONG_NO_OF_FETCH_ARGS";
    codes[1329] = "ER_SP_FETCH_NO_DATA";
    codes[1330] = "ER_SP_DUP_PARAM";
    codes[1331] = "ER_SP_DUP_VAR";
    codes[1332] = "ER_SP_DUP_COND";
    codes[1333] = "ER_SP_DUP_CURS";
    codes[1334] = "ER_SP_CANT_ALTER";
    codes[1335] = "ER_SP_SUBSELECT_NYI";
    codes[1336] = "ER_STMT_NOT_ALLOWED_IN_SF_OR_TRG";
    codes[1337] = "ER_SP_VARCOND_AFTER_CURSHNDLR";
    codes[1338] = "ER_SP_CURSOR_AFTER_HANDLER";
    codes[1339] = "ER_SP_CASE_NOT_FOUND";
    codes[1340] = "ER_FPARSER_TOO_BIG_FILE";
    codes[1341] = "ER_FPARSER_BAD_HEADER";
    codes[1342] = "ER_FPARSER_EOF_IN_COMMENT";
    codes[1343] = "ER_FPARSER_ERROR_IN_PARAMETER";
    codes[1344] = "ER_FPARSER_EOF_IN_UNKNOWN_PARAMETER";
    codes[1345] = "ER_VIEW_NO_EXPLAIN";
    codes[1346] = "ER_FRM_UNKNOWN_TYPE";
    codes[1347] = "ER_WRONG_OBJECT";
    codes[1348] = "ER_NONUPDATEABLE_COLUMN";
    codes[1349] = "ER_VIEW_SELECT_DERIVED";
    codes[1350] = "ER_VIEW_SELECT_CLAUSE";
    codes[1351] = "ER_VIEW_SELECT_VARIABLE";
    codes[1352] = "ER_VIEW_SELECT_TMPTABLE";
    codes[1353] = "ER_VIEW_WRONG_LIST";
    codes[1354] = "ER_WARN_VIEW_MERGE";
    codes[1355] = "ER_WARN_VIEW_WITHOUT_KEY";
    codes[1356] = "ER_VIEW_INVALID";
    codes[1357] = "ER_SP_NO_DROP_SP";
    codes[1358] = "ER_SP_GOTO_IN_HNDLR";
    codes[1359] = "ER_TRG_ALREADY_EXISTS";
    codes[1360] = "ER_TRG_DOES_NOT_EXIST";
    codes[1361] = "ER_TRG_ON_VIEW_OR_TEMP_TABLE";
    codes[1362] = "ER_TRG_CANT_CHANGE_ROW";
    codes[1363] = "ER_TRG_NO_SUCH_ROW_IN_TRG";
    codes[1364] = "ER_NO_DEFAULT_FOR_FIELD";
    codes[1365] = "ER_DIVISION_BY_ZERO";
    codes[1366] = "ER_TRUNCATED_WRONG_VALUE_FOR_FIELD";
    codes[1367] = "ER_ILLEGAL_VALUE_FOR_TYPE";
    codes[1368] = "ER_VIEW_NONUPD_CHECK";
    codes[1369] = "ER_VIEW_CHECK_FAILED";
    codes[1370] = "ER_PROCACCESS_DENIED_ERROR";
    codes[1371] = "ER_RELAY_LOG_FAIL";
    codes[1372] = "ER_PASSWD_LENGTH";
    codes[1373] = "ER_UNKNOWN_TARGET_BINLOG";
    codes[1374] = "ER_IO_ERR_LOG_INDEX_READ";
    codes[1375] = "ER_BINLOG_PURGE_PROHIBITED";
    codes[1376] = "ER_FSEEK_FAIL";
    codes[1377] = "ER_BINLOG_PURGE_FATAL_ERR";
    codes[1378] = "ER_LOG_IN_USE";
    codes[1379] = "ER_LOG_PURGE_UNKNOWN_ERR";
    codes[1380] = "ER_RELAY_LOG_INIT";
    codes[1381] = "ER_NO_BINARY_LOGGING";
    codes[1382] = "ER_RESERVED_SYNTAX";
    codes[1383] = "ER_WSAS_FAILED";
    codes[1384] = "ER_DIFF_GROUPS_PROC";
    codes[1385] = "ER_NO_GROUP_FOR_PROC";
    codes[1386] = "ER_ORDER_WITH_PROC";
    codes[1387] = "ER_LOGGING_PROHIBIT_CHANGING_OF";
    codes[1388] = "ER_NO_FILE_MAPPING";
    codes[1389] = "ER_WRONG_MAGIC";
    codes[1390] = "ER_PS_MANY_PARAM";
    codes[1391] = "ER_KEY_PART_0";
    codes[1392] = "ER_VIEW_CHECKSUM";
    codes[1393] = "ER_VIEW_MULTIUPDATE";
    codes[1394] = "ER_VIEW_NO_INSERT_FIELD_LIST";
    codes[1395] = "ER_VIEW_DELETE_MERGE_VIEW";
    codes[1396] = "ER_CANNOT_USER";
    codes[1397] = "ER_XAER_NOTA";
    codes[1398] = "ER_XAER_INVAL";
    codes[1399] = "ER_XAER_RMFAIL";
    codes[1400] = "ER_XAER_OUTSIDE";
    codes[1401] = "ER_XAER_RMERR";
    codes[1402] = "ER_XA_RBROLLBACK";
    codes[1403] = "ER_NONEXISTING_PROC_GRANT";
    codes[1404] = "ER_PROC_AUTO_GRANT_FAIL";
    codes[1405] = "ER_PROC_AUTO_REVOKE_FAIL";
    codes[1406] = "ER_DATA_TOO_LONG";
    codes[1407] = "ER_SP_BAD_SQLSTATE";
    codes[1408] = "ER_STARTUP";
    codes[1409] = "ER_LOAD_FROM_FIXED_SIZE_ROWS_TO_VAR";
    codes[1410] = "ER_CANT_CREATE_USER_WITH_GRANT";
    codes[1411] = "ER_WRONG_VALUE_FOR_TYPE";
    codes[1412] = "ER_TABLE_DEF_CHANGED";
    codes[1413] = "ER_SP_DUP_HANDLER";
    codes[1414] = "ER_SP_NOT_VAR_ARG";
    codes[1415] = "ER_SP_NO_RETSET";
    codes[1416] = "ER_CANT_CREATE_GEOMETRY_OBJECT";
    codes[1417] = "ER_FAILED_ROUTINE_BREAK_BINLOG";
    codes[1418] = "ER_BINLOG_UNSAFE_ROUTINE";
    codes[1419] = "ER_BINLOG_CREATE_ROUTINE_NEED_SUPER";
    codes[1420] = "ER_EXEC_STMT_WITH_OPEN_CURSOR";
    codes[1421] = "ER_STMT_HAS_NO_OPEN_CURSOR";
    codes[1422] = "ER_COMMIT_NOT_ALLOWED_IN_SF_OR_TRG";
    codes[1423] = "ER_NO_DEFAULT_FOR_VIEW_FIELD";
    codes[1424] = "ER_SP_NO_RECURSION";
    codes[1425] = "ER_TOO_BIG_SCALE";
    codes[1426] = "ER_TOO_BIG_PRECISION";
    codes[1427] = "ER_M_BIGGER_THAN_D";
    codes[1428] = "ER_WRONG_LOCK_OF_SYSTEM_TABLE";
    codes[1429] = "ER_CONNECT_TO_FOREIGN_DATA_SOURCE";
    codes[1430] = "ER_QUERY_ON_FOREIGN_DATA_SOURCE";
    codes[1431] = "ER_FOREIGN_DATA_SOURCE_DOESNT_EXIST";
    codes[1432] = "ER_FOREIGN_DATA_STRING_INVALID_CANT_CREATE";
    codes[1433] = "ER_FOREIGN_DATA_STRING_INVALID";
    codes[1434] = "ER_CANT_CREATE_FEDERATED_TABLE";
    codes[1435] = "ER_TRG_IN_WRONG_SCHEMA";
    codes[1436] = "ER_STACK_OVERRUN_NEED_MORE";
    codes[1437] = "ER_TOO_LONG_BODY";
    codes[1438] = "ER_WARN_CANT_DROP_DEFAULT_KEYCACHE";
    codes[1439] = "ER_TOO_BIG_DISPLAYWIDTH";
    codes[1440] = "ER_XAER_DUPID";
    codes[1441] = "ER_DATETIME_FUNCTION_OVERFLOW";
    codes[1442] = "ER_CANT_UPDATE_USED_TABLE_IN_SF_OR_TRG";
    codes[1443] = "ER_VIEW_PREVENT_UPDATE";
    codes[1444] = "ER_PS_NO_RECURSION";
    codes[1445] = "ER_SP_CANT_SET_AUTOCOMMIT";
    codes[1446] = "ER_MALFORMED_DEFINER";
    codes[1447] = "ER_VIEW_FRM_NO_USER";
    codes[1448] = "ER_VIEW_OTHER_USER";
    codes[1449] = "ER_NO_SUCH_USER";
    codes[1450] = "ER_FORBID_SCHEMA_CHANGE";
    codes[1451] = "ER_ROW_IS_REFERENCED_2";
    codes[1452] = "ER_NO_REFERENCED_ROW_2";
    codes[1453] = "ER_SP_BAD_VAR_SHADOW";
    codes[1454] = "ER_TRG_NO_DEFINER";
    codes[1455] = "ER_OLD_FILE_FORMAT";
    codes[1456] = "ER_SP_RECURSION_LIMIT";
    codes[1457] = "ER_SP_PROC_TABLE_CORRUPT";
    codes[1458] = "ER_SP_WRONG_NAME";
    codes[1459] = "ER_TABLE_NEEDS_UPGRADE";
    codes[1460] = "ER_SP_NO_AGGREGATE";
    codes[1461] = "ER_MAX_PREPARED_STMT_COUNT_REACHED";
    codes[1462] = "ER_VIEW_RECURSIVE";
    codes[1463] = "ER_NON_GROUPING_FIELD_USED";
    codes[1464] = "ER_TABLE_CANT_HANDLE_SPKEYS";
    codes[1465] = "ER_NO_TRIGGERS_ON_SYSTEM_SCHEMA";
    codes[1466] = "ER_REMOVED_SPACES";
    codes[1467] = "ER_AUTOINC_READ_FAILED";
    codes[1468] = "ER_USERNAME";
    codes[1469] = "ER_HOSTNAME";
    codes[1470] = "ER_WRONG_STRING_LENGTH";
    codes[1471] = "ER_NON_INSERTABLE_TABLE";
    codes[1472] = "ER_ADMIN_WRONG_MRG_TABLE";
    codes[1473] = "ER_TOO_HIGH_LEVEL_OF_NESTING_FOR_SELECT";
    codes[1474] = "ER_NAME_BECOMES_EMPTY";
    codes[1475] = "ER_AMBIGUOUS_FIELD_TERM";
    codes[1476] = "ER_FOREIGN_SERVER_EXISTS";
    codes[1477] = "ER_FOREIGN_SERVER_DOESNT_EXIST";
    codes[1478] = "ER_ILLEGAL_HA_CREATE_OPTION";
    codes[1479] = "ER_PARTITION_REQUIRES_VALUES_ERROR";
    codes[1480] = "ER_PARTITION_WRONG_VALUES_ERROR";
    codes[1481] = "ER_PARTITION_MAXVALUE_ERROR";
    codes[1482] = "ER_PARTITION_SUBPARTITION_ERROR";
    codes[1483] = "ER_PARTITION_SUBPART_MIX_ERROR";
    codes[1484] = "ER_PARTITION_WRONG_NO_PART_ERROR";
    codes[1485] = "ER_PARTITION_WRONG_NO_SUBPART_ERROR";
    codes[1486] = "ER_WRONG_EXPR_IN_PARTITION_FUNC_ERROR";
    codes[1487] = "ER_NOT_CONSTANT_EXPRESSION";
    codes[1488] = "ER_FIELD_NOT_FOUND_PART_ERROR";
    codes[1489] = "ER_LIST_OF_FIELDS_ONLY_IN_HASH_ERROR";
    codes[1490] = "ER_INCONSISTENT_PARTITION_INFO_ERROR";
    codes[1491] = "ER_PARTITION_FUNC_NOT_ALLOWED_ERROR";
    codes[1492] = "ER_PARTITIONS_MUST_BE_DEFINED_ERROR";
    codes[1493] = "ER_RANGE_NOT_INCREASING_ERROR";
    codes[1494] = "ER_INCONSISTENT_TYPE_OF_FUNCTIONS_ERROR";
    codes[1495] = "ER_MULTIPLE_DEF_CONST_IN_LIST_PART_ERROR";
    codes[1496] = "ER_PARTITION_ENTRY_ERROR";
    codes[1497] = "ER_MIX_HANDLER_ERROR";
    codes[1498] = "ER_PARTITION_NOT_DEFINED_ERROR";
    codes[1499] = "ER_TOO_MANY_PARTITIONS_ERROR";
    codes[1500] = "ER_SUBPARTITION_ERROR";
    codes[1501] = "ER_CANT_CREATE_HANDLER_FILE";
    codes[1502] = "ER_BLOB_FIELD_IN_PART_FUNC_ERROR";
    codes[1503] = "ER_UNIQUE_KEY_NEED_ALL_FIELDS_IN_PF";
    codes[1504] = "ER_NO_PARTS_ERROR";
    codes[1505] = "ER_PARTITION_MGMT_ON_NONPARTITIONED";
    codes[1506] = "ER_FEATURE_NOT_SUPPORTED_WITH_PARTITIONING";
    codes[1507] = "ER_PARTITION_DOES_NOT_EXIST";
    codes[1508] = "ER_DROP_LAST_PARTITION";
    codes[1509] = "ER_COALESCE_ONLY_ON_HASH_PARTITION";
    codes[1510] = "ER_REORG_HASH_ONLY_ON_SAME_NO";
    codes[1511] = "ER_REORG_NO_PARAM_ERROR";
    codes[1512] = "ER_ONLY_ON_RANGE_LIST_PARTITION";
    codes[1513] = "ER_ADD_PARTITION_SUBPART_ERROR";
    codes[1514] = "ER_ADD_PARTITION_NO_NEW_PARTITION";
    codes[1515] = "ER_COALESCE_PARTITION_NO_PARTITION";
    codes[1516] = "ER_REORG_PARTITION_NOT_EXIST";
    codes[1517] = "ER_SAME_NAME_PARTITION";
    codes[1518] = "ER_NO_BINLOG_ERROR";
    codes[1519] = "ER_CONSECUTIVE_REORG_PARTITIONS";
    codes[1520] = "ER_REORG_OUTSIDE_RANGE";
    codes[1521] = "ER_PARTITION_FUNCTION_FAILURE";
    codes[1522] = "ER_PART_STATE_ERROR";
    codes[1523] = "ER_LIMITED_PART_RANGE";
    codes[1524] = "ER_PLUGIN_IS_NOT_LOADED";
    codes[1525] = "ER_WRONG_VALUE";
    codes[1526] = "ER_NO_PARTITION_FOR_GIVEN_VALUE";
    codes[1527] = "ER_FILEGROUP_OPTION_ONLY_ONCE";
    codes[1528] = "ER_CREATE_FILEGROUP_FAILED";
    codes[1529] = "ER_DROP_FILEGROUP_FAILED";
    codes[1530] = "ER_TABLESPACE_AUTO_EXTEND_ERROR";
    codes[1531] = "ER_WRONG_SIZE_NUMBER";
    codes[1532] = "ER_SIZE_OVERFLOW_ERROR";
    codes[1533] = "ER_ALTER_FILEGROUP_FAILED";
    codes[1534] = "ER_BINLOG_ROW_LOGGING_FAILED";
    codes[1535] = "ER_BINLOG_ROW_WRONG_TABLE_DEF";
    codes[1536] = "ER_BINLOG_ROW_RBR_TO_SBR";
    codes[1537] = "ER_EVENT_ALREADY_EXISTS";
    codes[1538] = "ER_EVENT_STORE_FAILED";
    codes[1539] = "ER_EVENT_DOES_NOT_EXIST";
    codes[1540] = "ER_EVENT_CANT_ALTER";
    codes[1541] = "ER_EVENT_DROP_FAILED";
    codes[1542] = "ER_EVENT_INTERVAL_NOT_POSITIVE_OR_TOO_BIG";
    codes[1543] = "ER_EVENT_ENDS_BEFORE_STARTS";
    codes[1544] = "ER_EVENT_EXEC_TIME_IN_THE_PAST";
    codes[1545] = "ER_EVENT_OPEN_TABLE_FAILED";
    codes[1546] = "ER_EVENT_NEITHER_M_EXPR_NOR_M_AT";
    codes[1547] = "ER_UNUSED_2";
    codes[1548] = "ER_UNUSED_3";
    codes[1549] = "ER_EVENT_CANNOT_DELETE";
    codes[1550] = "ER_EVENT_COMPILE_ERROR";
    codes[1551] = "ER_EVENT_SAME_NAME";
    codes[1552] = "ER_EVENT_DATA_TOO_LONG";
    codes[1553] = "ER_DROP_INDEX_FK";
    codes[1554] = "ER_WARN_DEPRECATED_SYNTAX_WITH_VER";
    codes[1555] = "ER_CANT_WRITE_LOCK_LOG_TABLE";
    codes[1556] = "ER_CANT_LOCK_LOG_TABLE";
    codes[1557] = "ER_UNUSED_4";
    codes[1558] = "ER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE";
    codes[1559] = "ER_TEMP_TABLE_PREVENTS_SWITCH_OUT_OF_RBR";
    codes[1560] = "ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_FORMAT";
    codes[1561] = "ER_UNUSED_13";
    codes[1562] = "ER_PARTITION_NO_TEMPORARY";
    codes[1563] = "ER_PARTITION_CONST_DOMAIN_ERROR";
    codes[1564] = "ER_PARTITION_FUNCTION_IS_NOT_ALLOWED";
    codes[1565] = "ER_DDL_LOG_ERROR";
    codes[1566] = "ER_NULL_IN_VALUES_LESS_THAN";
    codes[1567] = "ER_WRONG_PARTITION_NAME";
    codes[1568] = "ER_CANT_CHANGE_TX_CHARACTERISTICS";
    codes[1569] = "ER_DUP_ENTRY_AUTOINCREMENT_CASE";
    codes[1570] = "ER_EVENT_MODIFY_QUEUE_ERROR";
    codes[1571] = "ER_EVENT_SET_VAR_ERROR";
    codes[1572] = "ER_PARTITION_MERGE_ERROR";
    codes[1573] = "ER_CANT_ACTIVATE_LOG";
    codes[1574] = "ER_RBR_NOT_AVAILABLE";
    codes[1575] = "ER_BASE64_DECODE_ERROR";
    codes[1576] = "ER_EVENT_RECURSION_FORBIDDEN";
    codes[1577] = "ER_EVENTS_DB_ERROR";
    codes[1578] = "ER_ONLY_INTEGERS_ALLOWED";
    codes[1579] = "ER_UNSUPORTED_LOG_ENGINE";
    codes[1580] = "ER_BAD_LOG_STATEMENT";
    codes[1581] = "ER_CANT_RENAME_LOG_TABLE";
    codes[1582] = "ER_WRONG_PARAMCOUNT_TO_NATIVE_FCT";
    codes[1583] = "ER_WRONG_PARAMETERS_TO_NATIVE_FCT";
    codes[1584] = "ER_WRONG_PARAMETERS_TO_STORED_FCT";
    codes[1585] = "ER_NATIVE_FCT_NAME_COLLISION";
    codes[1586] = "ER_DUP_ENTRY_WITH_KEY_NAME";
    codes[1587] = "ER_BINLOG_PURGE_EMFILE";
    codes[1588] = "ER_EVENT_CANNOT_CREATE_IN_THE_PAST";
    codes[1589] = "ER_EVENT_CANNOT_ALTER_IN_THE_PAST";
    codes[1590] = "ER_SLAVE_INCIDENT";
    codes[1591] = "ER_NO_PARTITION_FOR_GIVEN_VALUE_SILENT";
    codes[1592] = "ER_BINLOG_UNSAFE_STATEMENT";
    codes[1593] = "ER_SLAVE_FATAL_ERROR";
    codes[1594] = "ER_SLAVE_RELAY_LOG_READ_FAILURE";
    codes[1595] = "ER_SLAVE_RELAY_LOG_WRITE_FAILURE";
    codes[1596] = "ER_SLAVE_CREATE_EVENT_FAILURE";
    codes[1597] = "ER_SLAVE_MASTER_COM_FAILURE";
    codes[1598] = "ER_BINLOG_LOGGING_IMPOSSIBLE";
    codes[1599] = "ER_VIEW_NO_CREATION_CTX";
    codes[1600] = "ER_VIEW_INVALID_CREATION_CTX";
    codes[1601] = "ER_SR_INVALID_CREATION_CTX";
    codes[1602] = "ER_TRG_CORRUPTED_FILE";
    codes[1603] = "ER_TRG_NO_CREATION_CTX";
    codes[1604] = "ER_TRG_INVALID_CREATION_CTX";
    codes[1605] = "ER_EVENT_INVALID_CREATION_CTX";
    codes[1606] = "ER_TRG_CANT_OPEN_TABLE";
    codes[1607] = "ER_CANT_CREATE_SROUTINE";
    codes[1608] = "ER_UNUSED_11";
    codes[1609] = "ER_NO_FORMAT_DESCRIPTION_EVENT_BEFORE_BINLOG_STATEMENT";
    codes[1610] = "ER_SLAVE_CORRUPT_EVENT";
    codes[1611] = "ER_LOAD_DATA_INVALID_COLUMN";
    codes[1612] = "ER_LOG_PURGE_NO_FILE";
    codes[1613] = "ER_XA_RBTIMEOUT";
    codes[1614] = "ER_XA_RBDEADLOCK";
    codes[1615] = "ER_NEED_REPREPARE";
    codes[1616] = "ER_DELAYED_NOT_SUPPORTED";
    codes[1617] = "WARN_NO_MASTER_INFO";
    codes[1618] = "WARN_OPTION_IGNORED";
    codes[1619] = "ER_PLUGIN_DELETE_BUILTIN";
    codes[1620] = "WARN_PLUGIN_BUSY";
    codes[1621] = "ER_VARIABLE_IS_READONLY";
    codes[1622] = "ER_WARN_ENGINE_TRANSACTION_ROLLBACK";
    codes[1623] = "ER_SLAVE_HEARTBEAT_FAILURE";
    codes[1624] = "ER_SLAVE_HEARTBEAT_VALUE_OUT_OF_RANGE";
    codes[1625] = "ER_UNUSED_14";
    codes[1626] = "ER_CONFLICT_FN_PARSE_ERROR";
    codes[1627] = "ER_EXCEPTIONS_WRITE_ERROR";
    codes[1628] = "ER_TOO_LONG_TABLE_COMMENT";
    codes[1629] = "ER_TOO_LONG_FIELD_COMMENT";
    codes[1630] = "ER_FUNC_INEXISTENT_NAME_COLLISION";
    codes[1631] = "ER_DATABASE_NAME";
    codes[1632] = "ER_TABLE_NAME";
    codes[1633] = "ER_PARTITION_NAME";
    codes[1634] = "ER_SUBPARTITION_NAME";
    codes[1635] = "ER_TEMPORARY_NAME";
    codes[1636] = "ER_RENAMED_NAME";
    codes[1637] = "ER_TOO_MANY_CONCURRENT_TRXS";
    codes[1638] = "WARN_NON_ASCII_SEPARATOR_NOT_IMPLEMENTED";
    codes[1639] = "ER_DEBUG_SYNC_TIMEOUT";
    codes[1640] = "ER_DEBUG_SYNC_HIT_LIMIT";
    codes[1641] = "ER_DUP_SIGNAL_SET";
    codes[1642] = "ER_SIGNAL_WARN";
    codes[1643] = "ER_SIGNAL_NOT_FOUND";
    codes[1644] = "ER_SIGNAL_EXCEPTION";
    codes[1645] = "ER_RESIGNAL_WITHOUT_ACTIVE_HANDLER";
    codes[1646] = "ER_SIGNAL_BAD_CONDITION_TYPE";
    codes[1647] = "WARN_COND_ITEM_TRUNCATED";
    codes[1648] = "ER_COND_ITEM_TOO_LONG";
    codes[1649] = "ER_UNKNOWN_LOCALE";
    codes[1650] = "ER_SLAVE_IGNORE_SERVER_IDS";
    codes[1651] = "ER_QUERY_CACHE_DISABLED";
    codes[1652] = "ER_SAME_NAME_PARTITION_FIELD";
    codes[1653] = "ER_PARTITION_COLUMN_LIST_ERROR";
    codes[1654] = "ER_WRONG_TYPE_COLUMN_VALUE_ERROR";
    codes[1655] = "ER_TOO_MANY_PARTITION_FUNC_FIELDS_ERROR";
    codes[1656] = "ER_MAXVALUE_IN_VALUES_IN";
    codes[1657] = "ER_TOO_MANY_VALUES_ERROR";
    codes[1658] = "ER_ROW_SINGLE_PARTITION_FIELD_ERROR";
    codes[1659] = "ER_FIELD_TYPE_NOT_ALLOWED_AS_PARTITION_FIELD";
    codes[1660] = "ER_PARTITION_FIELDS_TOO_LONG";
    codes[1661] = "ER_BINLOG_ROW_ENGINE_AND_STMT_ENGINE";
    codes[1662] = "ER_BINLOG_ROW_MODE_AND_STMT_ENGINE";
    codes[1663] = "ER_BINLOG_UNSAFE_AND_STMT_ENGINE";
    codes[1664] = "ER_BINLOG_ROW_INJECTION_AND_STMT_ENGINE";
    codes[1665] = "ER_BINLOG_STMT_MODE_AND_ROW_ENGINE";
    codes[1666] = "ER_BINLOG_ROW_INJECTION_AND_STMT_MODE";
    codes[1667] = "ER_BINLOG_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE";
    codes[1668] = "ER_BINLOG_UNSAFE_LIMIT";
    codes[1669] = "ER_BINLOG_UNSAFE_INSERT_DELAYED";
    codes[1670] = "ER_BINLOG_UNSAFE_SYSTEM_TABLE";
    codes[1671] = "ER_BINLOG_UNSAFE_AUTOINC_COLUMNS";
    codes[1672] = "ER_BINLOG_UNSAFE_UDF";
    codes[1673] = "ER_BINLOG_UNSAFE_SYSTEM_VARIABLE";
    codes[1674] = "ER_BINLOG_UNSAFE_SYSTEM_FUNCTION";
    codes[1675] = "ER_BINLOG_UNSAFE_NONTRANS_AFTER_TRANS";
    codes[1676] = "ER_MESSAGE_AND_STATEMENT";
    codes[1677] = "ER_SLAVE_CONVERSION_FAILED";
    codes[1678] = "ER_SLAVE_CANT_CREATE_CONVERSION";
    codes[1679] = "ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_FORMAT";
    codes[1680] = "ER_PATH_LENGTH";
    codes[1681] = "ER_WARN_DEPRECATED_SYNTAX_NO_REPLACEMENT";
    codes[1682] = "ER_WRONG_NATIVE_TABLE_STRUCTURE";
    codes[1683] = "ER_WRONG_PERFSCHEMA_USAGE";
    codes[1684] = "ER_WARN_I_S_SKIPPED_TABLE";
    codes[1685] = "ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_BINLOG_DIRECT";
    codes[1686] = "ER_STORED_FUNCTION_PREVENTS_SWITCH_BINLOG_DIRECT";
    codes[1687] = "ER_SPATIAL_MUST_HAVE_GEOM_COL";
    codes[1688] = "ER_TOO_LONG_INDEX_COMMENT";
    codes[1689] = "ER_LOCK_ABORTED";
    codes[1690] = "ER_DATA_OUT_OF_RANGE";
    codes[1691] = "ER_WRONG_SPVAR_TYPE_IN_LIMIT";
    codes[1692] = "ER_BINLOG_UNSAFE_MULTIPLE_ENGINES_AND_SELF_LOGGING_ENGINE";
    codes[1693] = "ER_BINLOG_UNSAFE_MIXED_STATEMENT";
    codes[1694] = "ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_SQL_LOG_BIN";
    codes[1695] = "ER_STORED_FUNCTION_PREVENTS_SWITCH_SQL_LOG_BIN";
    codes[1696] = "ER_FAILED_READ_FROM_PAR_FILE";
    codes[1697] = "ER_VALUES_IS_NOT_INT_TYPE_ERROR";
    codes[1698] = "ER_ACCESS_DENIED_NO_PASSWORD_ERROR";
    codes[1699] = "ER_SET_PASSWORD_AUTH_PLUGIN";
    codes[1700] = "ER_GRANT_PLUGIN_USER_EXISTS";
    codes[1701] = "ER_TRUNCATE_ILLEGAL_FK";
    codes[1702] = "ER_PLUGIN_IS_PERMANENT";
    codes[1703] = "ER_SLAVE_HEARTBEAT_VALUE_OUT_OF_RANGE_MIN";
    codes[1704] = "ER_SLAVE_HEARTBEAT_VALUE_OUT_OF_RANGE_MAX";
    codes[1705] = "ER_STMT_CACHE_FULL";
    codes[1706] = "ER_MULTI_UPDATE_KEY_CONFLICT";
    codes[1707] = "ER_TABLE_NEEDS_REBUILD";
    codes[1708] = "WARN_OPTION_BELOW_LIMIT";
    codes[1709] = "ER_INDEX_COLUMN_TOO_LONG";
    codes[1710] = "ER_ERROR_IN_TRIGGER_BODY";
    codes[1711] = "ER_ERROR_IN_UNKNOWN_TRIGGER_BODY";
    codes[1712] = "ER_INDEX_CORRUPT";
    codes[1713] = "ER_UNDO_RECORD_TOO_BIG";
    codes[1714] = "ER_BINLOG_UNSAFE_INSERT_IGNORE_SELECT";
    codes[1715] = "ER_BINLOG_UNSAFE_INSERT_SELECT_UPDATE";
    codes[1716] = "ER_BINLOG_UNSAFE_REPLACE_SELECT";
    codes[1717] = "ER_BINLOG_UNSAFE_CREATE_IGNORE_SELECT";
    codes[1718] = "ER_BINLOG_UNSAFE_CREATE_REPLACE_SELECT";
    codes[1719] = "ER_BINLOG_UNSAFE_UPDATE_IGNORE";
    codes[1720] = "ER_UNUSED_15";
    codes[1721] = "ER_UNUSED_16";
    codes[1722] = "ER_BINLOG_UNSAFE_WRITE_AUTOINC_SELECT";
    codes[1723] = "ER_BINLOG_UNSAFE_CREATE_SELECT_AUTOINC";
    codes[1724] = "ER_BINLOG_UNSAFE_INSERT_TWO_KEYS";
    codes[1725] = "ER_UNUSED_28";
    codes[1726] = "ER_VERS_NOT_ALLOWED";
    codes[1727] = "ER_BINLOG_UNSAFE_AUTOINC_NOT_FIRST";
    codes[1728] = "ER_CANNOT_LOAD_FROM_TABLE_V2";
    codes[1729] = "ER_MASTER_DELAY_VALUE_OUT_OF_RANGE";
    codes[1730] = "ER_ONLY_FD_AND_RBR_EVENTS_ALLOWED_IN_BINLOG_STATEMENT";
    codes[1731] = "ER_PARTITION_EXCHANGE_DIFFERENT_OPTION";
    codes[1732] = "ER_PARTITION_EXCHANGE_PART_TABLE";
    codes[1733] = "ER_PARTITION_EXCHANGE_TEMP_TABLE";
    codes[1734] = "ER_PARTITION_INSTEAD_OF_SUBPARTITION";
    codes[1735] = "ER_UNKNOWN_PARTITION";
    codes[1736] = "ER_TABLES_DIFFERENT_METADATA";
    codes[1737] = "ER_ROW_DOES_NOT_MATCH_PARTITION";
    codes[1738] = "ER_BINLOG_CACHE_SIZE_GREATER_THAN_MAX";
    codes[1739] = "ER_WARN_INDEX_NOT_APPLICABLE";
    codes[1740] = "ER_PARTITION_EXCHANGE_FOREIGN_KEY";
    codes[1741] = "ER_NO_SUCH_KEY_VALUE";
    codes[1742] = "ER_VALUE_TOO_LONG";
    codes[1743] = "ER_NETWORK_READ_EVENT_CHECKSUM_FAILURE";
    codes[1744] = "ER_BINLOG_READ_EVENT_CHECKSUM_FAILURE";
    codes[1745] = "ER_BINLOG_STMT_CACHE_SIZE_GREATER_THAN_MAX";
    codes[1746] = "ER_CANT_UPDATE_TABLE_IN_CREATE_TABLE_SELECT";
    codes[1747] = "ER_PARTITION_CLAUSE_ON_NONPARTITIONED";
    codes[1748] = "ER_ROW_DOES_NOT_MATCH_GIVEN_PARTITION_SET";
    codes[1749] = "ER_UNUSED_5";
    codes[1750] = "ER_CHANGE_RPL_INFO_REPOSITORY_FAILURE";
    codes[1751] = "ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_CREATED_TEMP_TABLE";
    codes[1752] = "ER_WARNING_NOT_COMPLETE_ROLLBACK_WITH_DROPPED_TEMP_TABLE";
    codes[1753] = "ER_MTS_FEATURE_IS_NOT_SUPPORTED";
    codes[1754] = "ER_MTS_UPDATED_DBS_GREATER_MAX";
    codes[1755] = "ER_MTS_CANT_PARALLEL";
    codes[1756] = "ER_MTS_INCONSISTENT_DATA";
    codes[1757] = "ER_FULLTEXT_NOT_SUPPORTED_WITH_PARTITIONING";
    codes[1758] = "ER_DA_INVALID_CONDITION_NUMBER";
    codes[1759] = "ER_INSECURE_PLAIN_TEXT";
    codes[1760] = "ER_INSECURE_CHANGE_MASTER";
    codes[1761] = "ER_FOREIGN_DUPLICATE_KEY_WITH_CHILD_INFO";
    codes[1762] = "ER_FOREIGN_DUPLICATE_KEY_WITHOUT_CHILD_INFO";
    codes[1763] = "ER_SQLTHREAD_WITH_SECURE_SLAVE";
    codes[1764] = "ER_TABLE_HAS_NO_FT";
    codes[1765] = "ER_VARIABLE_NOT_SETTABLE_IN_SF_OR_TRIGGER";
    codes[1766] = "ER_VARIABLE_NOT_SETTABLE_IN_TRANSACTION";
    codes[1767] = "ER_GTID_NEXT_IS_NOT_IN_GTID_NEXT_LIST";
    codes[1768] = "ER_CANT_CHANGE_GTID_NEXT_IN_TRANSACTION_WHEN_GTID_NEXT_LIST_IS_NULL";
    codes[1769] = "ER_SET_STATEMENT_CANNOT_INVOKE_FUNCTION";
    codes[1770] = "ER_GTID_NEXT_CANT_BE_AUTOMATIC_IF_GTID_NEXT_LIST_IS_NON_NULL";
    codes[1771] = "ER_SKIPPING_LOGGED_TRANSACTION";
    codes[1772] = "ER_MALFORMED_GTID_SET_SPECIFICATION";
    codes[1773] = "ER_MALFORMED_GTID_SET_ENCODING";
    codes[1774] = "ER_MALFORMED_GTID_SPECIFICATION";
    codes[1775] = "ER_GNO_EXHAUSTED";
    codes[1776] = "ER_BAD_SLAVE_AUTO_POSITION";
    codes[1777] = "ER_AUTO_POSITION_REQUIRES_GTID_MODE_ON";
    codes[1778] = "ER_CANT_DO_IMPLICIT_COMMIT_IN_TRX_WHEN_GTID_NEXT_IS_SET";
    codes[1779] = "ER_GTID_MODE_2_OR_3_REQUIRES_ENFORCE_GTID_CONSISTENCY_ON";
    codes[1780] = "ER_GTID_MODE_REQUIRES_BINLOG";
    codes[1781] = "ER_CANT_SET_GTID_NEXT_TO_GTID_WHEN_GTID_MODE_IS_OFF";
    codes[1782] = "ER_CANT_SET_GTID_NEXT_TO_ANONYMOUS_WHEN_GTID_MODE_IS_ON";
    codes[1783] = "ER_CANT_SET_GTID_NEXT_LIST_TO_NON_NULL_WHEN_GTID_MODE_IS_OFF";
    codes[1784] = "ER_FOUND_GTID_EVENT_WHEN_GTID_MODE_IS_OFF";
    codes[1785] = "ER_GTID_UNSAFE_NON_TRANSACTIONAL_TABLE";
    codes[1786] = "ER_GTID_UNSAFE_CREATE_SELECT";
    codes[1787] = "ER_GTID_UNSAFE_CREATE_DROP_TEMPORARY_TABLE_IN_TRANSACTION";
    codes[1788] = "ER_GTID_MODE_CAN_ONLY_CHANGE_ONE_STEP_AT_A_TIME";
    codes[1789] = "ER_MASTER_HAS_PURGED_REQUIRED_GTIDS";
    codes[1790] = "ER_CANT_SET_GTID_NEXT_WHEN_OWNING_GTID";
    codes[1791] = "ER_UNKNOWN_EXPLAIN_FORMAT";
    codes[1792] = "ER_CANT_EXECUTE_IN_READ_ONLY_TRANSACTION";
    codes[1793] = "ER_TOO_LONG_TABLE_PARTITION_COMMENT";
    codes[1794] = "ER_SLAVE_CONFIGURATION";
    codes[1795] = "ER_INNODB_FT_LIMIT";
    codes[1796] = "ER_INNODB_NO_FT_TEMP_TABLE";
    codes[1797] = "ER_INNODB_FT_WRONG_DOCID_COLUMN";
    codes[1798] = "ER_INNODB_FT_WRONG_DOCID_INDEX";
    codes[1799] = "ER_INNODB_ONLINE_LOG_TOO_BIG";
    codes[1800] = "ER_UNKNOWN_ALTER_ALGORITHM";
    codes[1801] = "ER_UNKNOWN_ALTER_LOCK";
    codes[1802] = "ER_MTS_CHANGE_MASTER_CANT_RUN_WITH_GAPS";
    codes[1803] = "ER_MTS_RECOVERY_FAILURE";
    codes[1804] = "ER_MTS_RESET_WORKERS";
    codes[1805] = "ER_COL_COUNT_DOESNT_MATCH_CORRUPTED_V2";
    codes[1806] = "ER_SLAVE_SILENT_RETRY_TRANSACTION";
    codes[1807] = "ER_UNUSED_22";
    codes[1808] = "ER_TABLE_SCHEMA_MISMATCH";
    codes[1809] = "ER_TABLE_IN_SYSTEM_TABLESPACE";
    codes[1810] = "ER_IO_READ_ERROR";
    codes[1811] = "ER_IO_WRITE_ERROR";
    codes[1812] = "ER_TABLESPACE_MISSING";
    codes[1813] = "ER_TABLESPACE_EXISTS";
    codes[1814] = "ER_TABLESPACE_DISCARDED";
    codes[1815] = "ER_INTERNAL_ERROR";
    codes[1816] = "ER_INNODB_IMPORT_ERROR";
    codes[1817] = "ER_INNODB_INDEX_CORRUPT";
    codes[1818] = "ER_INVALID_YEAR_COLUMN_LENGTH";
    codes[1819] = "ER_NOT_VALID_PASSWORD";
    codes[1820] = "ER_MUST_CHANGE_PASSWORD";
    codes[1821] = "ER_FK_NO_INDEX_CHILD";
    codes[1822] = "ER_FK_NO_INDEX_PARENT";
    codes[1823] = "ER_FK_FAIL_ADD_SYSTEM";
    codes[1824] = "ER_FK_CANNOT_OPEN_PARENT";
    codes[1825] = "ER_FK_INCORRECT_OPTION";
    codes[1826] = "ER_DUP_CONSTRAINT_NAME";
    codes[1827] = "ER_PASSWORD_FORMAT";
    codes[1828] = "ER_FK_COLUMN_CANNOT_DROP";
    codes[1829] = "ER_FK_COLUMN_CANNOT_DROP_CHILD";
    codes[1830] = "ER_FK_COLUMN_NOT_NULL";
    codes[1831] = "ER_DUP_INDEX";
    codes[1832] = "ER_FK_COLUMN_CANNOT_CHANGE";
    codes[1833] = "ER_FK_COLUMN_CANNOT_CHANGE_CHILD";
    codes[1834] = "ER_FK_CANNOT_DELETE_PARENT";
    codes[1835] = "ER_MALFORMED_PACKET";
    codes[1836] = "ER_READ_ONLY_MODE";
    codes[1837] = "ER_GTID_NEXT_TYPE_UNDEFINED_GROUP";
    codes[1838] = "ER_VARIABLE_NOT_SETTABLE_IN_SP";
    codes[1839] = "ER_CANT_SET_GTID_PURGED_WHEN_GTID_MODE_IS_OFF";
    codes[1840] = "ER_CANT_SET_GTID_PURGED_WHEN_GTID_EXECUTED_IS_NOT_EMPTY";
    codes[1841] = "ER_CANT_SET_GTID_PURGED_WHEN_OWNED_GTIDS_IS_NOT_EMPTY";
    codes[1842] = "ER_GTID_PURGED_WAS_CHANGED";
    codes[1843] = "ER_GTID_EXECUTED_WAS_CHANGED";
    codes[1844] = "ER_BINLOG_STMT_MODE_AND_NO_REPL_TABLES";
    codes[1845] = "ER_ALTER_OPERATION_NOT_SUPPORTED";
    codes[1846] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON";
    codes[1847] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COPY";
    codes[1848] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_PARTITION";
    codes[1849] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FK_RENAME";
    codes[1850] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_COLUMN_TYPE";
    codes[1851] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FK_CHECK";
    codes[1852] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_IGNORE";
    codes[1853] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_NOPK";
    codes[1854] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_AUTOINC";
    codes[1855] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_HIDDEN_FTS";
    codes[1856] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_CHANGE_FTS";
    codes[1857] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_FTS";
    codes[1858] = "ER_SQL_SLAVE_SKIP_COUNTER_NOT_SETTABLE_IN_GTID_MODE";
    codes[1859] = "ER_DUP_UNKNOWN_IN_INDEX";
    codes[1860] = "ER_IDENT_CAUSES_TOO_LONG_PATH";
    codes[1861] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_NOT_NULL";
    codes[1862] = "ER_MUST_CHANGE_PASSWORD_LOGIN";
    codes[1863] = "ER_ROW_IN_WRONG_PARTITION";
    codes[1864] = "ER_MTS_EVENT_BIGGER_PENDING_JOBS_SIZE_MAX";
    codes[1865] = "ER_INNODB_NO_FT_USES_PARSER";
    codes[1866] = "ER_BINLOG_LOGICAL_CORRUPTION";
    codes[1867] = "ER_WARN_PURGE_LOG_IN_USE";
    codes[1868] = "ER_WARN_PURGE_LOG_IS_ACTIVE";
    codes[1869] = "ER_AUTO_INCREMENT_CONFLICT";
    codes[1870] = "WARN_ON_BLOCKHOLE_IN_RBR";
    codes[1871] = "ER_SLAVE_MI_INIT_REPOSITORY";
    codes[1872] = "ER_SLAVE_RLI_INIT_REPOSITORY";
    codes[1873] = "ER_ACCESS_DENIED_CHANGE_USER_ERROR";
    codes[1874] = "ER_INNODB_READ_ONLY";
    codes[1875] = "ER_STOP_SLAVE_SQL_THREAD_TIMEOUT";
    codes[1876] = "ER_STOP_SLAVE_IO_THREAD_TIMEOUT";
    codes[1877] = "ER_TABLE_CORRUPT";
    codes[1878] = "ER_TEMP_FILE_WRITE_FAILURE";
    codes[1879] = "ER_INNODB_FT_AUX_NOT_HEX_ID";
    codes[1880] = "ER_LAST_MYSQL_ERROR_MESSAGE";
    codes[1900] = "ER_UNUSED_18";
    codes[1901] = "ER_GENERATED_COLUMN_FUNCTION_IS_NOT_ALLOWED";
    codes[1902] = "ER_UNUSED_19";
    codes[1903] = "ER_PRIMARY_KEY_BASED_ON_GENERATED_COLUMN";
    codes[1904] = "ER_KEY_BASED_ON_GENERATED_VIRTUAL_COLUMN";
    codes[1905] = "ER_WRONG_FK_OPTION_FOR_GENERATED_COLUMN";
    codes[1906] = "ER_WARNING_NON_DEFAULT_VALUE_FOR_GENERATED_COLUMN";
    codes[1907] = "ER_UNSUPPORTED_ACTION_ON_GENERATED_COLUMN";
    codes[1908] = "ER_UNUSED_20";
    codes[1909] = "ER_UNUSED_21";
    codes[1910] = "ER_UNSUPPORTED_ENGINE_FOR_GENERATED_COLUMNS";
    codes[1911] = "ER_UNKNOWN_OPTION";
    codes[1912] = "ER_BAD_OPTION_VALUE";
    codes[1913] = "ER_UNUSED_6";
    codes[1914] = "ER_UNUSED_7";
    codes[1915] = "ER_UNUSED_8";
    codes[1916] = "ER_DATA_OVERFLOW";
    codes[1917] = "ER_DATA_TRUNCATED";
    codes[1918] = "ER_BAD_DATA";
    codes[1919] = "ER_DYN_COL_WRONG_FORMAT";
    codes[1920] = "ER_DYN_COL_IMPLEMENTATION_LIMIT";
    codes[1921] = "ER_DYN_COL_DATA";
    codes[1922] = "ER_DYN_COL_WRONG_CHARSET";
    codes[1923] = "ER_ILLEGAL_SUBQUERY_OPTIMIZER_SWITCHES";
    codes[1924] = "ER_QUERY_CACHE_IS_DISABLED";
    codes[1925] = "ER_QUERY_CACHE_IS_GLOBALY_DISABLED";
    codes[1926] = "ER_VIEW_ORDERBY_IGNORED";
    codes[1927] = "ER_CONNECTION_KILLED";
    codes[1928] = "ER_UNUSED_12";
    codes[1929] = "ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_SKIP_REPLICATION";
    codes[1930] = "ER_STORED_FUNCTION_PREVENTS_SWITCH_SKIP_REPLICATION";
    codes[1931] = "ER_QUERY_EXCEEDED_ROWS_EXAMINED_LIMIT";
    codes[1932] = "ER_NO_SUCH_TABLE_IN_ENGINE";
    codes[1933] = "ER_TARGET_NOT_EXPLAINABLE";
    codes[1934] = "ER_CONNECTION_ALREADY_EXISTS";
    codes[1935] = "ER_MASTER_LOG_PREFIX";
    codes[1936] = "ER_CANT_START_STOP_SLAVE";
    codes[1937] = "ER_SLAVE_STARTED";
    codes[1938] = "ER_SLAVE_STOPPED";
    codes[1939] = "ER_SQL_DISCOVER_ERROR";
    codes[1940] = "ER_FAILED_GTID_STATE_INIT";
    codes[1941] = "ER_INCORRECT_GTID_STATE";
    codes[1942] = "ER_CANNOT_UPDATE_GTID_STATE";
    codes[1943] = "ER_DUPLICATE_GTID_DOMAIN";
    codes[1944] = "ER_GTID_OPEN_TABLE_FAILED";
    codes[1945] = "ER_GTID_POSITION_NOT_FOUND_IN_BINLOG";
    codes[1946] = "ER_CANNOT_LOAD_SLAVE_GTID_STATE";
    codes[1947] = "ER_MASTER_GTID_POS_CONFLICTS_WITH_BINLOG";
    codes[1948] = "ER_MASTER_GTID_POS_MISSING_DOMAIN";
    codes[1949] = "ER_UNTIL_REQUIRES_USING_GTID";
    codes[1950] = "ER_GTID_STRICT_OUT_OF_ORDER";
    codes[1951] = "ER_GTID_START_FROM_BINLOG_HOLE";
    codes[1952] = "ER_SLAVE_UNEXPECTED_MASTER_SWITCH";
    codes[1953] = "ER_INSIDE_TRANSACTION_PREVENTS_SWITCH_GTID_DOMAIN_ID_SEQ_NO";
    codes[1954] = "ER_STORED_FUNCTION_PREVENTS_SWITCH_GTID_DOMAIN_ID_SEQ_NO";
    codes[1955] = "ER_GTID_POSITION_NOT_FOUND_IN_BINLOG2";
    codes[1956] = "ER_BINLOG_MUST_BE_EMPTY";
    codes[1957] = "ER_NO_SUCH_QUERY";
    codes[1958] = "ER_BAD_BASE64_DATA";
    codes[1959] = "ER_INVALID_ROLE";
    codes[1960] = "ER_INVALID_CURRENT_USER";
    codes[1961] = "ER_CANNOT_GRANT_ROLE";
    codes[1962] = "ER_CANNOT_REVOKE_ROLE";
    codes[1963] = "ER_CHANGE_SLAVE_PARALLEL_THREADS_ACTIVE";
    codes[1964] = "ER_PRIOR_COMMIT_FAILED";
    codes[1965] = "ER_IT_IS_A_VIEW";
    codes[1966] = "ER_SLAVE_SKIP_NOT_IN_GTID";
    codes[1967] = "ER_TABLE_DEFINITION_TOO_BIG";
    codes[1968] = "ER_PLUGIN_INSTALLED";
    codes[1969] = "ER_STATEMENT_TIMEOUT";
    codes[1970] = "ER_SUBQUERIES_NOT_SUPPORTED";
    codes[1971] = "ER_SET_STATEMENT_NOT_SUPPORTED";
    codes[1972] = "ER_UNUSED_9";
    codes[1973] = "ER_USER_CREATE_EXISTS";
    codes[1974] = "ER_USER_DROP_EXISTS";
    codes[1975] = "ER_ROLE_CREATE_EXISTS";
    codes[1976] = "ER_ROLE_DROP_EXISTS";
    codes[1977] = "ER_CANNOT_CONVERT_CHARACTER";
    codes[1978] = "ER_INVALID_DEFAULT_VALUE_FOR_FIELD";
    codes[1979] = "ER_KILL_QUERY_DENIED_ERROR";
    codes[1980] = "ER_NO_EIS_FOR_FIELD";
    codes[1981] = "ER_WARN_AGGFUNC_DEPENDENCE";
    codes[1982] = "WARN_INNODB_PARTITION_OPTION_IGNORED";
    codes[3e3] = "ER_FILE_CORRUPT";
    codes[3001] = "ER_ERROR_ON_MASTER";
    codes[3002] = "ER_INCONSISTENT_ERROR";
    codes[3003] = "ER_STORAGE_ENGINE_NOT_LOADED";
    codes[3004] = "ER_GET_STACKED_DA_WITHOUT_ACTIVE_HANDLER";
    codes[3005] = "ER_WARN_LEGACY_SYNTAX_CONVERTED";
    codes[3006] = "ER_BINLOG_UNSAFE_FULLTEXT_PLUGIN";
    codes[3007] = "ER_CANNOT_DISCARD_TEMPORARY_TABLE";
    codes[3008] = "ER_FK_DEPTH_EXCEEDED";
    codes[3009] = "ER_COL_COUNT_DOESNT_MATCH_PLEASE_UPDATE_V2";
    codes[3010] = "ER_WARN_TRIGGER_DOESNT_HAVE_CREATED";
    codes[3011] = "ER_REFERENCED_TRG_DOES_NOT_EXIST_MYSQL";
    codes[3012] = "ER_EXPLAIN_NOT_SUPPORTED";
    codes[3013] = "ER_INVALID_FIELD_SIZE";
    codes[3014] = "ER_MISSING_HA_CREATE_OPTION";
    codes[3015] = "ER_ENGINE_OUT_OF_MEMORY";
    codes[3016] = "ER_PASSWORD_EXPIRE_ANONYMOUS_USER";
    codes[3017] = "ER_SLAVE_SQL_THREAD_MUST_STOP";
    codes[3018] = "ER_NO_FT_MATERIALIZED_SUBQUERY";
    codes[3019] = "ER_INNODB_UNDO_LOG_FULL";
    codes[3020] = "ER_INVALID_ARGUMENT_FOR_LOGARITHM";
    codes[3021] = "ER_SLAVE_CHANNEL_IO_THREAD_MUST_STOP";
    codes[3022] = "ER_WARN_OPEN_TEMP_TABLES_MUST_BE_ZERO";
    codes[3023] = "ER_WARN_ONLY_MASTER_LOG_FILE_NO_POS";
    codes[3024] = "ER_QUERY_TIMEOUT";
    codes[3025] = "ER_NON_RO_SELECT_DISABLE_TIMER";
    codes[3026] = "ER_DUP_LIST_ENTRY";
    codes[3027] = "ER_SQL_MODE_NO_EFFECT";
    codes[3028] = "ER_AGGREGATE_ORDER_FOR_UNION";
    codes[3029] = "ER_AGGREGATE_ORDER_NON_AGG_QUERY";
    codes[3030] = "ER_SLAVE_WORKER_STOPPED_PREVIOUS_THD_ERROR";
    codes[3031] = "ER_DONT_SUPPORT_SLAVE_PRESERVE_COMMIT_ORDER";
    codes[3032] = "ER_SERVER_OFFLINE_MODE";
    codes[3033] = "ER_GIS_DIFFERENT_SRIDS";
    codes[3034] = "ER_GIS_UNSUPPORTED_ARGUMENT";
    codes[3035] = "ER_GIS_UNKNOWN_ERROR";
    codes[3036] = "ER_GIS_UNKNOWN_EXCEPTION";
    codes[3037] = "ER_GIS_INVALID_DATA";
    codes[3038] = "ER_BOOST_GEOMETRY_EMPTY_INPUT_EXCEPTION";
    codes[3039] = "ER_BOOST_GEOMETRY_CENTROID_EXCEPTION";
    codes[3040] = "ER_BOOST_GEOMETRY_OVERLAY_INVALID_INPUT_EXCEPTION";
    codes[3041] = "ER_BOOST_GEOMETRY_TURN_INFO_EXCEPTION";
    codes[3042] = "ER_BOOST_GEOMETRY_SELF_INTERSECTION_POINT_EXCEPTION";
    codes[3043] = "ER_BOOST_GEOMETRY_UNKNOWN_EXCEPTION";
    codes[3044] = "ER_STD_BAD_ALLOC_ERROR";
    codes[3045] = "ER_STD_DOMAIN_ERROR";
    codes[3046] = "ER_STD_LENGTH_ERROR";
    codes[3047] = "ER_STD_INVALID_ARGUMENT";
    codes[3048] = "ER_STD_OUT_OF_RANGE_ERROR";
    codes[3049] = "ER_STD_OVERFLOW_ERROR";
    codes[3050] = "ER_STD_RANGE_ERROR";
    codes[3051] = "ER_STD_UNDERFLOW_ERROR";
    codes[3052] = "ER_STD_LOGIC_ERROR";
    codes[3053] = "ER_STD_RUNTIME_ERROR";
    codes[3054] = "ER_STD_UNKNOWN_EXCEPTION";
    codes[3055] = "ER_GIS_DATA_WRONG_ENDIANESS";
    codes[3056] = "ER_CHANGE_MASTER_PASSWORD_LENGTH";
    codes[3057] = "ER_USER_LOCK_WRONG_NAME";
    codes[3058] = "ER_USER_LOCK_DEADLOCK";
    codes[3059] = "ER_REPLACE_INACCESSIBLE_ROWS";
    codes[3060] = "ER_ALTER_OPERATION_NOT_SUPPORTED_REASON_GIS";
    codes[4e3] = "ER_UNUSED_26";
    codes[4001] = "ER_UNUSED_27";
    codes[4002] = "ER_WITH_COL_WRONG_LIST";
    codes[4003] = "ER_TOO_MANY_DEFINITIONS_IN_WITH_CLAUSE";
    codes[4004] = "ER_DUP_QUERY_NAME";
    codes[4005] = "ER_RECURSIVE_WITHOUT_ANCHORS";
    codes[4006] = "ER_UNACCEPTABLE_MUTUAL_RECURSION";
    codes[4007] = "ER_REF_TO_RECURSIVE_WITH_TABLE_IN_DERIVED";
    codes[4008] = "ER_NOT_STANDARD_COMPLIANT_RECURSIVE";
    codes[4009] = "ER_WRONG_WINDOW_SPEC_NAME";
    codes[4010] = "ER_DUP_WINDOW_NAME";
    codes[4011] = "ER_PARTITION_LIST_IN_REFERENCING_WINDOW_SPEC";
    codes[4012] = "ER_ORDER_LIST_IN_REFERENCING_WINDOW_SPEC";
    codes[4013] = "ER_WINDOW_FRAME_IN_REFERENCED_WINDOW_SPEC";
    codes[4014] = "ER_BAD_COMBINATION_OF_WINDOW_FRAME_BOUND_SPECS";
    codes[4015] = "ER_WRONG_PLACEMENT_OF_WINDOW_FUNCTION";
    codes[4016] = "ER_WINDOW_FUNCTION_IN_WINDOW_SPEC";
    codes[4017] = "ER_NOT_ALLOWED_WINDOW_FRAME";
    codes[4018] = "ER_NO_ORDER_LIST_IN_WINDOW_SPEC";
    codes[4019] = "ER_RANGE_FRAME_NEEDS_SIMPLE_ORDERBY";
    codes[4020] = "ER_WRONG_TYPE_FOR_ROWS_FRAME";
    codes[4021] = "ER_WRONG_TYPE_FOR_RANGE_FRAME";
    codes[4022] = "ER_FRAME_EXCLUSION_NOT_SUPPORTED";
    codes[4023] = "ER_WINDOW_FUNCTION_DONT_HAVE_FRAME";
    codes[4024] = "ER_INVALID_NTILE_ARGUMENT";
    codes[4025] = "ER_CONSTRAINT_FAILED";
    codes[4026] = "ER_EXPRESSION_IS_TOO_BIG";
    codes[4027] = "ER_ERROR_EVALUATING_EXPRESSION";
    codes[4028] = "ER_CALCULATING_DEFAULT_VALUE";
    codes[4029] = "ER_EXPRESSION_REFERS_TO_UNINIT_FIELD";
    codes[4030] = "ER_PARTITION_DEFAULT_ERROR";
    codes[4031] = "ER_REFERENCED_TRG_DOES_NOT_EXIST";
    codes[4032] = "ER_INVALID_DEFAULT_PARAM";
    codes[4033] = "ER_BINLOG_NON_SUPPORTED_BULK";
    codes[4034] = "ER_BINLOG_UNCOMPRESS_ERROR";
    codes[4035] = "ER_JSON_BAD_CHR";
    codes[4036] = "ER_JSON_NOT_JSON_CHR";
    codes[4037] = "ER_JSON_EOS";
    codes[4038] = "ER_JSON_SYNTAX";
    codes[4039] = "ER_JSON_ESCAPING";
    codes[4040] = "ER_JSON_DEPTH";
    codes[4041] = "ER_JSON_PATH_EOS";
    codes[4042] = "ER_JSON_PATH_SYNTAX";
    codes[4043] = "ER_JSON_PATH_DEPTH";
    codes[4044] = "ER_JSON_PATH_NO_WILDCARD";
    codes[4045] = "ER_JSON_PATH_ARRAY";
    codes[4046] = "ER_JSON_ONE_OR_ALL";
    codes[4047] = "ER_UNSUPPORTED_COMPRESSED_TABLE";
    codes[4048] = "ER_GEOJSON_INCORRECT";
    codes[4049] = "ER_GEOJSON_TOO_FEW_POINTS";
    codes[4050] = "ER_GEOJSON_NOT_CLOSED";
    codes[4051] = "ER_JSON_PATH_EMPTY";
    codes[4052] = "ER_SLAVE_SAME_ID";
    codes[4053] = "ER_FLASHBACK_NOT_SUPPORTED";
    codes[4054] = "ER_KEYS_OUT_OF_ORDER";
    codes[4055] = "ER_OVERLAPPING_KEYS";
    codes[4056] = "ER_REQUIRE_ROW_BINLOG_FORMAT";
    codes[4057] = "ER_ISOLATION_MODE_NOT_SUPPORTED";
    codes[4058] = "ER_ON_DUPLICATE_DISABLED";
    codes[4059] = "ER_UPDATES_WITH_CONSISTENT_SNAPSHOT";
    codes[4060] = "ER_ROLLBACK_ONLY";
    codes[4061] = "ER_ROLLBACK_TO_SAVEPOINT";
    codes[4062] = "ER_ISOLATION_LEVEL_WITH_CONSISTENT_SNAPSHOT";
    codes[4063] = "ER_UNSUPPORTED_COLLATION";
    codes[4064] = "ER_METADATA_INCONSISTENCY";
    codes[4065] = "ER_CF_DIFFERENT";
    codes[4066] = "ER_RDB_TTL_DURATION_FORMAT";
    codes[4067] = "ER_RDB_STATUS_GENERAL";
    codes[4068] = "ER_RDB_STATUS_MSG";
    codes[4069] = "ER_RDB_TTL_UNSUPPORTED";
    codes[4070] = "ER_RDB_TTL_COL_FORMAT";
    codes[4071] = "ER_PER_INDEX_CF_DEPRECATED";
    codes[4072] = "ER_KEY_CREATE_DURING_ALTER";
    codes[4073] = "ER_SK_POPULATE_DURING_ALTER";
    codes[4074] = "ER_SUM_FUNC_WITH_WINDOW_FUNC_AS_ARG";
    codes[4075] = "ER_NET_OK_PACKET_TOO_LARGE";
    codes[4076] = "ER_GEOJSON_EMPTY_COORDINATES";
    codes[4077] = "ER_MYROCKS_CANT_NOPAD_COLLATION";
    codes[4078] = "ER_ILLEGAL_PARAMETER_DATA_TYPES2_FOR_OPERATION";
    codes[4079] = "ER_ILLEGAL_PARAMETER_DATA_TYPE_FOR_OPERATION";
    codes[4080] = "ER_WRONG_PARAMCOUNT_TO_CURSOR";
    codes[4081] = "ER_UNKNOWN_STRUCTURED_VARIABLE";
    codes[4082] = "ER_ROW_VARIABLE_DOES_NOT_HAVE_FIELD";
    codes[4083] = "ER_END_IDENTIFIER_DOES_NOT_MATCH";
    codes[4084] = "ER_SEQUENCE_RUN_OUT";
    codes[4085] = "ER_SEQUENCE_INVALID_DATA";
    codes[4086] = "ER_SEQUENCE_INVALID_TABLE_STRUCTURE";
    codes[4087] = "ER_SEQUENCE_ACCESS_ERROR";
    codes[4088] = "ER_SEQUENCE_BINLOG_FORMAT";
    codes[4089] = "ER_NOT_SEQUENCE";
    codes[4090] = "ER_NOT_SEQUENCE2";
    codes[4091] = "ER_UNKNOWN_SEQUENCES";
    codes[4092] = "ER_UNKNOWN_VIEW";
    codes[4093] = "ER_WRONG_INSERT_INTO_SEQUENCE";
    codes[4094] = "ER_SP_STACK_TRACE";
    codes[4095] = "ER_PACKAGE_ROUTINE_IN_SPEC_NOT_DEFINED_IN_BODY";
    codes[4096] = "ER_PACKAGE_ROUTINE_FORWARD_DECLARATION_NOT_DEFINED";
    codes[4097] = "ER_COMPRESSED_COLUMN_USED_AS_KEY";
    codes[4098] = "ER_UNKNOWN_COMPRESSION_METHOD";
    codes[4099] = "ER_WRONG_NUMBER_OF_VALUES_IN_TVC";
    codes[4100] = "ER_FIELD_REFERENCE_IN_TVC";
    codes[4101] = "ER_WRONG_TYPE_FOR_PERCENTILE_FUNC";
    codes[4102] = "ER_ARGUMENT_NOT_CONSTANT";
    codes[4103] = "ER_ARGUMENT_OUT_OF_RANGE";
    codes[4104] = "ER_WRONG_TYPE_OF_ARGUMENT";
    codes[4105] = "ER_NOT_AGGREGATE_FUNCTION";
    codes[4106] = "ER_INVALID_AGGREGATE_FUNCTION";
    codes[4107] = "ER_INVALID_VALUE_TO_LIMIT";
    codes[4108] = "ER_INVISIBLE_NOT_NULL_WITHOUT_DEFAULT";
    codes[4109] = "ER_UPDATE_INFO_WITH_SYSTEM_VERSIONING";
    codes[4110] = "ER_VERS_FIELD_WRONG_TYPE";
    codes[4111] = "ER_VERS_ENGINE_UNSUPPORTED";
    codes[4112] = "ER_UNUSED_23";
    codes[4113] = "ER_PARTITION_WRONG_TYPE";
    codes[4114] = "WARN_VERS_PART_FULL";
    codes[4115] = "WARN_VERS_PARAMETERS";
    codes[4116] = "ER_VERS_DROP_PARTITION_INTERVAL";
    codes[4117] = "ER_UNUSED_25";
    codes[4118] = "WARN_VERS_PART_NON_HISTORICAL";
    codes[4119] = "ER_VERS_ALTER_NOT_ALLOWED";
    codes[4120] = "ER_VERS_ALTER_ENGINE_PROHIBITED";
    codes[4121] = "ER_VERS_RANGE_PROHIBITED";
    codes[4122] = "ER_CONFLICTING_FOR_SYSTEM_TIME";
    codes[4123] = "ER_VERS_TABLE_MUST_HAVE_COLUMNS";
    codes[4124] = "ER_VERS_NOT_VERSIONED";
    codes[4125] = "ER_MISSING";
    codes[4126] = "ER_VERS_PERIOD_COLUMNS";
    codes[4127] = "ER_PART_WRONG_VALUE";
    codes[4128] = "ER_VERS_WRONG_PARTS";
    codes[4129] = "ER_VERS_NO_TRX_ID";
    codes[4130] = "ER_VERS_ALTER_SYSTEM_FIELD";
    codes[4131] = "ER_DROP_VERSIONING_SYSTEM_TIME_PARTITION";
    codes[4132] = "ER_VERS_DB_NOT_SUPPORTED";
    codes[4133] = "ER_VERS_TRT_IS_DISABLED";
    codes[4134] = "ER_VERS_DUPLICATE_ROW_START_END";
    codes[4135] = "ER_VERS_ALREADY_VERSIONED";
    codes[4136] = "ER_UNUSED_24";
    codes[4137] = "ER_VERS_NOT_SUPPORTED";
    codes[4138] = "ER_VERS_TRX_PART_HISTORIC_ROW_NOT_SUPPORTED";
    codes[4139] = "ER_INDEX_FILE_FULL";
    codes[4140] = "ER_UPDATED_COLUMN_ONLY_ONCE";
    codes[4141] = "ER_EMPTY_ROW_IN_TVC";
    codes[4142] = "ER_VERS_QUERY_IN_PARTITION";
    codes[4143] = "ER_KEY_DOESNT_SUPPORT";
    codes[4144] = "ER_ALTER_OPERATION_TABLE_OPTIONS_NEED_REBUILD";
    codes[4145] = "ER_BACKUP_LOCK_IS_ACTIVE";
    codes[4146] = "ER_BACKUP_NOT_RUNNING";
    codes[4147] = "ER_BACKUP_WRONG_STAGE";
    codes[4148] = "ER_BACKUP_STAGE_FAILED";
    codes[4149] = "ER_BACKUP_UNKNOWN_STAGE";
    codes[4150] = "ER_USER_IS_BLOCKED";
    codes[4151] = "ER_ACCOUNT_HAS_BEEN_LOCKED";
    codes[4152] = "ER_PERIOD_TEMPORARY_NOT_ALLOWED";
    codes[4153] = "ER_PERIOD_TYPES_MISMATCH";
    codes[4154] = "ER_MORE_THAN_ONE_PERIOD";
    codes[4155] = "ER_PERIOD_FIELD_WRONG_ATTRIBUTES";
    codes[4156] = "ER_PERIOD_NOT_FOUND";
    codes[4157] = "ER_PERIOD_COLUMNS_UPDATED";
    codes[4158] = "ER_PERIOD_CONSTRAINT_DROP";
    codes[4159] = "ER_TOO_LONG_KEYPART";
    codes[4160] = "ER_TOO_LONG_DATABASE_COMMENT";
    codes[4161] = "ER_UNKNOWN_DATA_TYPE";
    codes[4162] = "ER_UNKNOWN_OPERATOR";
    codes[4163] = "ER_WARN_HISTORY_ROW_START_TIME";
    codes[4164] = "ER_PART_STARTS_BEYOND_INTERVAL";
    codes[4165] = "ER_GALERA_REPLICATION_NOT_SUPPORTED";
    codes[4166] = "ER_LOAD_INFILE_CAPABILITY_DISABLED";
    codes[4167] = "ER_NO_SECURE_TRANSPORTS_CONFIGURED";
    codes[4168] = "ER_SLAVE_IGNORED_SHARED_TABLE";
    codes[4169] = "ER_NO_AUTOINCREMENT_WITH_UNIQUE";
    codes[4170] = "ER_KEY_CONTAINS_PERIOD_FIELDS";
    codes[4171] = "ER_KEY_CANT_HAVE_WITHOUT_OVERLAPS";
    codes[4172] = "ER_NOT_ALLOWED_IN_THIS_CONTEXT";
    codes[4173] = "ER_DATA_WAS_COMMITED_UNDER_ROLLBACK";
    codes[4174] = "ER_PK_INDEX_CANT_BE_IGNORED";
    codes[4175] = "ER_BINLOG_UNSAFE_SKIP_LOCKED";
    codes[4176] = "ER_JSON_TABLE_ERROR_ON_FIELD";
    codes[4177] = "ER_JSON_TABLE_ALIAS_REQUIRED";
    codes[4178] = "ER_JSON_TABLE_SCALAR_EXPECTED";
    codes[4179] = "ER_JSON_TABLE_MULTIPLE_MATCHES";
    codes[4180] = "ER_WITH_TIES_NEEDS_ORDER";
    codes[4181] = "ER_REMOVED_ORPHAN_TRIGGER";
    codes[4182] = "ER_STORAGE_ENGINE_DISABLED";
    codes[4183] = "WARN_SFORMAT_ERROR";
    codes[4184] = "ER_PARTITION_CONVERT_SUBPARTITIONED";
    codes[4185] = "ER_PROVIDER_NOT_LOADED";
    codes[4186] = "ER_JSON_HISTOGRAM_PARSE_FAILED";
    codes[4187] = "ER_SF_OUT_INOUT_ARG_NOT_ALLOWED";
    codes[4188] = "ER_INCONSISTENT_SLAVE_TEMP_TABLE";
    codes[4189] = "ER_VERS_HIST_PART_FAILED";
    module.exports.codes = codes;
  }
});

// node_modules/mariadb/lib/misc/errors.js
var require_errors = __commonJS({
  "node_modules/mariadb/lib/misc/errors.js"(exports, module) {
    "use strict";
    var ErrorCodes = require_error_code();
    var SqlError = class extends Error {
      constructor(msg, sql, fatal, info, sqlState, errno, additionalStack, addHeader = void 0, cause) {
        super(
          (addHeader !== false ? `(conn:${info && info.threadId ? info.threadId : -1}, no: ${errno ? errno : -1}, SQLState: ${sqlState}) ` : "") + msg + (sql ? "\nsql: " + sql : ""),
          cause
        );
        this.name = "SqlError";
        this.sqlMessage = msg;
        this.sql = sql;
        this.fatal = fatal;
        this.errno = errno;
        this.sqlState = sqlState;
        if (errno > 45e3 && errno < 46e3) {
          this.code = errByNo[errno] || "UNKNOWN";
        } else {
          this.code = ErrorCodes.codes[this.errno] || "UNKNOWN";
        }
        if (additionalStack) {
          this.stack += "\n From event:\n" + additionalStack.substring(additionalStack.indexOf("\n") + 1);
        }
      }
      get text() {
        return this.sqlMessage;
      }
    };
    module.exports.createError = function(msg, errno, info = null, sqlState = "HY000", sql = null, fatal = false, additionalStack = void 0, addHeader = void 0, cause = void 0) {
      if (cause) return new SqlError(msg, sql, fatal, info, sqlState, errno, additionalStack, addHeader, { cause });
      return new SqlError(msg, sql, fatal, info, sqlState, errno, additionalStack, addHeader, cause);
    };
    module.exports.createFatalError = function(msg, errno, info = null, sqlState = "08S01", sql = null, additionalStack = void 0, addHeader = void 0) {
      return new SqlError(msg, sql, true, info, sqlState, errno, additionalStack, addHeader);
    };
    module.exports.ER_CONNECTION_ALREADY_CLOSED = 45001;
    module.exports.ER_MYSQL_CHANGE_USER_BUG = 45003;
    module.exports.ER_CMD_NOT_EXECUTED_DESTROYED = 45004;
    module.exports.ER_NULL_CHAR_ESCAPEID = 45005;
    module.exports.ER_NULL_ESCAPEID = 45006;
    module.exports.ER_NOT_IMPLEMENTED_FORMAT = 45007;
    module.exports.ER_NODE_NOT_SUPPORTED_TLS = 45008;
    module.exports.ER_SOCKET_UNEXPECTED_CLOSE = 45009;
    module.exports.ER_UNEXPECTED_PACKET = 45011;
    module.exports.ER_CONNECTION_TIMEOUT = 45012;
    module.exports.ER_CMD_CONNECTION_CLOSED = 45013;
    module.exports.ER_CHANGE_USER_BAD_PACKET = 45014;
    module.exports.ER_PING_BAD_PACKET = 45015;
    module.exports.ER_MISSING_PARAMETER = 45016;
    module.exports.ER_PARAMETER_UNDEFINED = 45017;
    module.exports.ER_PLACEHOLDER_UNDEFINED = 45018;
    module.exports.ER_SOCKET = 45019;
    module.exports.ER_EOF_EXPECTED = 45020;
    module.exports.ER_LOCAL_INFILE_DISABLED = 45021;
    module.exports.ER_LOCAL_INFILE_NOT_READABLE = 45022;
    module.exports.ER_SERVER_SSL_DISABLED = 45023;
    module.exports.ER_AUTHENTICATION_BAD_PACKET = 45024;
    module.exports.ER_AUTHENTICATION_PLUGIN_NOT_SUPPORTED = 45025;
    module.exports.ER_SOCKET_TIMEOUT = 45026;
    module.exports.ER_POOL_ALREADY_CLOSED = 45027;
    module.exports.ER_GET_CONNECTION_TIMEOUT = 45028;
    module.exports.ER_SETTING_SESSION_ERROR = 45029;
    module.exports.ER_INITIAL_SQL_ERROR = 45030;
    module.exports.ER_BATCH_WITH_NO_VALUES = 45031;
    module.exports.ER_RESET_BAD_PACKET = 45032;
    module.exports.ER_WRONG_IANA_TIMEZONE = 45033;
    module.exports.ER_LOCAL_INFILE_WRONG_FILENAME = 45034;
    module.exports.ER_ADD_CONNECTION_CLOSED_POOL = 45035;
    module.exports.ER_WRONG_AUTO_TIMEZONE = 45036;
    module.exports.ER_CLOSING_POOL = 45037;
    module.exports.ER_TIMEOUT_NOT_SUPPORTED = 45038;
    module.exports.ER_INITIAL_TIMEOUT_ERROR = 45039;
    module.exports.ER_DUPLICATE_FIELD = 45040;
    module.exports.ER_PING_TIMEOUT = 45042;
    module.exports.ER_BAD_PARAMETER_VALUE = 45043;
    module.exports.ER_CANNOT_RETRIEVE_RSA_KEY = 45044;
    module.exports.ER_MINIMUM_NODE_VERSION_REQUIRED = 45045;
    module.exports.ER_MAX_ALLOWED_PACKET = 45046;
    module.exports.ER_NOT_SUPPORTED_AUTH_PLUGIN = 45047;
    module.exports.ER_COMPRESSION_NOT_SUPPORTED = 45048;
    module.exports.ER_UNDEFINED_SQL = 45049;
    module.exports.ER_PARSING_PRECISION = 45050;
    module.exports.ER_PREPARE_CLOSED = 45051;
    module.exports.ER_MISSING_SQL_PARAMETER = 45052;
    module.exports.ER_MISSING_SQL_FILE = 45053;
    module.exports.ER_SQL_FILE_ERROR = 45054;
    module.exports.ER_MISSING_DATABASE_PARAMETER = 45055;
    module.exports.ER_SELF_SIGNED = 45056;
    module.exports.ER_SELF_SIGNED_NO_PWD = 45057;
    module.exports.ER_PRIVATE_FIELDS_USE = 45058;
    module.exports.ER_TLS_IDENTITY_ERROR = 45059;
    module.exports.ER_POOL_NOT_INITIALIZED = 45060;
    module.exports.ER_POOL_NO_CONNECTION = 45061;
    module.exports.ER_SELF_SIGNED_BAD_PLUGIN = 45062;
    var keys = Object.keys(module.exports);
    var errByNo = {};
    for (let i = 0; i < keys.length; i++) {
      const keyName = keys[i];
      if (keyName !== "createError") {
        errByNo[module.exports[keyName]] = keyName;
      }
    }
    module.exports.SqlError = SqlError;
  }
});

// node_modules/mariadb/lib/io/packet.js
var require_packet = __commonJS({
  "node_modules/mariadb/lib/io/packet.js"(exports, module) {
    "use strict";
    var Errors = require_errors();
    var Packet = class {
      update(buf, pos, end) {
        this.buf = buf;
        this.pos = pos;
        this.end = end;
        return this;
      }
      skip(n) {
        this.pos += n;
      }
      readGeometry(defaultVal) {
        const geoBuf = this.readBufferLengthEncoded();
        if (geoBuf === null || geoBuf.length === 0) {
          return defaultVal;
        }
        let geoPos = 4;
        return readGeometryObject(false);
        function parseCoordinates(byteOrder) {
          geoPos += 16;
          const x = byteOrder ? geoBuf.readDoubleLE(geoPos - 16) : geoBuf.readDoubleBE(geoPos - 16);
          const y = byteOrder ? geoBuf.readDoubleLE(geoPos - 8) : geoBuf.readDoubleBE(geoPos - 8);
          return [x, y];
        }
        function readGeometryObject(inner) {
          const byteOrder = geoBuf[geoPos++];
          const wkbType = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);
          geoPos += 4;
          switch (wkbType) {
            case 1:
              const coords = parseCoordinates(byteOrder);
              if (inner) return coords;
              return {
                type: "Point",
                coordinates: coords
              };
            case 2:
              const pointNumber = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);
              geoPos += 4;
              let coordinates = [];
              for (let i = 0; i < pointNumber; i++) {
                coordinates.push(parseCoordinates(byteOrder));
              }
              if (inner) return coordinates;
              return {
                type: "LineString",
                coordinates
              };
            case 3:
              let polygonCoordinates = [];
              const numRings = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);
              geoPos += 4;
              for (let ring = 0; ring < numRings; ring++) {
                const pointNumber2 = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);
                geoPos += 4;
                let linesCoordinates = [];
                for (let i = 0; i < pointNumber2; i++) {
                  linesCoordinates.push(parseCoordinates(byteOrder));
                }
                polygonCoordinates.push(linesCoordinates);
              }
              if (inner) return polygonCoordinates;
              return {
                type: "Polygon",
                coordinates: polygonCoordinates
              };
            case 4:
              return {
                type: "MultiPoint",
                coordinates: parseGeomArray(byteOrder, true)
              };
            case 5:
              return {
                type: "MultiLineString",
                coordinates: parseGeomArray(byteOrder, true)
              };
            case 6:
              return {
                type: "MultiPolygon",
                coordinates: parseGeomArray(byteOrder, true)
              };
            case 7:
              return {
                type: "GeometryCollection",
                geometries: parseGeomArray(byteOrder, false)
              };
          }
          return null;
        }
        function parseGeomArray(byteOrder, inner) {
          let coordinates = [];
          const number = byteOrder ? geoBuf.readInt32LE(geoPos) : geoBuf.readInt32BE(geoPos);
          geoPos += 4;
          for (let i = 0; i < number; i++) {
            coordinates.push(readGeometryObject(inner));
          }
          return coordinates;
        }
      }
      peek() {
        return this.buf[this.pos];
      }
      remaining() {
        return this.end - this.pos > 0;
      }
      readInt8() {
        const val = this.buf[this.pos++];
        return val | (val & 2 ** 7) * 33554430;
      }
      readUInt8() {
        return this.buf[this.pos++];
      }
      readInt16() {
        this.pos += 2;
        const first = this.buf[this.pos - 2];
        const last = this.buf[this.pos - 1];
        const val = first + last * 2 ** 8;
        return val | (val & 2 ** 15) * 131070;
      }
      readUInt16() {
        this.pos += 2;
        return this.buf[this.pos - 2] + this.buf[this.pos - 1] * 2 ** 8;
      }
      readInt24() {
        const first = this.buf[this.pos];
        const last = this.buf[this.pos + 2];
        const val = first + this.buf[this.pos + 1] * 2 ** 8 + last * 2 ** 16;
        this.pos += 3;
        return val | (val & 2 ** 23) * 510;
      }
      readUInt24() {
        this.pos += 3;
        return this.buf[this.pos - 3] + this.buf[this.pos - 2] * 2 ** 8 + this.buf[this.pos - 1] * 2 ** 16;
      }
      readUInt32() {
        this.pos += 4;
        return this.buf[this.pos - 4] + this.buf[this.pos - 3] * 2 ** 8 + this.buf[this.pos - 2] * 2 ** 16 + this.buf[this.pos - 1] * 2 ** 24;
      }
      readInt32() {
        this.pos += 4;
        return this.buf[this.pos - 4] + this.buf[this.pos - 3] * 2 ** 8 + this.buf[this.pos - 2] * 2 ** 16 + (this.buf[this.pos - 1] << 24);
      }
      readBigInt64() {
        const val = this.buf.readBigInt64LE(this.pos);
        this.pos += 8;
        return val;
      }
      readBigUInt64() {
        const val = this.buf.readBigUInt64LE(this.pos);
        this.pos += 8;
        return val;
      }
      /**
       * Metadata are length encoded, but cannot have length > 256, so simplified readUnsignedLength
       * @returns {number}
       */
      readMetadataLength() {
        const type = this.buf[this.pos++];
        if (type < 251) return type;
        return this.readUInt16();
      }
      readUnsignedLength() {
        const type = this.buf[this.pos++];
        if (type < 251) return type;
        switch (type) {
          case 251:
            return null;
          case 252:
            this.pos += 2;
            return this.buf[this.pos - 2] + this.buf[this.pos - 1] * 2 ** 8;
          case 253:
            this.pos += 3;
            return this.buf[this.pos - 3] + this.buf[this.pos - 2] * 2 ** 8 + this.buf[this.pos - 1] * 2 ** 16;
          case 254:
            return Number(this.readBigInt64());
        }
      }
      readBuffer(len) {
        this.pos += len;
        return this.buf.subarray(this.pos - len, this.pos);
      }
      readBufferRemaining() {
        let b = this.buf.subarray(this.pos, this.end);
        this.pos = this.end;
        return b;
      }
      readBufferLengthEncoded() {
        const len = this.readUnsignedLength();
        if (len === null) return null;
        this.pos += len;
        return this.buf.subarray(this.pos - len, this.pos);
      }
      readStringNullEnded() {
        let initialPosition = this.pos;
        let cnt = 0;
        while (this.remaining() > 0 && this.buf[this.pos++] !== 0) {
          cnt++;
        }
        return this.buf.toString(void 0, initialPosition, initialPosition + cnt);
      }
      /**
       * Return unsigned Bigint.
       *
       * Could be used for reading other kinds of value than InsertId, if reading possible null value
       * @returns {bigint}
       */
      readInsertId() {
        const type = this.buf[this.pos++];
        if (type < 251) return BigInt(type);
        switch (type) {
          case 252:
            this.pos += 2;
            return BigInt(this.buf[this.pos - 2] + this.buf[this.pos - 1] * 2 ** 8);
          case 253:
            this.pos += 3;
            return BigInt(this.buf[this.pos - 3] + this.buf[this.pos - 2] * 2 ** 8 + this.buf[this.pos - 1] * 2 ** 16);
          case 254:
            return this.readBigInt64();
        }
      }
      readAsciiStringLengthEncoded() {
        const len = this.readUnsignedLength();
        if (len === null) return null;
        this.pos += len;
        return this.buf.toString("ascii", this.pos - len, this.pos);
      }
      readStringLengthEncoded() {
        throw new Error("code is normally superseded by Node encoder or Iconv depending on charset used");
      }
      readBigIntLengthEncoded() {
        const len = this.buf[this.pos++];
        if (len < 16) {
          return BigInt(this._atoi(len));
        }
        if (len === 251) return null;
        return this.readBigIntFromLen(len);
      }
      readBigIntFromLen(len) {
        let result = 0n;
        let negate = false;
        let begin = this.pos;
        if (len > 0 && this.buf[begin] === 45) {
          negate = true;
          begin++;
        }
        for (; begin < this.pos + len; begin++) {
          result = result * 10n + BigInt(this.buf[begin] - 48);
        }
        this.pos += len;
        return negate ? -1n * result : result;
      }
      readDecimalLengthEncoded() {
        const len = this.buf[this.pos++];
        if (len === 251) return null;
        this.pos += len;
        return this.buf.toString("ascii", this.pos - len, this.pos);
      }
      readDate() {
        const len = this.buf[this.pos++];
        if (len === 251) return null;
        let res = [];
        let value = 0;
        let initPos = this.pos;
        this.pos += len;
        while (initPos < this.pos) {
          const char = this.buf[initPos++];
          if (char === 45) {
            res.push(value);
            value = 0;
          } else {
            value = value * 10 + char - 48;
          }
        }
        res.push(value);
        if (res[0] === 0 && res[1] === 0 && res[2] === 0) return null;
        return new Date(res[0], res[1] - 1, res[2]);
      }
      readBinaryDate(opts) {
        const len = this.buf[this.pos++];
        let year = 0;
        let month = 0;
        let day = 0;
        if (len > 0) {
          year = this.readInt16();
          if (len > 2) {
            month = this.readUInt8() - 1;
            if (len > 3) {
              day = this.readUInt8();
            }
          }
        }
        if (year === 0 && month === 0 && day === 0) return opts.dateStrings ? "0000-00-00" : null;
        if (opts.dateStrings) {
          return `${appendZero(year, 4)}-${appendZero(month + 1, 2)}-${appendZero(day, 2)}`;
        }
        return new Date(year, month, day);
      }
      readDateTime() {
        const len = this.buf[this.pos++];
        if (len === 251) return null;
        this.pos += len;
        const str = this.buf.toString("ascii", this.pos - len, this.pos);
        if (str.startsWith("0000-00-00 00:00:00")) return null;
        return new Date(str);
      }
      readBinaryDateTime() {
        const len = this.buf[this.pos++];
        let year = 0;
        let month = 0;
        let day = 0;
        let hour = 0;
        let min = 0;
        let sec = 0;
        let microSec = 0;
        if (len > 0) {
          year = this.readInt16();
          if (len > 2) {
            month = this.readUInt8();
            if (len > 3) {
              day = this.readUInt8();
              if (len > 4) {
                hour = this.readUInt8();
                min = this.readUInt8();
                sec = this.readUInt8();
                if (len > 7) {
                  microSec = this.readUInt32();
                }
              }
            }
          }
        }
        if (year === 0 && month === 0 && day === 0 && hour === 0 && min === 0 && sec === 0 && microSec === 0) return null;
        return new Date(year, month - 1, day, hour, min, sec, microSec / 1e3);
      }
      readBinaryDateTimeAsString(scale) {
        const len = this.buf[this.pos++];
        let year = 0;
        let month = 0;
        let day = 0;
        let hour = 0;
        let min = 0;
        let sec = 0;
        let microSec = 0;
        if (len > 0) {
          year = this.readInt16();
          if (len > 2) {
            month = this.readUInt8();
            if (len > 3) {
              day = this.readUInt8();
              if (len > 4) {
                hour = this.readUInt8();
                min = this.readUInt8();
                sec = this.readUInt8();
                if (len > 7) {
                  microSec = this.readUInt32();
                }
              }
            }
          }
        }
        if (year === 0 && month === 0 && day === 0 && hour === 0 && min === 0 && sec === 0 && microSec === 0)
          return "0000-00-00 00:00:00" + (scale > 0 ? ".000000".substring(0, scale + 1) : "");
        return appendZero(year, 4) + "-" + appendZero(month, 2) + "-" + appendZero(day, 2) + " " + appendZero(hour, 2) + ":" + appendZero(min, 2) + ":" + appendZero(sec, 2) + (microSec > 0 ? scale > 0 ? "." + appendZero(microSec, 6).substring(0, scale) : "." + appendZero(microSec, 6) : scale > 0 ? "." + appendZero(microSec, 6).substring(0, scale) : "");
      }
      readBinaryTime() {
        const len = this.buf[this.pos++];
        let negate = false;
        let hour = 0;
        let min = 0;
        let sec = 0;
        let microSec = 0;
        if (len > 0) {
          negate = this.buf[this.pos++] === 1;
          hour = this.readUInt32() * 24 + this.readUInt8();
          min = this.readUInt8();
          sec = this.readUInt8();
          if (len > 8) {
            microSec = this.readUInt32();
          }
        }
        let val = appendZero(hour, 2) + ":" + appendZero(min, 2) + ":" + appendZero(sec, 2);
        if (microSec > 0) {
          val += "." + appendZero(microSec, 6);
        }
        if (negate) return "-" + val;
        return val;
      }
      readFloat() {
        const val = this.buf.readFloatLE(this.pos);
        this.pos += 4;
        return val;
      }
      readDouble() {
        const val = this.buf.readDoubleLE(this.pos);
        this.pos += 8;
        return val;
      }
      readIntLengthEncoded() {
        const len = this.buf[this.pos++];
        if (len === 251) return null;
        return this._atoi(len);
      }
      _atoi(len) {
        let result = 0;
        let negate = false;
        let begin = this.pos;
        if (len > 0 && this.buf[begin] === 45) {
          negate = true;
          begin++;
        }
        for (; begin < this.pos + len; begin++) {
          result = result * 10 + (this.buf[begin] - 48);
        }
        this.pos += len;
        return negate ? -1 * result : result;
      }
      readFloatLengthCoded() {
        const len = this.readUnsignedLength();
        if (len === null) return null;
        this.pos += len;
        return +this.buf.toString("ascii", this.pos - len, this.pos);
      }
      skipLengthCodedNumber() {
        const type = this.buf[this.pos++];
        switch (type) {
          case 251:
            return;
          case 252:
            this.pos += 2 + (65535 & this.buf[this.pos] + (this.buf[this.pos + 1] << 8));
            return;
          case 253:
            this.pos += 3 + (16777215 & this.buf[this.pos] + (this.buf[this.pos + 1] << 8) + (this.buf[this.pos + 2] << 16));
            return;
          case 254:
            this.pos += 8 + Number(this.buf.readBigUInt64LE(this.pos));
            return;
          default:
            this.pos += type;
            return;
        }
      }
      length() {
        return this.end - this.pos;
      }
      subPacketLengthEncoded(len) {
      }
      /**
       * Parse ERR_Packet : https://mariadb.com/kb/en/library/err_packet/
       *
       * @param info              current connection info
       * @param sql               command sql
       * @param stack             additional stack trace
       * @returns {Error}
       */
      readError(info, sql, stack) {
        this.skip(1);
        let errno = this.readUInt16();
        let sqlState;
        let msg;
        if (this.peek() === 35) {
          this.skip(6);
          sqlState = this.buf.toString(void 0, this.pos - 5, this.pos);
          msg = this.readStringNullEnded();
        } else {
          sqlState = "HY000";
          msg = this.buf.toString(void 0, this.pos, this.end);
        }
        let fatal = sqlState.startsWith("08") || sqlState === "70100";
        return Errors.createError(msg, errno, info, sqlState, sql, fatal, stack);
      }
    };
    var appendZero = (val, len) => {
      let st = val.toString();
      while (st.length < len) {
        st = "0" + st;
      }
      return st;
    };
    module.exports = Packet;
  }
});

// node_modules/mariadb/lib/io/packet-node-encoded.js
var require_packet_node_encoded = __commonJS({
  "node_modules/mariadb/lib/io/packet-node-encoded.js"(exports, module) {
    "use strict";
    var Packet = require_packet();
    var PacketNodeEncoded = class _PacketNodeEncoded extends Packet {
      constructor(encoding) {
        super();
        this.encoding = encoding === "utf8" ? void 0 : encoding;
      }
      readStringLengthEncoded() {
        const len = this.readUnsignedLength();
        if (len === null) return null;
        this.pos += len;
        return this.buf.toString(this.encoding, this.pos - len, this.pos);
      }
      static readString(encoding, buf, beg, len) {
        return buf.toString(encoding, beg, beg + len);
      }
      subPacketLengthEncoded(len) {
        this.skip(len);
        return new _PacketNodeEncoded(this.encoding).update(this.buf, this.pos - len, this.pos);
      }
      readStringRemaining() {
        const str = this.buf.toString(this.encoding, this.pos, this.end);
        this.pos = this.end;
        return str;
      }
    };
    module.exports = PacketNodeEncoded;
  }
});

// node_modules/safer-buffer/safer.js
var require_safer = __commonJS({
  "node_modules/safer-buffer/safer.js"(exports, module) {
    "use strict";
    var buffer = require_buffer();
    var Buffer2 = buffer.Buffer;
    var safer = {};
    var key;
    for (key in buffer) {
      if (!buffer.hasOwnProperty(key)) continue;
      if (key === "SlowBuffer" || key === "Buffer") continue;
      safer[key] = buffer[key];
    }
    var Safer = safer.Buffer = {};
    for (key in Buffer2) {
      if (!Buffer2.hasOwnProperty(key)) continue;
      if (key === "allocUnsafe" || key === "allocUnsafeSlow") continue;
      Safer[key] = Buffer2[key];
    }
    safer.Buffer.prototype = Buffer2.prototype;
    if (!Safer.from || Safer.from === Uint8Array.from) {
      Safer.from = function(value, encodingOrOffset, length) {
        if (typeof value === "number") {
          throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value);
        }
        if (value && typeof value.length === "undefined") {
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value);
        }
        return Buffer2(value, encodingOrOffset, length);
      };
    }
    if (!Safer.alloc) {
      Safer.alloc = function(size, fill, encoding) {
        if (typeof size !== "number") {
          throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
        }
        if (size < 0 || size >= 2 * (1 << 30)) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
        var buf = Buffer2(size);
        if (!fill || fill.length === 0) {
          buf.fill(0);
        } else if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
        return buf;
      };
    }
    if (!safer.kStringMaxLength) {
      try {
        safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
      } catch (e) {
      }
    }
    if (!safer.constants) {
      safer.constants = {
        MAX_LENGTH: safer.kMaxLength
      };
      if (safer.kStringMaxLength) {
        safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
      }
    }
    module.exports = safer;
  }
});

// node_modules/mariadb/node_modules/iconv-lite/lib/bom-handling.js
var require_bom_handling = __commonJS({
  "node_modules/mariadb/node_modules/iconv-lite/lib/bom-handling.js"(exports) {
    "use strict";
    var BOMChar = "\uFEFF";
    exports.PrependBOM = PrependBOMWrapper;
    function PrependBOMWrapper(encoder, options) {
      this.encoder = encoder;
      this.addBOM = true;
    }
    PrependBOMWrapper.prototype.write = function(str) {
      if (this.addBOM) {
        str = BOMChar + str;
        this.addBOM = false;
      }
      return this.encoder.write(str);
    };
    PrependBOMWrapper.prototype.end = function() {
      return this.encoder.end();
    };
    exports.StripBOM = StripBOMWrapper;
    function StripBOMWrapper(decoder, options) {
      this.decoder = decoder;
      this.pass = false;
      this.options = options || {};
    }
    StripBOMWrapper.prototype.write = function(buf) {
      var res = this.decoder.write(buf);
      if (this.pass || !res)
        return res;
      if (res[0] === BOMChar) {
        res = res.slice(1);
        if (typeof this.options.stripBOM === "function")
          this.options.stripBOM();
      }
      this.pass = true;
      return res;
    };
    StripBOMWrapper.prototype.end = function() {
      return this.decoder.end();
    };
  }
});

// node_modules/mariadb/node_modules/iconv-lite/encodings/internal.js
var require_internal = __commonJS({
  "node_modules/mariadb/node_modules/iconv-lite/encodings/internal.js"(exports, module) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    module.exports = {
      // Encodings
      utf8: { type: "_internal", bomAware: true },
      cesu8: { type: "_internal", bomAware: true },
      unicode11utf8: "utf8",
      ucs2: { type: "_internal", bomAware: true },
      utf16le: "ucs2",
      binary: { type: "_internal" },
      base64: { type: "_internal" },
      hex: { type: "_internal" },
      // Codec.
      _internal: InternalCodec
    };
    function InternalCodec(codecOptions, iconv) {
      this.enc = codecOptions.encodingName;
      this.bomAware = codecOptions.bomAware;
      if (this.enc === "base64")
        this.encoder = InternalEncoderBase64;
      else if (this.enc === "cesu8") {
        this.enc = "utf8";
        this.encoder = InternalEncoderCesu8;
        if (Buffer2.from("eda0bdedb2a9", "hex").toString() !== "") {
          this.decoder = InternalDecoderCesu8;
          this.defaultCharUnicode = iconv.defaultCharUnicode;
        }
      }
    }
    InternalCodec.prototype.encoder = InternalEncoder;
    InternalCodec.prototype.decoder = InternalDecoder;
    var StringDecoder = require_string_decoder().StringDecoder;
    if (!StringDecoder.prototype.end)
      StringDecoder.prototype.end = function() {
      };
    function InternalDecoder(options, codec) {
      this.decoder = new StringDecoder(codec.enc);
    }
    InternalDecoder.prototype.write = function(buf) {
      if (!Buffer2.isBuffer(buf)) {
        buf = Buffer2.from(buf);
      }
      return this.decoder.write(buf);
    };
    InternalDecoder.prototype.end = function() {
      return this.decoder.end();
    };
    function InternalEncoder(options, codec) {
      this.enc = codec.enc;
    }
    InternalEncoder.prototype.write = function(str) {
      return Buffer2.from(str, this.enc);
    };
    InternalEncoder.prototype.end = function() {
    };
    function InternalEncoderBase64(options, codec) {
      this.prevStr = "";
    }
    InternalEncoderBase64.prototype.write = function(str) {
      str = this.prevStr + str;
      var completeQuads = str.length - str.length % 4;
      this.prevStr = str.slice(completeQuads);
      str = str.slice(0, completeQuads);
      return Buffer2.from(str, "base64");
    };
    InternalEncoderBase64.prototype.end = function() {
      return Buffer2.from(this.prevStr, "base64");
    };
    function InternalEncoderCesu8(options, codec) {
    }
    InternalEncoderCesu8.prototype.write = function(str) {
      var buf = Buffer2.alloc(str.length * 3), bufIdx = 0;
      for (var i = 0; i < str.length; i++) {
        var charCode = str.charCodeAt(i);
        if (charCode < 128)
          buf[bufIdx++] = charCode;
        else if (charCode < 2048) {
          buf[bufIdx++] = 192 + (charCode >>> 6);
          buf[bufIdx++] = 128 + (charCode & 63);
        } else {
          buf[bufIdx++] = 224 + (charCode >>> 12);
          buf[bufIdx++] = 128 + (charCode >>> 6 & 63);
          buf[bufIdx++] = 128 + (charCode & 63);
        }
      }
      return buf.slice(0, bufIdx);
    };
    InternalEncoderCesu8.prototype.end = function() {
    };
    function InternalDecoderCesu8(options, codec) {
      this.acc = 0;
      this.contBytes = 0;
      this.accBytes = 0;
      this.defaultCharUnicode = codec.defaultCharUnicode;
    }
    InternalDecoderCesu8.prototype.write = function(buf) {
      var acc = this.acc, contBytes = this.contBytes, accBytes = this.accBytes, res = "";
      for (var i = 0; i < buf.length; i++) {
        var curByte = buf[i];
        if ((curByte & 192) !== 128) {
          if (contBytes > 0) {
            res += this.defaultCharUnicode;
            contBytes = 0;
          }
          if (curByte < 128) {
            res += String.fromCharCode(curByte);
          } else if (curByte < 224) {
            acc = curByte & 31;
            contBytes = 1;
            accBytes = 1;
          } else if (curByte < 240) {
            acc = curByte & 15;
            contBytes = 2;
            accBytes = 1;
          } else {
            res += this.defaultCharUnicode;
          }
        } else {
          if (contBytes > 0) {
            acc = acc << 6 | curByte & 63;
            contBytes--;
            accBytes++;
            if (contBytes === 0) {
              if (accBytes === 2 && acc < 128 && acc > 0)
                res += this.defaultCharUnicode;
              else if (accBytes === 3 && acc < 2048)
                res += this.defaultCharUnicode;
              else
                res += String.fromCharCode(acc);
            }
          } else {
            res += this.defaultCharUnicode;
          }
        }
      }
      this.acc = acc;
      this.contBytes = contBytes;
      this.accBytes = accBytes;
      return res;
    };
    InternalDecoderCesu8.prototype.end = function() {
      var res = 0;
      if (this.contBytes > 0)
        res += this.defaultCharUnicode;
      return res;
    };
  }
});

// node_modules/mariadb/node_modules/iconv-lite/encodings/utf32.js
var require_utf32 = __commonJS({
  "node_modules/mariadb/node_modules/iconv-lite/encodings/utf32.js"(exports) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    exports._utf32 = Utf32Codec;
    function Utf32Codec(codecOptions, iconv) {
      this.iconv = iconv;
      this.bomAware = true;
      this.isLE = codecOptions.isLE;
    }
    exports.utf32le = { type: "_utf32", isLE: true };
    exports.utf32be = { type: "_utf32", isLE: false };
    exports.ucs4le = "utf32le";
    exports.ucs4be = "utf32be";
    Utf32Codec.prototype.encoder = Utf32Encoder;
    Utf32Codec.prototype.decoder = Utf32Decoder;
    function Utf32Encoder(options, codec) {
      this.isLE = codec.isLE;
      this.highSurrogate = 0;
    }
    Utf32Encoder.prototype.write = function(str) {
      var src = Buffer2.from(str, "ucs2");
      var dst = Buffer2.alloc(src.length * 2);
      var write32 = this.isLE ? dst.writeUInt32LE : dst.writeUInt32BE;
      var offset = 0;
      for (var i = 0; i < src.length; i += 2) {
        var code = src.readUInt16LE(i);
        var isHighSurrogate = 55296 <= code && code < 56320;
        var isLowSurrogate = 56320 <= code && code < 57344;
        if (this.highSurrogate) {
          if (isHighSurrogate || !isLowSurrogate) {
            write32.call(dst, this.highSurrogate, offset);
            offset += 4;
          } else {
            var codepoint = (this.highSurrogate - 55296 << 10 | code - 56320) + 65536;
            write32.call(dst, codepoint, offset);
            offset += 4;
            this.highSurrogate = 0;
            continue;
          }
        }
        if (isHighSurrogate)
          this.highSurrogate = code;
        else {
          write32.call(dst, code, offset);
          offset += 4;
          this.highSurrogate = 0;
        }
      }
      if (offset < dst.length)
        dst = dst.slice(0, offset);
      return dst;
    };
    Utf32Encoder.prototype.end = function() {
      if (!this.highSurrogate)
        return;
      var buf = Buffer2.alloc(4);
      if (this.isLE)
        buf.writeUInt32LE(this.highSurrogate, 0);
      else
        buf.writeUInt32BE(this.highSurrogate, 0);
      this.highSurrogate = 0;
      return buf;
    };
    function Utf32Decoder(options, codec) {
      this.isLE = codec.isLE;
      this.badChar = codec.iconv.defaultCharUnicode.charCodeAt(0);
      this.overflow = [];
    }
    Utf32Decoder.prototype.write = function(src) {
      if (src.length === 0)
        return "";
      var i = 0;
      var codepoint = 0;
      var dst = Buffer2.alloc(src.length + 4);
      var offset = 0;
      var isLE = this.isLE;
      var overflow = this.overflow;
      var badChar = this.badChar;
      if (overflow.length > 0) {
        for (; i < src.length && overflow.length < 4; i++)
          overflow.push(src[i]);
        if (overflow.length === 4) {
          if (isLE) {
            codepoint = overflow[i] | overflow[i + 1] << 8 | overflow[i + 2] << 16 | overflow[i + 3] << 24;
          } else {
            codepoint = overflow[i + 3] | overflow[i + 2] << 8 | overflow[i + 1] << 16 | overflow[i] << 24;
          }
          overflow.length = 0;
          offset = _writeCodepoint(dst, offset, codepoint, badChar);
        }
      }
      for (; i < src.length - 3; i += 4) {
        if (isLE) {
          codepoint = src[i] | src[i + 1] << 8 | src[i + 2] << 16 | src[i + 3] << 24;
        } else {
          codepoint = src[i + 3] | src[i + 2] << 8 | src[i + 1] << 16 | src[i] << 24;
        }
        offset = _writeCodepoint(dst, offset, codepoint, badChar);
      }
      for (; i < src.length; i++) {
        overflow.push(src[i]);
      }
      return dst.slice(0, offset).toString("ucs2");
    };
    function _writeCodepoint(dst, offset, codepoint, badChar) {
      if (codepoint < 0 || codepoint > 1114111) {
        codepoint = badChar;
      }
      if (codepoint >= 65536) {
        codepoint -= 65536;
        var high = 55296 | codepoint >> 10;
        dst[offset++] = high & 255;
        dst[offset++] = high >> 8;
        var codepoint = 56320 | codepoint & 1023;
      }
      dst[offset++] = codepoint & 255;
      dst[offset++] = codepoint >> 8;
      return offset;
    }
    Utf32Decoder.prototype.end = function() {
      this.overflow.length = 0;
    };
    exports.utf32 = Utf32AutoCodec;
    exports.ucs4 = "utf32";
    function Utf32AutoCodec(options, iconv) {
      this.iconv = iconv;
    }
    Utf32AutoCodec.prototype.encoder = Utf32AutoEncoder;
    Utf32AutoCodec.prototype.decoder = Utf32AutoDecoder;
    function Utf32AutoEncoder(options, codec) {
      options = options || {};
      if (options.addBOM === void 0)
        options.addBOM = true;
      this.encoder = codec.iconv.getEncoder(options.defaultEncoding || "utf-32le", options);
    }
    Utf32AutoEncoder.prototype.write = function(str) {
      return this.encoder.write(str);
    };
    Utf32AutoEncoder.prototype.end = function() {
      return this.encoder.end();
    };
    function Utf32AutoDecoder(options, codec) {
      this.decoder = null;
      this.initialBufs = [];
      this.initialBufsLen = 0;
      this.options = options || {};
      this.iconv = codec.iconv;
    }
    Utf32AutoDecoder.prototype.write = function(buf) {
      if (!this.decoder) {
        this.initialBufs.push(buf);
        this.initialBufsLen += buf.length;
        if (this.initialBufsLen < 32)
          return "";
        var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        var resStr = "";
        for (var i = 0; i < this.initialBufs.length; i++)
          resStr += this.decoder.write(this.initialBufs[i]);
        this.initialBufs.length = this.initialBufsLen = 0;
        return resStr;
      }
      return this.decoder.write(buf);
    };
    Utf32AutoDecoder.prototype.end = function() {
      if (!this.decoder) {
        var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        var resStr = "";
        for (var i = 0; i < this.initialBufs.length; i++)
          resStr += this.decoder.write(this.initialBufs[i]);
        var trail = this.decoder.end();
        if (trail)
          resStr += trail;
        this.initialBufs.length = this.initialBufsLen = 0;
        return resStr;
      }
      return this.decoder.end();
    };
    function detectEncoding(bufs, defaultEncoding) {
      var b = [];
      var charsProcessed = 0;
      var invalidLE = 0, invalidBE = 0;
      var bmpCharsLE = 0, bmpCharsBE = 0;
      outer_loop:
        for (var i = 0; i < bufs.length; i++) {
          var buf = bufs[i];
          for (var j = 0; j < buf.length; j++) {
            b.push(buf[j]);
            if (b.length === 4) {
              if (charsProcessed === 0) {
                if (b[0] === 255 && b[1] === 254 && b[2] === 0 && b[3] === 0) {
                  return "utf-32le";
                }
                if (b[0] === 0 && b[1] === 0 && b[2] === 254 && b[3] === 255) {
                  return "utf-32be";
                }
              }
              if (b[0] !== 0 || b[1] > 16) invalidBE++;
              if (b[3] !== 0 || b[2] > 16) invalidLE++;
              if (b[0] === 0 && b[1] === 0 && (b[2] !== 0 || b[3] !== 0)) bmpCharsBE++;
              if ((b[0] !== 0 || b[1] !== 0) && b[2] === 0 && b[3] === 0) bmpCharsLE++;
              b.length = 0;
              charsProcessed++;
              if (charsProcessed >= 100) {
                break outer_loop;
              }
            }
          }
        }
      if (bmpCharsBE - invalidBE > bmpCharsLE - invalidLE) return "utf-32be";
      if (bmpCharsBE - invalidBE < bmpCharsLE - invalidLE) return "utf-32le";
      return defaultEncoding || "utf-32le";
    }
  }
});

// node_modules/mariadb/node_modules/iconv-lite/encodings/utf16.js
var require_utf16 = __commonJS({
  "node_modules/mariadb/node_modules/iconv-lite/encodings/utf16.js"(exports) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    exports.utf16be = Utf16BECodec;
    function Utf16BECodec() {
    }
    Utf16BECodec.prototype.encoder = Utf16BEEncoder;
    Utf16BECodec.prototype.decoder = Utf16BEDecoder;
    Utf16BECodec.prototype.bomAware = true;
    function Utf16BEEncoder() {
    }
    Utf16BEEncoder.prototype.write = function(str) {
      var buf = Buffer2.from(str, "ucs2");
      for (var i = 0; i < buf.length; i += 2) {
        var tmp = buf[i];
        buf[i] = buf[i + 1];
        buf[i + 1] = tmp;
      }
      return buf;
    };
    Utf16BEEncoder.prototype.end = function() {
    };
    function Utf16BEDecoder() {
      this.overflowByte = -1;
    }
    Utf16BEDecoder.prototype.write = function(buf) {
      if (buf.length == 0)
        return "";
      var buf2 = Buffer2.alloc(buf.length + 1), i = 0, j = 0;
      if (this.overflowByte !== -1) {
        buf2[0] = buf[0];
        buf2[1] = this.overflowByte;
        i = 1;
        j = 2;
      }
      for (; i < buf.length - 1; i += 2, j += 2) {
        buf2[j] = buf[i + 1];
        buf2[j + 1] = buf[i];
      }
      this.overflowByte = i == buf.length - 1 ? buf[buf.length - 1] : -1;
      return buf2.slice(0, j).toString("ucs2");
    };
    Utf16BEDecoder.prototype.end = function() {
      this.overflowByte = -1;
    };
    exports.utf16 = Utf16Codec;
    function Utf16Codec(codecOptions, iconv) {
      this.iconv = iconv;
    }
    Utf16Codec.prototype.encoder = Utf16Encoder;
    Utf16Codec.prototype.decoder = Utf16Decoder;
    function Utf16Encoder(options, codec) {
      options = options || {};
      if (options.addBOM === void 0)
        options.addBOM = true;
      this.encoder = codec.iconv.getEncoder("utf-16le", options);
    }
    Utf16Encoder.prototype.write = function(str) {
      return this.encoder.write(str);
    };
    Utf16Encoder.prototype.end = function() {
      return this.encoder.end();
    };
    function Utf16Decoder(options, codec) {
      this.decoder = null;
      this.initialBufs = [];
      this.initialBufsLen = 0;
      this.options = options || {};
      this.iconv = codec.iconv;
    }
    Utf16Decoder.prototype.write = function(buf) {
      if (!this.decoder) {
        this.initialBufs.push(buf);
        this.initialBufsLen += buf.length;
        if (this.initialBufsLen < 16)
          return "";
        var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        var resStr = "";
        for (var i = 0; i < this.initialBufs.length; i++)
          resStr += this.decoder.write(this.initialBufs[i]);
        this.initialBufs.length = this.initialBufsLen = 0;
        return resStr;
      }
      return this.decoder.write(buf);
    };
    Utf16Decoder.prototype.end = function() {
      if (!this.decoder) {
        var encoding = detectEncoding(this.initialBufs, this.options.defaultEncoding);
        this.decoder = this.iconv.getDecoder(encoding, this.options);
        var resStr = "";
        for (var i = 0; i < this.initialBufs.length; i++)
          resStr += this.decoder.write(this.initialBufs[i]);
        var trail = this.decoder.end();
        if (trail)
          resStr += trail;
        this.initialBufs.length = this.initialBufsLen = 0;
        return resStr;
      }
      return this.decoder.end();
    };
    function detectEncoding(bufs, defaultEncoding) {
      var b = [];
      var charsProcessed = 0;
      var asciiCharsLE = 0, asciiCharsBE = 0;
      outer_loop:
        for (var i = 0; i < bufs.length; i++) {
          var buf = bufs[i];
          for (var j = 0; j < buf.length; j++) {
            b.push(buf[j]);
            if (b.length === 2) {
              if (charsProcessed === 0) {
                if (b[0] === 255 && b[1] === 254) return "utf-16le";
                if (b[0] === 254 && b[1] === 255) return "utf-16be";
              }
              if (b[0] === 0 && b[1] !== 0) asciiCharsBE++;
              if (b[0] !== 0 && b[1] === 0) asciiCharsLE++;
              b.length = 0;
              charsProcessed++;
              if (charsProcessed >= 100) {
                break outer_loop;
              }
            }
          }
        }
      if (asciiCharsBE > asciiCharsLE) return "utf-16be";
      if (asciiCharsBE < asciiCharsLE) return "utf-16le";
      return defaultEncoding || "utf-16le";
    }
  }
});

// node_modules/mariadb/node_modules/iconv-lite/encodings/utf7.js
var require_utf7 = __commonJS({
  "node_modules/mariadb/node_modules/iconv-lite/encodings/utf7.js"(exports) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    exports.utf7 = Utf7Codec;
    exports.unicode11utf7 = "utf7";
    function Utf7Codec(codecOptions, iconv) {
      this.iconv = iconv;
    }
    Utf7Codec.prototype.encoder = Utf7Encoder;
    Utf7Codec.prototype.decoder = Utf7Decoder;
    Utf7Codec.prototype.bomAware = true;
    var nonDirectChars = /[^A-Za-z0-9'\(\),-\.\/:\? \n\r\t]+/g;
    function Utf7Encoder(options, codec) {
      this.iconv = codec.iconv;
    }
    Utf7Encoder.prototype.write = function(str) {
      return Buffer2.from(str.replace(nonDirectChars, (function(chunk) {
        return "+" + (chunk === "+" ? "" : this.iconv.encode(chunk, "utf16-be").toString("base64").replace(/=+$/, "")) + "-";
      }).bind(this)));
    };
    Utf7Encoder.prototype.end = function() {
    };
    function Utf7Decoder(options, codec) {
      this.iconv = codec.iconv;
      this.inBase64 = false;
      this.base64Accum = "";
    }
    var base64Regex = /[A-Za-z0-9\/+]/;
    var base64Chars = [];
    for (i = 0; i < 256; i++)
      base64Chars[i] = base64Regex.test(String.fromCharCode(i));
    var i;
    var plusChar = "+".charCodeAt(0);
    var minusChar = "-".charCodeAt(0);
    var andChar = "&".charCodeAt(0);
    Utf7Decoder.prototype.write = function(buf) {
      var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
      for (var i2 = 0; i2 < buf.length; i2++) {
        if (!inBase64) {
          if (buf[i2] == plusChar) {
            res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
            lastI = i2 + 1;
            inBase64 = true;
          }
        } else {
          if (!base64Chars[buf[i2]]) {
            if (i2 == lastI && buf[i2] == minusChar) {
              res += "+";
            } else {
              var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii");
              res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
            }
            if (buf[i2] != minusChar)
              i2--;
            lastI = i2 + 1;
            inBase64 = false;
            base64Accum = "";
          }
        }
      }
      if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii");
      } else {
        var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii");
        var canBeDecoded = b64str.length - b64str.length % 8;
        base64Accum = b64str.slice(canBeDecoded);
        b64str = b64str.slice(0, canBeDecoded);
        res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
      }
      this.inBase64 = inBase64;
      this.base64Accum = base64Accum;
      return res;
    };
    Utf7Decoder.prototype.end = function() {
      var res = "";
      if (this.inBase64 && this.base64Accum.length > 0)
        res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
      this.inBase64 = false;
      this.base64Accum = "";
      return res;
    };
    exports.utf7imap = Utf7IMAPCodec;
    function Utf7IMAPCodec(codecOptions, iconv) {
      this.iconv = iconv;
    }
    Utf7IMAPCodec.prototype.encoder = Utf7IMAPEncoder;
    Utf7IMAPCodec.prototype.decoder = Utf7IMAPDecoder;
    Utf7IMAPCodec.prototype.bomAware = true;
    function Utf7IMAPEncoder(options, codec) {
      this.iconv = codec.iconv;
      this.inBase64 = false;
      this.base64Accum = Buffer2.alloc(6);
      this.base64AccumIdx = 0;
    }
    Utf7IMAPEncoder.prototype.write = function(str) {
      var inBase64 = this.inBase64, base64Accum = this.base64Accum, base64AccumIdx = this.base64AccumIdx, buf = Buffer2.alloc(str.length * 5 + 10), bufIdx = 0;
      for (var i2 = 0; i2 < str.length; i2++) {
        var uChar = str.charCodeAt(i2);
        if (32 <= uChar && uChar <= 126) {
          if (inBase64) {
            if (base64AccumIdx > 0) {
              bufIdx += buf.write(base64Accum.slice(0, base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
              base64AccumIdx = 0;
            }
            buf[bufIdx++] = minusChar;
            inBase64 = false;
          }
          if (!inBase64) {
            buf[bufIdx++] = uChar;
            if (uChar === andChar)
              buf[bufIdx++] = minusChar;
          }
        } else {
          if (!inBase64) {
            buf[bufIdx++] = andChar;
            inBase64 = true;
          }
          if (inBase64) {
            base64Accum[base64AccumIdx++] = uChar >> 8;
            base64Accum[base64AccumIdx++] = uChar & 255;
            if (base64AccumIdx == base64Accum.length) {
              bufIdx += buf.write(base64Accum.toString("base64").replace(/\//g, ","), bufIdx);
              base64AccumIdx = 0;
            }
          }
        }
      }
      this.inBase64 = inBase64;
      this.base64AccumIdx = base64AccumIdx;
      return buf.slice(0, bufIdx);
    };
    Utf7IMAPEncoder.prototype.end = function() {
      var buf = Buffer2.alloc(10), bufIdx = 0;
      if (this.inBase64) {
        if (this.base64AccumIdx > 0) {
          bufIdx += buf.write(this.base64Accum.slice(0, this.base64AccumIdx).toString("base64").replace(/\//g, ",").replace(/=+$/, ""), bufIdx);
          this.base64AccumIdx = 0;
        }
        buf[bufIdx++] = minusChar;
        this.inBase64 = false;
      }
      return buf.slice(0, bufIdx);
    };
    function Utf7IMAPDecoder(options, codec) {
      this.iconv = codec.iconv;
      this.inBase64 = false;
      this.base64Accum = "";
    }
    var base64IMAPChars = base64Chars.slice();
    base64IMAPChars[",".charCodeAt(0)] = true;
    Utf7IMAPDecoder.prototype.write = function(buf) {
      var res = "", lastI = 0, inBase64 = this.inBase64, base64Accum = this.base64Accum;
      for (var i2 = 0; i2 < buf.length; i2++) {
        if (!inBase64) {
          if (buf[i2] == andChar) {
            res += this.iconv.decode(buf.slice(lastI, i2), "ascii");
            lastI = i2 + 1;
            inBase64 = true;
          }
        } else {
          if (!base64IMAPChars[buf[i2]]) {
            if (i2 == lastI && buf[i2] == minusChar) {
              res += "&";
            } else {
              var b64str = base64Accum + this.iconv.decode(buf.slice(lastI, i2), "ascii").replace(/,/g, "/");
              res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
            }
            if (buf[i2] != minusChar)
              i2--;
            lastI = i2 + 1;
            inBase64 = false;
            base64Accum = "";
          }
        }
      }
      if (!inBase64) {
        res += this.iconv.decode(buf.slice(lastI), "ascii");
      } else {
        var b64str = base64Accum + this.iconv.decode(buf.slice(lastI), "ascii").replace(/,/g, "/");
        var canBeDecoded = b64str.length - b64str.length % 8;
        base64Accum = b64str.slice(canBeDecoded);
        b64str = b64str.slice(0, canBeDecoded);
        res += this.iconv.decode(Buffer2.from(b64str, "base64"), "utf16-be");
      }
      this.inBase64 = inBase64;
      this.base64Accum = base64Accum;
      return res;
    };
    Utf7IMAPDecoder.prototype.end = function() {
      var res = "";
      if (this.inBase64 && this.base64Accum.length > 0)
        res = this.iconv.decode(Buffer2.from(this.base64Accum, "base64"), "utf16-be");
      this.inBase64 = false;
      this.base64Accum = "";
      return res;
    };
  }
});

// node_modules/mariadb/node_modules/iconv-lite/encodings/sbcs-codec.js
var require_sbcs_codec = __commonJS({
  "node_modules/mariadb/node_modules/iconv-lite/encodings/sbcs-codec.js"(exports) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    exports._sbcs = SBCSCodec;
    function SBCSCodec(codecOptions, iconv) {
      if (!codecOptions)
        throw new Error("SBCS codec is called without the data.");
      if (!codecOptions.chars || codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256)
        throw new Error("Encoding '" + codecOptions.type + "' has incorrect 'chars' (must be of len 128 or 256)");
      if (codecOptions.chars.length === 128) {
        var asciiString = "";
        for (var i = 0; i < 128; i++)
          asciiString += String.fromCharCode(i);
        codecOptions.chars = asciiString + codecOptions.chars;
      }
      this.decodeBuf = Buffer2.from(codecOptions.chars, "ucs2");
      var encodeBuf = Buffer2.alloc(65536, iconv.defaultCharSingleByte.charCodeAt(0));
      for (var i = 0; i < codecOptions.chars.length; i++)
        encodeBuf[codecOptions.chars.charCodeAt(i)] = i;
      this.encodeBuf = encodeBuf;
    }
    SBCSCodec.prototype.encoder = SBCSEncoder;
    SBCSCodec.prototype.decoder = SBCSDecoder;
    function SBCSEncoder(options, codec) {
      this.encodeBuf = codec.encodeBuf;
    }
    SBCSEncoder.prototype.write = function(str) {
      var buf = Buffer2.alloc(str.length);
      for (var i = 0; i < str.length; i++)
        buf[i] = this.encodeBuf[str.charCodeAt(i)];
      return buf;
    };
    SBCSEncoder.prototype.end = function() {
    };
    function SBCSDecoder(options, codec) {
      this.decodeBuf = codec.decodeBuf;
    }
    SBCSDecoder.prototype.write = function(buf) {
      var decodeBuf = this.decodeBuf;
      var newBuf = Buffer2.alloc(buf.length * 2);
      var idx1 = 0, idx2 = 0;
      for (var i = 0; i < buf.length; i++) {
        idx1 = buf[i] * 2;
        idx2 = i * 2;
        newBuf[idx2] = decodeBuf[idx1];
        newBuf[idx2 + 1] = decodeBuf[idx1 + 1];
      }
      return newBuf.toString("ucs2");
    };
    SBCSDecoder.prototype.end = function() {
    };
  }
});

// node_modules/mariadb/node_modules/iconv-lite/encodings/sbcs-data.js
var require_sbcs_data = __commonJS({
  "node_modules/mariadb/node_modules/iconv-lite/encodings/sbcs-data.js"(exports, module) {
    "use strict";
    module.exports = {
      // Not supported by iconv, not sure why.
      "10029": "maccenteuro",
      "maccenteuro": {
        "type": "_sbcs",
        "chars": ""
      },
      "808": "cp808",
      "ibm808": "cp808",
      "cp808": {
        "type": "_sbcs",
        "chars": ""
      },
      "mik": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp720": {
        "type": "_sbcs",
        "chars": ""
      },
      // Aliases of generated encodings.
      "ascii8bit": "ascii",
      "usascii": "ascii",
      "ansix34": "ascii",
      "ansix341968": "ascii",
      "ansix341986": "ascii",
      "csascii": "ascii",
      "cp367": "ascii",
      "ibm367": "ascii",
      "isoir6": "ascii",
      "iso646us": "ascii",
      "iso646irv": "ascii",
      "us": "ascii",
      "latin1": "iso88591",
      "latin2": "iso88592",
      "latin3": "iso88593",
      "latin4": "iso88594",
      "latin5": "iso88599",
      "latin6": "iso885910",
      "latin7": "iso885913",
      "latin8": "iso885914",
      "latin9": "iso885915",
      "latin10": "iso885916",
      "csisolatin1": "iso88591",
      "csisolatin2": "iso88592",
      "csisolatin3": "iso88593",
      "csisolatin4": "iso88594",
      "csisolatincyrillic": "iso88595",
      "csisolatinarabic": "iso88596",
      "csisolatingreek": "iso88597",
      "csisolatinhebrew": "iso88598",
      "csisolatin5": "iso88599",
      "csisolatin6": "iso885910",
      "l1": "iso88591",
      "l2": "iso88592",
      "l3": "iso88593",
      "l4": "iso88594",
      "l5": "iso88599",
      "l6": "iso885910",
      "l7": "iso885913",
      "l8": "iso885914",
      "l9": "iso885915",
      "l10": "iso885916",
      "isoir14": "iso646jp",
      "isoir57": "iso646cn",
      "isoir100": "iso88591",
      "isoir101": "iso88592",
      "isoir109": "iso88593",
      "isoir110": "iso88594",
      "isoir144": "iso88595",
      "isoir127": "iso88596",
      "isoir126": "iso88597",
      "isoir138": "iso88598",
      "isoir148": "iso88599",
      "isoir157": "iso885910",
      "isoir166": "tis620",
      "isoir179": "iso885913",
      "isoir199": "iso885914",
      "isoir203": "iso885915",
      "isoir226": "iso885916",
      "cp819": "iso88591",
      "ibm819": "iso88591",
      "cyrillic": "iso88595",
      "arabic": "iso88596",
      "arabic8": "iso88596",
      "ecma114": "iso88596",
      "asmo708": "iso88596",
      "greek": "iso88597",
      "greek8": "iso88597",
      "ecma118": "iso88597",
      "elot928": "iso88597",
      "hebrew": "iso88598",
      "hebrew8": "iso88598",
      "turkish": "iso88599",
      "turkish8": "iso88599",
      "thai": "iso885911",
      "thai8": "iso885911",
      "celtic": "iso885914",
      "celtic8": "iso885914",
      "isoceltic": "iso885914",
      "tis6200": "tis620",
      "tis62025291": "tis620",
      "tis62025330": "tis620",
      "10000": "macroman",
      "10006": "macgreek",
      "10007": "maccyrillic",
      "10079": "maciceland",
      "10081": "macturkish",
      "cspc8codepage437": "cp437",
      "cspc775baltic": "cp775",
      "cspc850multilingual": "cp850",
      "cspcp852": "cp852",
      "cspc862latinhebrew": "cp862",
      "cpgr": "cp869",
      "msee": "cp1250",
      "mscyrl": "cp1251",
      "msansi": "cp1252",
      "msgreek": "cp1253",
      "msturk": "cp1254",
      "mshebr": "cp1255",
      "msarab": "cp1256",
      "winbaltrim": "cp1257",
      "cp20866": "koi8r",
      "20866": "koi8r",
      "ibm878": "koi8r",
      "cskoi8r": "koi8r",
      "cp21866": "koi8u",
      "21866": "koi8u",
      "ibm1168": "koi8u",
      "strk10482002": "rk1048",
      "tcvn5712": "tcvn",
      "tcvn57121": "tcvn",
      "gb198880": "iso646cn",
      "cn": "iso646cn",
      "csiso14jisc6220ro": "iso646jp",
      "jisc62201969ro": "iso646jp",
      "jp": "iso646jp",
      "cshproman8": "hproman8",
      "r8": "hproman8",
      "roman8": "hproman8",
      "xroman8": "hproman8",
      "ibm1051": "hproman8",
      "mac": "macintosh",
      "csmacintosh": "macintosh"
    };
  }
});

// node_modules/mariadb/node_modules/iconv-lite/encodings/sbcs-data-generated.js
var require_sbcs_data_generated = __commonJS({
  "node_modules/mariadb/node_modules/iconv-lite/encodings/sbcs-data-generated.js"(exports, module) {
    "use strict";
    module.exports = {
      "437": "cp437",
      "737": "cp737",
      "775": "cp775",
      "850": "cp850",
      "852": "cp852",
      "855": "cp855",
      "856": "cp856",
      "857": "cp857",
      "858": "cp858",
      "860": "cp860",
      "861": "cp861",
      "862": "cp862",
      "863": "cp863",
      "864": "cp864",
      "865": "cp865",
      "866": "cp866",
      "869": "cp869",
      "874": "windows874",
      "922": "cp922",
      "1046": "cp1046",
      "1124": "cp1124",
      "1125": "cp1125",
      "1129": "cp1129",
      "1133": "cp1133",
      "1161": "cp1161",
      "1162": "cp1162",
      "1163": "cp1163",
      "1250": "windows1250",
      "1251": "windows1251",
      "1252": "windows1252",
      "1253": "windows1253",
      "1254": "windows1254",
      "1255": "windows1255",
      "1256": "windows1256",
      "1257": "windows1257",
      "1258": "windows1258",
      "28591": "iso88591",
      "28592": "iso88592",
      "28593": "iso88593",
      "28594": "iso88594",
      "28595": "iso88595",
      "28596": "iso88596",
      "28597": "iso88597",
      "28598": "iso88598",
      "28599": "iso88599",
      "28600": "iso885910",
      "28601": "iso885911",
      "28603": "iso885913",
      "28604": "iso885914",
      "28605": "iso885915",
      "28606": "iso885916",
      "windows874": {
        "type": "_sbcs",
        "chars": ""
      },
      "win874": "windows874",
      "cp874": "windows874",
      "windows1250": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1250": "windows1250",
      "cp1250": "windows1250",
      "windows1251": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1251": "windows1251",
      "cp1251": "windows1251",
      "windows1252": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1252": "windows1252",
      "cp1252": "windows1252",
      "windows1253": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1253": "windows1253",
      "cp1253": "windows1253",
      "windows1254": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1254": "windows1254",
      "cp1254": "windows1254",
      "windows1255": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1255": "windows1255",
      "cp1255": "windows1255",
      "windows1256": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1256": "windows1256",
      "cp1256": "windows1256",
      "windows1257": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1257": "windows1257",
      "cp1257": "windows1257",
      "windows1258": {
        "type": "_sbcs",
        "chars": ""
      },
      "win1258": "windows1258",
      "cp1258": "windows1258",
      "iso88591": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28591": "iso88591",
      "iso88592": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28592": "iso88592",
      "iso88593": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28593": "iso88593",
      "iso88594": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28594": "iso88594",
      "iso88595": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28595": "iso88595",
      "iso88596": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28596": "iso88596",
      "iso88597": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28597": "iso88597",
      "iso88598": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28598": "iso88598",
      "iso88599": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28599": "iso88599",
      "iso885910": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28600": "iso885910",
      "iso885911": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28601": "iso885911",
      "iso885913": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28603": "iso885913",
      "iso885914": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28604": "iso885914",
      "iso885915": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28605": "iso885915",
      "iso885916": {
        "type": "_sbcs",
        "chars": ""
      },
      "cp28606": "iso885916",
      "cp437": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm437": "cp437",
      "csibm437": "cp437",
      "cp737": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm737": "cp737",
      "csibm737": "cp737",
      "cp775": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm775": "cp775",
      "csibm775": "cp775",
      "cp850": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm850": "cp850",
      "csibm850": "cp850",
      "cp852": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm852": "cp852",
      "csibm852": "cp852",
      "cp855": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm855": "cp855",
      "csibm855": "cp855",
      "cp856": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm856": "cp856",
      "csibm856": "cp856",
      "cp857": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm857": "cp857",
      "csibm857": "cp857",
      "cp858": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm858": "cp858",
      "csibm858": "cp858",
      "cp860": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm860": "cp860",
      "csibm860": "cp860",
      "cp861": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm861": "cp861",
      "csibm861": "cp861",
      "cp862": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm862": "cp862",
      "csibm862": "cp862",
      "cp863": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm863": "cp863",
      "csibm863": "cp863",
      "cp864": {
        "type": "_sbcs",
        "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
      },
      "ibm864": "cp864",
      "csibm864": "cp864",
      "cp865": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm865": "cp865",
      "csibm865": "cp865",
      "cp866": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm866": "cp866",
      "csibm866": "cp866",
      "cp869": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm869": "cp869",
      "csibm869": "cp869",
      "cp922": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm922": "cp922",
      "csibm922": "cp922",
      "cp1046": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm1046": "cp1046",
      "csibm1046": "cp1046",
      "cp1124": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm1124": "cp1124",
      "csibm1124": "cp1124",
      "cp1125": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm1125": "cp1125",
      "csibm1125": "cp1125",
      "cp1129": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm1129": "cp1129",
      "csibm1129": "cp1129",
      "cp1133": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm1133": "cp1133",
      "csibm1133": "cp1133",
      "cp1161": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm1161": "cp1161",
      "csibm1161": "cp1161",
      "cp1162": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm1162": "cp1162",
      "csibm1162": "cp1162",
      "cp1163": {
        "type": "_sbcs",
        "chars": ""
      },
      "ibm1163": "cp1163",
      "csibm1163": "cp1163",
      "maccroatian": {
        "type": "_sbcs",
        "chars": ""
      },
      "maccyrillic": {
        "type": "_sbcs",
        "chars": ""
      },
      "macgreek": {
        "type": "_sbcs",
        "chars": ""
      },
      "maciceland": {
        "type": "_sbcs",
        "chars": ""
      },
      "macroman": {
        "type": "_sbcs",
        "chars": ""
      },
      "macromania": {
        "type": "_sbcs",
        "chars": ""
      },
      "macthai": {
        "type": "_sbcs",
        "chars": "\uFEFF"
      },
      "macturkish": {
        "type": "_sbcs",
        "chars": ""
      },
      "macukraine": {
        "type": "_sbcs",
        "chars": ""
      },
      "koi8r": {
        "type": "_sbcs",
        "chars": ""
      },
      "koi8u": {
        "type": "_sbcs",
        "chars": ""
      },
      "koi8ru": {
        "type": "_sbcs",
        "chars": ""
      },
      "koi8t": {
        "type": "_sbcs",
        "chars": ""
      },
      "armscii8": {
        "type": "_sbcs",
        "chars": ")(.,-"
      },
      "rk1048": {
        "type": "_sbcs",
        "chars": ""
      },
      "tcvn": {
        "type": "_sbcs",
        "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
      },
      "georgianacademy": {
        "type": "_sbcs",
        "chars": ""
      },
      "georgianps": {
        "type": "_sbcs",
        "chars": ""
      },
      "pt154": {
        "type": "_sbcs",
        "chars": ""
      },
      "viscii": {
        "type": "_sbcs",
        "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}~"
      },
      "iso646cn": {
        "type": "_sbcs",
        "chars": "\0\x07\b	\n\v\f\r\x1B !\"#%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{|}"
      },
      "iso646jp": {
        "type": "_sbcs",
        "chars": "\0\x07\b	\n\v\f\r\x1B !\"#$%&'()*+,-./0123456789:;<=>?@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_`abcdefghijklmnopqrstuvwxyz{|}"
      },
      "hproman8": {
        "type": "_sbcs",
        "chars": ""
      },
      "macintosh": {
        "type": "_sbcs",
        "chars": ""
      },
      "ascii": {
        "type": "_sbcs",
        "chars": ""
      },
      "tis620": {
        "type": "_sbcs",
        "chars": ""
      }
    };
  }
});

// node_modules/mariadb/node_modules/iconv-lite/encodings/dbcs-codec.js
var require_dbcs_codec = __commonJS({
  "node_modules/mariadb/node_modules/iconv-lite/encodings/dbcs-codec.js"(exports) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    exports._dbcs = DBCSCodec;
    var UNASSIGNED = -1;
    var GB18030_CODE = -2;
    var SEQ_START = -10;
    var NODE_START = -1e3;
    var UNASSIGNED_NODE = new Array(256);
    var DEF_CHAR = -1;
    for (i = 0; i < 256; i++)
      UNASSIGNED_NODE[i] = UNASSIGNED;
    var i;
    function DBCSCodec(codecOptions, iconv) {
      this.encodingName = codecOptions.encodingName;
      if (!codecOptions)
        throw new Error("DBCS codec is called without the data.");
      if (!codecOptions.table)
        throw new Error("Encoding '" + this.encodingName + "' has no data.");
      var mappingTable = codecOptions.table();
      this.decodeTables = [];
      this.decodeTables[0] = UNASSIGNED_NODE.slice(0);
      this.decodeTableSeq = [];
      for (var i2 = 0; i2 < mappingTable.length; i2++)
        this._addDecodeChunk(mappingTable[i2]);
      if (typeof codecOptions.gb18030 === "function") {
        this.gb18030 = codecOptions.gb18030();
        var commonThirdByteNodeIdx = this.decodeTables.length;
        this.decodeTables.push(UNASSIGNED_NODE.slice(0));
        var commonFourthByteNodeIdx = this.decodeTables.length;
        this.decodeTables.push(UNASSIGNED_NODE.slice(0));
        var firstByteNode = this.decodeTables[0];
        for (var i2 = 129; i2 <= 254; i2++) {
          var secondByteNode = this.decodeTables[NODE_START - firstByteNode[i2]];
          for (var j = 48; j <= 57; j++) {
            if (secondByteNode[j] === UNASSIGNED) {
              secondByteNode[j] = NODE_START - commonThirdByteNodeIdx;
            } else if (secondByteNode[j] > NODE_START) {
              throw new Error("gb18030 decode tables conflict at byte 2");
            }
            var thirdByteNode = this.decodeTables[NODE_START - secondByteNode[j]];
            for (var k = 129; k <= 254; k++) {
              if (thirdByteNode[k] === UNASSIGNED) {
                thirdByteNode[k] = NODE_START - commonFourthByteNodeIdx;
              } else if (thirdByteNode[k] === NODE_START - commonFourthByteNodeIdx) {
                continue;
              } else if (thirdByteNode[k] > NODE_START) {
                throw new Error("gb18030 decode tables conflict at byte 3");
              }
              var fourthByteNode = this.decodeTables[NODE_START - thirdByteNode[k]];
              for (var l = 48; l <= 57; l++) {
                if (fourthByteNode[l] === UNASSIGNED)
                  fourthByteNode[l] = GB18030_CODE;
              }
            }
          }
        }
      }
      this.defaultCharUnicode = iconv.defaultCharUnicode;
      this.encodeTable = [];
      this.encodeTableSeq = [];
      var skipEncodeChars = {};
      if (codecOptions.encodeSkipVals)
        for (var i2 = 0; i2 < codecOptions.encodeSkipVals.length; i2++) {
          var val = codecOptions.encodeSkipVals[i2];
          if (typeof val === "number")
            skipEncodeChars[val] = true;
          else
            for (var j = val.from; j <= val.to; j++)
              skipEncodeChars[j] = true;
        }
      this._fillEncodeTable(0, 0, skipEncodeChars);
      if (codecOptions.encodeAdd) {
        for (var uChar in codecOptions.encodeAdd)
          if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))
            this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);
      }
      this.defCharSB = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];
      if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]["?"];
      if (this.defCharSB === UNASSIGNED) this.defCharSB = "?".charCodeAt(0);
    }
    DBCSCodec.prototype.encoder = DBCSEncoder;
    DBCSCodec.prototype.decoder = DBCSDecoder;
    DBCSCodec.prototype._getDecodeTrieNode = function(addr) {
      var bytes = [];
      for (; addr > 0; addr >>>= 8)
        bytes.push(addr & 255);
      if (bytes.length == 0)
        bytes.push(0);
      var node = this.decodeTables[0];
      for (var i2 = bytes.length - 1; i2 > 0; i2--) {
        var val = node[bytes[i2]];
        if (val == UNASSIGNED) {
          node[bytes[i2]] = NODE_START - this.decodeTables.length;
          this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));
        } else if (val <= NODE_START) {
          node = this.decodeTables[NODE_START - val];
        } else
          throw new Error("Overwrite byte in " + this.encodingName + ", addr: " + addr.toString(16));
      }
      return node;
    };
    DBCSCodec.prototype._addDecodeChunk = function(chunk) {
      var curAddr = parseInt(chunk[0], 16);
      var writeTable = this._getDecodeTrieNode(curAddr);
      curAddr = curAddr & 255;
      for (var k = 1; k < chunk.length; k++) {
        var part = chunk[k];
        if (typeof part === "string") {
          for (var l = 0; l < part.length; ) {
            var code = part.charCodeAt(l++);
            if (55296 <= code && code < 56320) {
              var codeTrail = part.charCodeAt(l++);
              if (56320 <= codeTrail && codeTrail < 57344)
                writeTable[curAddr++] = 65536 + (code - 55296) * 1024 + (codeTrail - 56320);
              else
                throw new Error("Incorrect surrogate pair in " + this.encodingName + " at chunk " + chunk[0]);
            } else if (4080 < code && code <= 4095) {
              var len = 4095 - code + 2;
              var seq = [];
              for (var m = 0; m < len; m++)
                seq.push(part.charCodeAt(l++));
              writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;
              this.decodeTableSeq.push(seq);
            } else
              writeTable[curAddr++] = code;
          }
        } else if (typeof part === "number") {
          var charCode = writeTable[curAddr - 1] + 1;
          for (var l = 0; l < part; l++)
            writeTable[curAddr++] = charCode++;
        } else
          throw new Error("Incorrect type '" + typeof part + "' given in " + this.encodingName + " at chunk " + chunk[0]);
      }
      if (curAddr > 255)
        throw new Error("Incorrect chunk in " + this.encodingName + " at addr " + chunk[0] + ": too long" + curAddr);
    };
    DBCSCodec.prototype._getEncodeBucket = function(uCode) {
      var high = uCode >> 8;
      if (this.encodeTable[high] === void 0)
        this.encodeTable[high] = UNASSIGNED_NODE.slice(0);
      return this.encodeTable[high];
    };
    DBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {
      var bucket = this._getEncodeBucket(uCode);
      var low = uCode & 255;
      if (bucket[low] <= SEQ_START)
        this.encodeTableSeq[SEQ_START - bucket[low]][DEF_CHAR] = dbcsCode;
      else if (bucket[low] == UNASSIGNED)
        bucket[low] = dbcsCode;
    };
    DBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {
      var uCode = seq[0];
      var bucket = this._getEncodeBucket(uCode);
      var low = uCode & 255;
      var node;
      if (bucket[low] <= SEQ_START) {
        node = this.encodeTableSeq[SEQ_START - bucket[low]];
      } else {
        node = {};
        if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low];
        bucket[low] = SEQ_START - this.encodeTableSeq.length;
        this.encodeTableSeq.push(node);
      }
      for (var j = 1; j < seq.length - 1; j++) {
        var oldVal = node[uCode];
        if (typeof oldVal === "object")
          node = oldVal;
        else {
          node = node[uCode] = {};
          if (oldVal !== void 0)
            node[DEF_CHAR] = oldVal;
        }
      }
      uCode = seq[seq.length - 1];
      node[uCode] = dbcsCode;
    };
    DBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {
      var node = this.decodeTables[nodeIdx];
      var hasValues = false;
      var subNodeEmpty = {};
      for (var i2 = 0; i2 < 256; i2++) {
        var uCode = node[i2];
        var mbCode = prefix + i2;
        if (skipEncodeChars[mbCode])
          continue;
        if (uCode >= 0) {
          this._setEncodeChar(uCode, mbCode);
          hasValues = true;
        } else if (uCode <= NODE_START) {
          var subNodeIdx = NODE_START - uCode;
          if (!subNodeEmpty[subNodeIdx]) {
            var newPrefix = mbCode << 8 >>> 0;
            if (this._fillEncodeTable(subNodeIdx, newPrefix, skipEncodeChars))
              hasValues = true;
            else
              subNodeEmpty[subNodeIdx] = true;
          }
        } else if (uCode <= SEQ_START) {
          this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);
          hasValues = true;
        }
      }
      return hasValues;
    };
    function DBCSEncoder(options, codec) {
      this.leadSurrogate = -1;
      this.seqObj = void 0;
      this.encodeTable = codec.encodeTable;
      this.encodeTableSeq = codec.encodeTableSeq;
      this.defaultCharSingleByte = codec.defCharSB;
      this.gb18030 = codec.gb18030;
    }
    DBCSEncoder.prototype.write = function(str) {
      var newBuf = Buffer2.alloc(str.length * (this.gb18030 ? 4 : 3)), leadSurrogate = this.leadSurrogate, seqObj = this.seqObj, nextChar = -1, i2 = 0, j = 0;
      while (true) {
        if (nextChar === -1) {
          if (i2 == str.length) break;
          var uCode = str.charCodeAt(i2++);
        } else {
          var uCode = nextChar;
          nextChar = -1;
        }
        if (55296 <= uCode && uCode < 57344) {
          if (uCode < 56320) {
            if (leadSurrogate === -1) {
              leadSurrogate = uCode;
              continue;
            } else {
              leadSurrogate = uCode;
              uCode = UNASSIGNED;
            }
          } else {
            if (leadSurrogate !== -1) {
              uCode = 65536 + (leadSurrogate - 55296) * 1024 + (uCode - 56320);
              leadSurrogate = -1;
            } else {
              uCode = UNASSIGNED;
            }
          }
        } else if (leadSurrogate !== -1) {
          nextChar = uCode;
          uCode = UNASSIGNED;
          leadSurrogate = -1;
        }
        var dbcsCode = UNASSIGNED;
        if (seqObj !== void 0 && uCode != UNASSIGNED) {
          var resCode = seqObj[uCode];
          if (typeof resCode === "object") {
            seqObj = resCode;
            continue;
          } else if (typeof resCode == "number") {
            dbcsCode = resCode;
          } else if (resCode == void 0) {
            resCode = seqObj[DEF_CHAR];
            if (resCode !== void 0) {
              dbcsCode = resCode;
              nextChar = uCode;
            } else {
            }
          }
          seqObj = void 0;
        } else if (uCode >= 0) {
          var subtable = this.encodeTable[uCode >> 8];
          if (subtable !== void 0)
            dbcsCode = subtable[uCode & 255];
          if (dbcsCode <= SEQ_START) {
            seqObj = this.encodeTableSeq[SEQ_START - dbcsCode];
            continue;
          }
          if (dbcsCode == UNASSIGNED && this.gb18030) {
            var idx = findIdx(this.gb18030.uChars, uCode);
            if (idx != -1) {
              var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);
              newBuf[j++] = 129 + Math.floor(dbcsCode / 12600);
              dbcsCode = dbcsCode % 12600;
              newBuf[j++] = 48 + Math.floor(dbcsCode / 1260);
              dbcsCode = dbcsCode % 1260;
              newBuf[j++] = 129 + Math.floor(dbcsCode / 10);
              dbcsCode = dbcsCode % 10;
              newBuf[j++] = 48 + dbcsCode;
              continue;
            }
          }
        }
        if (dbcsCode === UNASSIGNED)
          dbcsCode = this.defaultCharSingleByte;
        if (dbcsCode < 256) {
          newBuf[j++] = dbcsCode;
        } else if (dbcsCode < 65536) {
          newBuf[j++] = dbcsCode >> 8;
          newBuf[j++] = dbcsCode & 255;
        } else if (dbcsCode < 16777216) {
          newBuf[j++] = dbcsCode >> 16;
          newBuf[j++] = dbcsCode >> 8 & 255;
          newBuf[j++] = dbcsCode & 255;
        } else {
          newBuf[j++] = dbcsCode >>> 24;
          newBuf[j++] = dbcsCode >>> 16 & 255;
          newBuf[j++] = dbcsCode >>> 8 & 255;
          newBuf[j++] = dbcsCode & 255;
        }
      }
      this.seqObj = seqObj;
      this.leadSurrogate = leadSurrogate;
      return newBuf.slice(0, j);
    };
    DBCSEncoder.prototype.end = function() {
      if (this.leadSurrogate === -1 && this.seqObj === void 0)
        return;
      var newBuf = Buffer2.alloc(10), j = 0;
      if (this.seqObj) {
        var dbcsCode = this.seqObj[DEF_CHAR];
        if (dbcsCode !== void 0) {
          if (dbcsCode < 256) {
            newBuf[j++] = dbcsCode;
          } else {
            newBuf[j++] = dbcsCode >> 8;
            newBuf[j++] = dbcsCode & 255;
          }
        } else {
        }
        this.seqObj = void 0;
      }
      if (this.leadSurrogate !== -1) {
        newBuf[j++] = this.defaultCharSingleByte;
        this.leadSurrogate = -1;
      }
      return newBuf.slice(0, j);
    };
    DBCSEncoder.prototype.findIdx = findIdx;
    function DBCSDecoder(options, codec) {
      this.nodeIdx = 0;
      this.prevBytes = [];
      this.decodeTables = codec.decodeTables;
      this.decodeTableSeq = codec.decodeTableSeq;
      this.defaultCharUnicode = codec.defaultCharUnicode;
      this.gb18030 = codec.gb18030;
    }
    DBCSDecoder.prototype.write = function(buf) {
      var newBuf = Buffer2.alloc(buf.length * 2), nodeIdx = this.nodeIdx, prevBytes = this.prevBytes, prevOffset = this.prevBytes.length, seqStart = -this.prevBytes.length, uCode;
      for (var i2 = 0, j = 0; i2 < buf.length; i2++) {
        var curByte = i2 >= 0 ? buf[i2] : prevBytes[i2 + prevOffset];
        var uCode = this.decodeTables[nodeIdx][curByte];
        if (uCode >= 0) {
        } else if (uCode === UNASSIGNED) {
          uCode = this.defaultCharUnicode.charCodeAt(0);
          i2 = seqStart;
        } else if (uCode === GB18030_CODE) {
          if (i2 >= 3) {
            var ptr = (buf[i2 - 3] - 129) * 12600 + (buf[i2 - 2] - 48) * 1260 + (buf[i2 - 1] - 129) * 10 + (curByte - 48);
          } else {
            var ptr = (prevBytes[i2 - 3 + prevOffset] - 129) * 12600 + ((i2 - 2 >= 0 ? buf[i2 - 2] : prevBytes[i2 - 2 + prevOffset]) - 48) * 1260 + ((i2 - 1 >= 0 ? buf[i2 - 1] : prevBytes[i2 - 1 + prevOffset]) - 129) * 10 + (curByte - 48);
          }
          var idx = findIdx(this.gb18030.gbChars, ptr);
          uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];
        } else if (uCode <= NODE_START) {
          nodeIdx = NODE_START - uCode;
          continue;
        } else if (uCode <= SEQ_START) {
          var seq = this.decodeTableSeq[SEQ_START - uCode];
          for (var k = 0; k < seq.length - 1; k++) {
            uCode = seq[k];
            newBuf[j++] = uCode & 255;
            newBuf[j++] = uCode >> 8;
          }
          uCode = seq[seq.length - 1];
        } else
          throw new Error("iconv-lite internal error: invalid decoding table value " + uCode + " at " + nodeIdx + "/" + curByte);
        if (uCode >= 65536) {
          uCode -= 65536;
          var uCodeLead = 55296 | uCode >> 10;
          newBuf[j++] = uCodeLead & 255;
          newBuf[j++] = uCodeLead >> 8;
          uCode = 56320 | uCode & 1023;
        }
        newBuf[j++] = uCode & 255;
        newBuf[j++] = uCode >> 8;
        nodeIdx = 0;
        seqStart = i2 + 1;
      }
      this.nodeIdx = nodeIdx;
      this.prevBytes = seqStart >= 0 ? Array.prototype.slice.call(buf, seqStart) : prevBytes.slice(seqStart + prevOffset).concat(Array.prototype.slice.call(buf));
      return newBuf.slice(0, j).toString("ucs2");
    };
    DBCSDecoder.prototype.end = function() {
      var ret = "";
      while (this.prevBytes.length > 0) {
        ret += this.defaultCharUnicode;
        var bytesArr = this.prevBytes.slice(1);
        this.prevBytes = [];
        this.nodeIdx = 0;
        if (bytesArr.length > 0)
          ret += this.write(bytesArr);
      }
      this.prevBytes = [];
      this.nodeIdx = 0;
      return ret;
    };
    function findIdx(table, val) {
      if (table[0] > val)
        return -1;
      var l = 0, r = table.length;
      while (l < r - 1) {
        var mid = l + (r - l + 1 >> 1);
        if (table[mid] <= val)
          l = mid;
        else
          r = mid;
      }
      return l;
    }
  }
});

// node_modules/mariadb/node_modules/iconv-lite/encodings/tables/shiftjis.json
var require_shiftjis = __commonJS({
  "node_modules/mariadb/node_modules/iconv-lite/encodings/tables/shiftjis.json"(exports, module) {
    module.exports = [
      ["0", "\0", 128],
      ["a1", "", 62],
      ["8140", "", 9, ""],
      ["8180", ""],
      ["81b8", ""],
      ["81c8", ""],
      ["81da", ""],
      ["81f0", ""],
      ["81fc", ""],
      ["824f", "", 9],
      ["8260", "", 25],
      ["8281", "", 25],
      ["829f", "", 82],
      ["8340", "", 62],
      ["8380", "", 22],
      ["839f", "", 16, "", 6],
      ["83bf", "", 16, "", 6],
      ["8440", "", 5, "", 25],
      ["8470", "", 5, "", 7],
      ["8480", "", 17],
      ["849f", ""],
      ["8740", "", 19, "", 9],
      ["875f", ""],
      ["877e", ""],
      ["8780", "", 4, ""],
      ["889f", ""],
      ["8940", ""],
      ["8980", ""],
      ["8a40", ""],
      ["8a80", ""],
      ["8b40", ""],
      ["8b80", ""],
      ["8c40", ""],
      ["8c80", ""],
      ["8d40", ""],
      ["8d80", ""],
      ["8e40", ""],
      ["8e80", ""],
      ["8f40", ""],
      ["8f80", ""],
      ["9040", ""],
      ["9080", ""],
      ["9140", ""],
      ["9180", ""],
      ["9240", ""],
      ["9280", ""],
      ["9340", ""],
      ["9380", ""],
      ["9440", ""],
      ["9480", ""],
      ["9540", ""],
      ["9580", ""],
      ["9640", ""],
      ["9680", ""],
      ["9740", ""],
      ["9780", ""],
      ["9840", ""],
      ["989f", ""],
      ["9940", ""],
      ["9980", ""],
      ["9a40", ""],
      ["9a80", ""],
      ["9b40", ""],
      ["9b80", ""],
      ["9c40", ""],
      ["9c80", ""],
      ["9d40", ""],
      ["9d80", ""],
      ["9e40", ""],
      ["9e80", ""],
      ["9f40", ""],
      ["9f80", ""],
      ["e040", ""],
      ["e080", ""],
      ["e140", ""],
      ["e180", ""],
      ["e240", ""],
      ["e280", ""],
      ["e340", ""],
      ["e380", ""],
      ["e440", ""],
      ["e480", ""],
      ["e540", ""],
      ["e580", ""],
      ["e640", ""],
      ["e680", ""],
      ["e740", ""],
      ["e780", ""],
      ["e840", ""],
      ["e880", ""],
      ["e940", ""],
      ["e980", ""],
      ["ea40", ""],
      ["ea80", ""],
      ["ed40", ""],
      ["ed80", ""],
      ["ee40", ""],
      ["ee80", ""],
      ["eeef", "", 9, ""],
      ["f040", "", 62],
      ["f080", "", 124],
      ["f140", "", 62],
      ["f180", "", 124],
      ["f240", "", 62],
      ["f280", "", 124],
      ["f340", "", 62],
      ["f380", "", 124],
      ["f440", "", 62],
      ["f480", "", 124],
      ["f540", "", 62],
      ["f580", "", 124],
      ["f640", "", 62],
      ["f680", "", 124],
      ["f740", "", 62],
      ["f780", "", 124],
      ["f840", "", 62],
      ["f880", "", 124],
      ["f940", ""],
      ["fa40", "", 9, "", 9, ""],
      ["fa80", ""],
      ["fb40", ""],
      ["fb80", ""],
      ["fc40", ""]
    ];
  }
});

// node_modules/mariadb/node_modules/iconv-lite/encodings/tables/eucjp.json
var require_eucjp = __commonJS({
  "node_modules/mariadb/node_modules/iconv-lite/encodings/tables/eucjp.json"(exports, module) {
    module.exports = [
      ["0", "\0", 127],
      ["8ea1", "", 62],
      ["a1a1", "", 9, ""],
      ["a2a1", ""],
      ["a2ba", ""],
      ["a2ca", ""],
      ["a2dc", ""],
      ["a2f2", ""],
      ["a2fe", ""],
      ["a3b0", "", 9],
      ["a3c1", "", 25],
      ["a3e1", "", 25],
      ["a4a1", "", 82],
      ["a5a1", "", 85],
      ["a6a1", "", 16, "", 6],
      ["a6c1", "", 16, "", 6],
      ["a7a1", "", 5, "", 25],
      ["a7d1", "", 5, "", 25],
      ["a8a1", ""],
      ["ada1", "", 19, "", 9],
      ["adc0", ""],
      ["addf", "", 4, ""],
      ["b0a1", ""],
      ["b1a1", ""],
      ["b2a1", ""],
      ["b3a1", ""],
      ["b4a1", ""],
      ["b5a1", ""],
      ["b6a1", ""],
      ["b7a1", ""],
      ["b8a1", ""],
      ["b9a1", ""],
      ["baa1", ""],
      ["bba1", ""],
      ["bca1", ""],
      ["bda1", ""],
      ["bea1", ""],
      ["bfa1", ""],
      ["c0a1", ""],
      ["c1a1", ""],
      ["c2a1", ""],
      ["c3a1", ""],
      ["c4a1", ""],
      ["c5a1", ""],
      ["c6a1", ""],
      ["c7a1", ""],
      ["c8a1", ""],
      ["c9a1", ""],
      ["caa1", ""],
      ["cba1", ""],
      ["cca1", ""],
      ["cda1", ""],
      ["cea1", ""],
      ["cfa1", ""],
      ["d0a1", ""],
      ["d1a1", ""],
      ["d2a1", ""],
      ["d3a1", ""],
      ["d4a1", ""],
      ["d5a1", ""],
      ["d6a1", ""],
      ["d7a1", ""],
      ["d8a1", ""],
      ["d9a1", ""],
      ["daa1", ""],
      ["dba1", ""],
      ["dca1", ""],
      ["dda1", ""],
      ["dea1", ""],
      ["dfa1", ""],
      ["e0a1", ""],
      ["e1a1", ""],
      ["e2a1", ""],
      ["e3a1", ""],
      ["e4a1", ""],
      ["e5a1", ""],
      ["e6a1", ""],
      ["e7a1", ""],
      ["e8a1", ""],
      ["e9a1", ""],
      ["eaa1", ""],
      ["eba1", ""],
      ["eca1", ""],
      ["eda1", ""],
      ["eea1", ""],
      ["efa1", ""],
      ["f0a1", ""],
      ["f1a1", ""],
      ["f2a1", ""],
      ["f3a1", ""],
      ["f4a1", ""],
      ["f9a1", ""],
      ["faa1", ""],
      ["fba1", ""],
      ["fca1", ""],
      ["fcf1", "", 9, ""],
      ["8fa2af", ""],
      ["8fa2c2", ""],
      ["8fa2eb", ""],
      ["8fa6e1", ""],
      ["8fa6e7", ""],
      ["8fa6e9", ""],
      ["8fa6ec", ""],
      ["8fa6f1", ""],
      ["8fa7c2", "", 10, ""],
      ["8fa7f2", "", 10, ""],
      ["8fa9a1", ""],
      ["8fa9a4", ""],
      ["8fa9a6", ""],
      ["8fa9a8", ""],
      ["8fa9ab", ""],
      ["8fa9af", ""],
      ["8fa9c1", ""],
      ["8faaa1", ""],
      ["8faaba", ""],
      ["8faba1", ""],
      ["8fabbd", ""],
      ["8fabc5", ""],
      ["8fb0a1", ""],
      ["8fb1a1", ""],
      ["8fb2a1", "", 4, ""],
      ["8fb3a1", ""],
      ["8fb4a1", ""],
      ["8fb5a1", ""],
      ["8fb6a1", "", 5, "", 4, ""],
      ["8fb7a1", "", 4, ""],
      ["8fb8a1", ""],
      ["8fb9a1", ""],
      ["8fbaa1", "", 4, ""],
      ["8fbba1", ""],
      ["8fbca1", "", 4, ""],
      ["8fbda1", "", 4, ""],
      ["8fbea1", "", 4, ""],
      ["8fbfa1", ""],
      ["8fc0a1", ""],
      ["8fc1a1", ""],
      ["8fc2a1", ""],
      ["8fc3a1", "", 4, ""],
      ["8fc4a1", ""],
      ["8fc5a1", ""],
      ["8fc6a1", ""],
      ["8fc7a1", ""],
      ["8fc8a1", ""],
      ["8fc9a1", "", 4, "", 4, ""],
      ["8fcaa1", ""],
      ["8fcba1", ""],
      ["8fcca1", "", 9, ""],
      ["8fcda1", "", 5, ""],
      ["8fcea1", "", 6, ""],
      ["8fcfa1", ""],
      ["8fd0a1", ""],
      ["8fd1a1", ""],
      ["8fd2a1", "", 5],
      ["8fd3a1", ""],
      ["8fd4a1", "", 4, ""],
      ["8fd5a1", ""],
      ["8fd6a1", ""],
      ["8fd7a1", ""],
      ["8fd8a1", ""],
      ["8fd9a1", "", 4, "", 6, ""],
      ["8fdaa1", "", 4, ""],
      ["8fdba1", "", 6, ""],
      ["8fdca1", "", 4, ""],
      ["8fdda1", "", 4, ""],
      ["8fdea1", "", 4, ""],
      ["8fdfa1", ""],
      ["8fe0a1", ""],
      ["8fe1a1", "", 4, ""],
      ["8fe2a1", ""],
      ["8fe3a1", "", 5, "", 4, ""],
      ["8fe4a1", "", 4, ""],
      ["8fe5a1", "", 4, ""],
      ["8fe6a1", ""],
      ["8fe7a1", ""],
      ["8fe8a1", "", 4, ""],
      ["8fe9a1", "", 4],
      ["8feaa1", "", 4, ""],
      ["8feba1", "", 4, ""],
      ["8feca1", ""],
      ["8feda1", "", 4, "", 4, ""]
    ];
  }
});

// node_modules/mariadb/node_modules/iconv-lite/encodings/tables/cp936.json
var require_cp936 = __commonJS({
  "node_modules/mariadb/node_modules/iconv-lite/encodings/tables/cp936.json"(exports, module) {
    module.exports = [
      ["0", "\0", 127, ""],
      ["8140", "", 5, "", 9, "", 6, ""],
      ["8180", "", 6, "", 4, "", 4, "", 5, ""],
      ["8240", "", 4, "", 8, "", 4, "", 11],
      ["8280", "", 10, "", 4, "", 7, "", 5, "", 8, "", 20, "", 4, "", 6, ""],
      ["8340", "", 17, "", 5, "", 10, "", 4, "", 9, ""],
      ["8380", "", 5, "", 13, "", 28, "", 4, "", 4, "", 5],
      ["8440", "", 5, "", 5, ""],
      ["8480", "", 9, "", 4, "", 6, "", 6, "", 9, "", 5, "", 10, "", 7, ""],
      ["8540", "", 9, ""],
      ["8580", "", 4, "", 6, "", 4, "", 4, "", 7, ""],
      ["8640", "", 4, "", 5, "", 4, "", 5, ""],
      ["8680", "", 4, "", 4, "", 5, "", 6, "", 8, "", 4, "", 4, "", 4, ""],
      ["8740", "", 7, "", 11, "", 4, "", 4],
      ["8780", "", 7, "", 6, "", 14, "", 10, "", 6, "", 12, "", 8, "", 5, "", 6],
      ["8840", "", 9, "", 4, "", 4, ""],
      ["8880", "", 4, "", 6, "", 8, "", 6, "", 7, "", 4, "", 4, "", 7],
      ["8940", "", 5, "", 6, "", 4, "", 5, "", 4, "", 16, ""],
      ["8980", "", 4, "", 4, "", 7, "", 17, "", 10, "", 13, "", 5, "", 7, "", 4, ""],
      ["8a40", "", 4, "", 12, ""],
      ["8a80", "", 5, "", 6, "", 4, "", 11, "", 6, "", 4, "", 4, "", 9, "", 5],
      ["8b40", "", 8, "", 17, "", 6, "", 13, ""],
      ["8b80", "", 4, "", 4, "", 5, "", 4, "", 4, "", 22, "", 11, "", 25, "", 7, "", 6],
      ["8c40", "", 7, ""],
      ["8c80", "", 8, "", 4, "", 6, "", 6, "", 6, "", 4, "", 4, "", 4],
      ["8d40", "", 5, "", 5, "", 5, "", 6, "", 9, "", 4],
      ["8d80", "", 5, "", 4, "", 4, "", 4, "", 7, "", 7, "", 10, "", 10, "", 12, "", 21, ""],
      ["8e40", "", 21, "", 12, "", 6, "", 12, ""],
      ["8e80", "", 4, "", 7, "", 4, "", 4, "", 5, "", 6, "", 4, "", 14, "", 4, "", 4, "", 6],
      ["8f40", "", 5, "", 11, "", 8, ""],
      ["8f80", "", 6, "", 14, "", 5, "", 5, "", 4, ""],
      ["9040", "", 4, "", 4, "", 6, ""],
      ["9080", "", 7, "", 4, "", 4, "", 4, "", 4, "", 18, "", 6],
      ["9140", "", 6, "", 6, "", 18, "", 4, ""],
      ["9180", "", 6, "", 8, "", 9, "", 5, "", 4, "", 4, "", 16, "", 13, "", 8, "", 5, "", 4, ""],
      ["9240", "", 6, "", 5, ""],
      ["9280", "", 5, "", 7, "", 6, ""],
      ["9340", "", 6, "", 4, "", 4, "", 5, ""],
      ["9380", "", 5, "", 4, "", 6, "", 4, "", 7, "", 9, "", 6, "", 8, "", 4, "", 6, ""],
      ["9440", "", 24, "", 7, "", 7, "", 4, "", 8],
      ["9480", "", 4, "", 4, "", 14, "", 7, "", 7, ""],
      ["9540", "", 4, "", 4, "", 6, ""],
      ["9580", "", 4, "", 4, "", 8, "", 4, "", 4, "", 25, "", 7, "", 5, ""],
      ["9640", "", 5, "", 4, ""],
      ["9680", "", 7, "", 9, "", 7, "", 4, "", 6, "", 6, "", 5],
      ["9740", "", 7, "", 8, "", 7, "", 9, ""],
      ["9780", "", 6, "", 5, "", 4, "", 9, "", 4, "", 11, "", 7, "", 16, ""],
      ["9840", "", 4, "", 5, "", 9, ""],
      ["9880", "", 7, "", 5, "", 11, "", 9, "", 9, "", 11, "", 5, "", 5, "", 6, "", 4, "", 7, "", 6, ""],
      ["9940", "", 4, "", 10, "", 6, "", 8, "", 4, "", 7, "", 5],
      ["9980", "", 114, "", 6],
      ["9a40", "", 11, "", 7, "", 13, ""],
      ["9a80", "", 4, "", 7, "", 7, "", 6, "", 4, "", 4, "", 7, "", 6, "", 4, "", 4, ""],
      ["9b40", "", 4, ""],
      ["9b80", "", 5, "", 4, "", 4, "", 5, ""],
      ["9c40", "", 7, ""],
      ["9c80", "", 7, "", 7, "", 10, "", 14, "", 4, "", 6, "", 5],
      ["9d40", "", 7, "", 4, "", 9, "", 6, ""],
      ["9d80", "", 9, "", 5, "", 6, "", 12, "", 4, "", 10, "", 5, "", 5, "", 6, "", 10, ""],
      ["9e40", "", 7, "", 32, "", 7, "", 6, "", 6],
      ["9e80", "", 9, "", 17, "", 13, "", 11, "", 12, "", 12, ""],
      ["9f40", "", 6, "", 10, "", 4, "", 10, "", 7, ""],
      ["9f80", "", 13, "", 12, "", 4, "", 4, "", 5, "", 4, "", 4, "", 6, "", 5, "", 8, "", 9, "", 4],
      ["a040", "", 9, "", 5, "", 9, "", 11, "", 19],
      ["a080", "", 9, "", 6, "", 4, "", 11, "", 11, "", 6, ""],
      ["a1a1", "", 7, ""],
      ["a2a1", "", 9],
      ["a2b1", "", 19, "", 19, "", 9],
      ["a2e5", "", 9],
      ["a2f1", "", 11],
      ["a3a1", "", 88, ""],
      ["a4a1", "", 82],
      ["a5a1", "", 85],
      ["a6a1", "", 16, "", 6],
      ["a6c1", "", 16, "", 6],
      ["a6e0", ""],
      ["a6ee", ""],
      ["a6f4", ""],
      ["a7a1", "", 5, "", 25],
      ["a7d1", "", 5, "", 25],
      ["a840", "", 35, "", 6],
      ["a880", "", 7, ""],
      ["a8a1", ""],
      ["a8bd", ""],
      ["a8c0", ""],
      ["a8c5", "", 36],
      ["a940", "", 8, ""],
      ["a959", ""],
      ["a95c", ""],
      ["a960", "", 9, "", 8],
      ["a980", "", 4, ""],
      ["a996", ""],
      ["a9a4", "", 75],
      ["aa40", "", 5, "", 5, "", 8],
      ["aa80", "", 7, "", 10, ""],
      ["ab40", "", 11, "", 4, "", 5, "", 4],
      ["ab80", "", 6, "", 4],
      ["ac40", "", 10, "", 8, "", 5, "", 4, "", 11],
      ["ac80", "", 6, "", 12, "", 4, ""],
      ["ad40", "", 10, "", 7, "", 15, "", 12],
      ["ad80", "", 9, "", 8, "", 6, ""],
      ["ae40", "", 6, "", 7, "", 4, ""],
      ["ae80", "", 7, "", 6, "", 4, ""],
      ["af40", "", 4, ""],
      ["af80", ""],
      ["b040", "", 6, "", 5, "", 4, "", 6, "", 7, ""],
      ["b080", "", 7, "", 8, "", 9, ""],
      ["b140", "", 4, "", 7, "", 10, ""],
      ["b180", "", 4, "", 7, "", 7, ""],
      ["b240", "", 11, "", 5, "", 11, "", 4],
      ["b280", "", 12, "", 8, "", 4, ""],
      ["b340", "", 5, ""],
      ["b380", "", 11, "", 7, "", 6, ""],
      ["b440", "", 7, "", 9],
      ["b480", "", 4, "", 5, "", 6, ""],
      ["b540", "", 5, "", 9, "", 4, "", 14, "", 4, "", 8, ""],
      ["b580", "", 6, "", 4, ""],
      ["b640", "", 6, "", 11, "", 10, "", 4, "", 5, ""],
      ["b680", "", 6, "", 4, ""],
      ["b740", "", 14, "", 5, "", 9, "", 4, "", 16],
      ["b780", "", 6, ""],
      ["b840", "", 4, "", 10, "", 10, "", 9, "", 5, ""],
      ["b880", "", 4, ""],
      ["b940", "", 5, "", 10, "", 6, ""],
      ["b980", "", 7, ""],
      ["ba40", "", 4, "", 4, "", 7, "", 5, ""],
      ["ba80", "", 4, "", 5, "", 12, "", 5, ""],
      ["bb40", "", 9, "", 36, "", 5, "", 9],
      ["bb80", "", 6, "", 4, ""],
      ["bc40", "", 6, "", 6, "", 5, "", 7, "", 13, "", 5],
      ["bc80", "", 14, "", 6, ""],
      ["bd40", "", 54, "", 7],
      ["bd80", "", 32, ""],
      ["be40", "", 12, "", 6, "", 42],
      ["be80", "", 32, ""],
      ["bf40", "", 62],
      ["bf80", "", 4, "", 4, "", 21, ""],
      ["c040", "", 35, "", 23, ""],
      ["c080", "", 6, "", 9, ""],
      ["c140", "", 4, "", 7, "", 4, "", 4, "", 6, ""],
      ["c180", "", 4, "", 4, "", 5, ""],
      ["c240", "", 6, "", 5, ""],
      ["c280", "", 13, "", 5, "", 11, ""],
      ["c340", "", 5, "", 4, "", 6, ""],
      ["c380", "", 12, "", 4, ""],
      ["c440", "", 5, "", 4, "", 4, "", 5, "", 4, ""],
      ["c480", "", 7, "", 5, "", 6, ""],
      ["c540", "", 14, "", 4, "", 5, "", 4, "", 5, ""],
      ["c580", "", 7, "", 7, ""],
      ["c640", ""],
      ["c680", "", 4, "", 9, ""],
      ["c740", "", 4, "", 4, "", 6, "", 6, "", 6, ""],
      ["c780", ""],
      ["c840", "", 4, "", 5, "", 5, "", 7, "", 5, "", 7, ""],
      ["c880", "", 6, "", 4, "", 4, ""],
      ["c940", "", 4, "", 7, "", 12, ""],
      ["c980", "", 4, "", 4, "", 10, ""],
      ["ca40", "", 8, "", 8, "", 9, "", 4, "", 10],
      ["ca80", "", 4, "", 8, ""],
      ["cb40", "", 6, "", 10, "", 6, "", 5, "", 6, "", 6, "", 4, ""],
      ["cb80", "", 5, "", 6, "", 14, ""],
      ["cc40", "", 4, "", 10, "", 15, "", 13, ""],
      ["cc80", "", 11, "", 4, "", 7, ""],
      ["cd40", "", 6, "", 6, "", 4, "", 5, "", 4, "", 4, ""],
      ["cd80", ""],
      ["ce40", "", 6, "", 5, "", 7, ""],
      ["ce80", "", 4, "", 6, "", 4, ""],
      ["cf40", "", 4, "", 4, "", 6, "", 9],
      ["cf80", "", 5, "", 7, "", 4, ""],
      ["d040", "", 13, "", 5, "", 5, "", 5, "", 6, ""],
      ["d080", "", 4, "", 4, "", 5, ""],
      ["d140", "", 4, "", 4, "", 6, "", 5],
      ["d180", "", 4, "", 4, "", 4, ""],
      ["d240", "", 8, "", 24, "", 5, "", 19, ""],
      ["d280", "", 26, ""],
      ["d340", "", 30, "", 6],
      ["d380", "", 4, "", 5, "", 21, ""],
      ["d440", "", 31, "", 8, "", 21],
      ["d480", "", 25, "", 6, ""],
      ["d540", "", 7, "", 7, "", 46],
      ["d580", "", 32, ""],
      ["d640", "", 34, "", 27],
      ["d680", "", 30, ""],
      ["d740", "", 31, "", 4, "", 25],
      ["d780", "", 24, ""],
      ["d840", "", 8, "", 7, "", 5, "", 6, "", 6, "", 6, ""],
      ["d880", "", 6, "", 20, ""],
      ["d940", "", 62],
      ["d980", "", 32, ""],
      ["da40", "", 14, "", 8, "", 4, "", 9, ""],
      ["da80", "", 12, ""],
      ["db40", "", 6, "", 7, "", 4, ""],
      ["db80", "", 4, "", 5, "", 11, ""],
      ["dc40", "", 4, "", 6, "", 6, "", 11, "", 6, "", 7],
      ["dc80", "", 10, "", 21, ""],
      ["dd40", "", 62],
      ["dd80", "", 32, ""],
      ["de40", "", 32, ""],
      ["de80", "", 4, ""],
      ["df40", "", 5, "", 4, "", 4, "", 5, "", 4, "", 6, ""],
      ["df80", "", 4, ""],
      ["e040", "", 19, ""],
      ["e080", "", 10, "", 6, "", 8, ""],
      ["e140", "", 4, "", 6, "", 5, "", 5, ""],
      ["e180", "", 10, "", 9, "", 8, ""],
      ["e240", "", 62],
      ["e280", "", 32, "", 5, ""],
      ["e340", "", 45, "", 16],
      ["e380", "", 7, "", 24, ""],
      ["e440", "", 5, "", 24, "", 31],
      ["e480", "", 32, ""],
      ["e540", "", 51, "", 10],
      ["e580", "", 31, ""],
      ["e640", "", 34, "", 27],
      ["e680", "", 29, ""],
      ["e740", "", 7, "", 54],
      ["e780", "", 32, "", 6, "", 4, ""],
      ["e840", "", 14, "", 43, ""],
      ["e880", "", 20, ""],
      ["e940", "", 7, "", 42],
      ["e980", "", 32, ""],
      ["ea40", "", 27, "", 6, ""],
      ["ea80", "", 4, "", 12, ""],
      ["eb40", "", 9, "", 7, "", 9, "", 6, ""],
      ["eb80", "", 4, ""],
      ["ec40", "", 8, "", 4, "", 18, "", 7],
      ["ec80", "", 4, "", 7, "", 4, "", 4, ""],
      ["ed40", "", 6, "", 46],
      ["ed80", "", 4, "", 23, ""],
      ["ee40", "", 62],
      ["ee80", "", 32, "", 4, "", 6, ""],
      ["ef40", "", 5, "", 37, "", 4],
      ["ef80", "", 30, "", 4, "", 8, ""],
      ["f040", "", 4, "", 28, "", 26],
      ["f080", "", 9, "", 12, "", 4, "", 6, ""],
      ["f140", "", 10, "", 47],
      ["f180", "", 32, ""],
      ["f240", "", 62],
      ["f280", "", 32, ""],
      ["f340", "", 17, "", 6, "", 4, ""],
      ["f380", "", 8, "", 6, ""],
      ["f440", "", 5, "", 10, "", 10, "", 7, "", 5],
      ["f480", "", 32, ""],
      ["f540", "", 62],
      ["f580", "", 32, ""],
      ["f640", "", 62],
      ["f680", "", 32, "", 5, "", 5, "", 4, "", 7, ""],
      ["f740", "", 62],
      ["f780", "", 4, "", 4, ""],
      ["f840", "", 62],
      ["f880", "", 32],
      ["f940", "", 62],
      ["f980", "", 32],
      ["fa40", "", 62],
      ["fa80", "", 32],
      ["fb40", "", 27, "", 9, ""],
      ["fb80", "", 5, "", 8, "", 5, ""],
      ["fc40", "", 8, "", 4, "", 8, "", 6],
      ["fc80", "", 4, "", 5, "", 8, ""],
      ["fd40", "", 4, "", 4, "", 10, "", 38],
      ["fd80", "", 5, "", 11, "", 4, ""],
      ["fe40", ""]
    ];
  }
});

// node_modules/mariadb/node_modules/iconv-lite/encodings/tables/gbk-added.json
var require_gbk_added = __commonJS({
  "node_modules/mariadb/node_modules/iconv-lite/encodings/tables/gbk-added.json"(exports, module) {
    module.exports = [
      ["a140", "", 62],
      ["a180", "", 32],
      ["a240", "", 62],
      ["a280", "", 32],
      ["a2ab", "", 5],
      ["a2e3", ""],
      ["a2ef", ""],
      ["a2fd", ""],
      ["a340", "", 62],
      ["a380", "", 31, ""],
      ["a440", "", 62],
      ["a480", "", 32],
      ["a4f4", "", 10],
      ["a540", "", 62],
      ["a580", "", 32],
      ["a5f7", "", 7],
      ["a640", "", 62],
      ["a680", "", 32],
      ["a6b9", "", 7],
      ["a6d9", "", 6],
      ["a6ec", ""],
      ["a6f3", ""],
      ["a6f6", "", 8],
      ["a740", "", 62],
      ["a780", "", 32],
      ["a7c2", "", 14],
      ["a7f2", "", 12],
      ["a896", "", 10],
      ["a8bc", ""],
      ["a8bf", ""],
      ["a8c1", ""],
      ["a8ea", "", 20],
      ["a958", ""],
      ["a95b", ""],
      ["a95d", ""],
      ["a989", "", 11],
      ["a997", "", 12],
      ["a9f0", "", 14],
      ["aaa1", "", 93],
      ["aba1", "", 93],
      ["aca1", "", 93],
      ["ada1", "", 93],
      ["aea1", "", 93],
      ["afa1", "", 93],
      ["d7fa", "", 4],
      ["f8a1", "", 93],
      ["f9a1", "", 93],
      ["faa1", "", 93],
      ["fba1", "", 93],
      ["fca1", "", 93],
      ["fda1", "", 93],
      ["fe50", ""],
      ["fe80", "", 6, "", 93],
      ["8135f437", ""]
    ];
  }
});

// node_modules/mariadb/node_modules/iconv-lite/encodings/tables/gb18030-ranges.json
var require_gb18030_ranges = __commonJS({
  "node_modules/mariadb/node_modules/iconv-lite/encodings/tables/gb18030-ranges.json"(exports, module) {
    module.exports = { uChars: [128, 165, 169, 178, 184, 216, 226, 235, 238, 244, 248, 251, 253, 258, 276, 284, 300, 325, 329, 334, 364, 463, 465, 467, 469, 471, 473, 475, 477, 506, 594, 610, 712, 716, 730, 930, 938, 962, 970, 1026, 1104, 1106, 8209, 8215, 8218, 8222, 8231, 8241, 8244, 8246, 8252, 8365, 8452, 8454, 8458, 8471, 8482, 8556, 8570, 8596, 8602, 8713, 8720, 8722, 8726, 8731, 8737, 8740, 8742, 8748, 8751, 8760, 8766, 8777, 8781, 8787, 8802, 8808, 8816, 8854, 8858, 8870, 8896, 8979, 9322, 9372, 9548, 9588, 9616, 9622, 9634, 9652, 9662, 9672, 9676, 9680, 9702, 9735, 9738, 9793, 9795, 11906, 11909, 11913, 11917, 11928, 11944, 11947, 11951, 11956, 11960, 11964, 11979, 12284, 12292, 12312, 12319, 12330, 12351, 12436, 12447, 12535, 12543, 12586, 12842, 12850, 12964, 13200, 13215, 13218, 13253, 13263, 13267, 13270, 13384, 13428, 13727, 13839, 13851, 14617, 14703, 14801, 14816, 14964, 15183, 15471, 15585, 16471, 16736, 17208, 17325, 17330, 17374, 17623, 17997, 18018, 18212, 18218, 18301, 18318, 18760, 18811, 18814, 18820, 18823, 18844, 18848, 18872, 19576, 19620, 19738, 19887, 40870, 59244, 59336, 59367, 59413, 59417, 59423, 59431, 59437, 59443, 59452, 59460, 59478, 59493, 63789, 63866, 63894, 63976, 63986, 64016, 64018, 64021, 64025, 64034, 64037, 64042, 65074, 65093, 65107, 65112, 65127, 65132, 65375, 65510, 65536], gbChars: [0, 36, 38, 45, 50, 81, 89, 95, 96, 100, 103, 104, 105, 109, 126, 133, 148, 172, 175, 179, 208, 306, 307, 308, 309, 310, 311, 312, 313, 341, 428, 443, 544, 545, 558, 741, 742, 749, 750, 805, 819, 820, 7922, 7924, 7925, 7927, 7934, 7943, 7944, 7945, 7950, 8062, 8148, 8149, 8152, 8164, 8174, 8236, 8240, 8262, 8264, 8374, 8380, 8381, 8384, 8388, 8390, 8392, 8393, 8394, 8396, 8401, 8406, 8416, 8419, 8424, 8437, 8439, 8445, 8482, 8485, 8496, 8521, 8603, 8936, 8946, 9046, 9050, 9063, 9066, 9076, 9092, 9100, 9108, 9111, 9113, 9131, 9162, 9164, 9218, 9219, 11329, 11331, 11334, 11336, 11346, 11361, 11363, 11366, 11370, 11372, 11375, 11389, 11682, 11686, 11687, 11692, 11694, 11714, 11716, 11723, 11725, 11730, 11736, 11982, 11989, 12102, 12336, 12348, 12350, 12384, 12393, 12395, 12397, 12510, 12553, 12851, 12962, 12973, 13738, 13823, 13919, 13933, 14080, 14298, 14585, 14698, 15583, 15847, 16318, 16434, 16438, 16481, 16729, 17102, 17122, 17315, 17320, 17402, 17418, 17859, 17909, 17911, 17915, 17916, 17936, 17939, 17961, 18664, 18703, 18814, 18962, 19043, 33469, 33470, 33471, 33484, 33485, 33490, 33497, 33501, 33505, 33513, 33520, 33536, 33550, 37845, 37921, 37948, 38029, 38038, 38064, 38065, 38066, 38069, 38075, 38076, 38078, 39108, 39109, 39113, 39114, 39115, 39116, 39265, 39394, 189e3] };
  }
});

// node_modules/mariadb/node_modules/iconv-lite/encodings/tables/cp949.json
var require_cp949 = __commonJS({
  "node_modules/mariadb/node_modules/iconv-lite/encodings/tables/cp949.json"(exports, module) {
    module.exports = [
      ["0", "\0", 127],
      ["8141", "", 4, "", 6, ""],
      ["8161", "", 9, "", 5, ""],
      ["8181", "", 18, "", 4, "", 6, "", 5, "", 6, "", 7, "", 7, "", 4, "", 4, ""],
      ["8241", "", 7, "", 5],
      ["8261", "", 6, "", 5, ""],
      ["8281", "", 7, "", 7, "", 4, "", 10, "", 5, "", 17, "", 7, "", 6, "", 7, "", 18],
      ["8341", "", 5, "", 5, "", 7],
      ["8361", "", 18, ""],
      ["8381", "", 4, "", 6, "", 5, "", 5, "", 46, "", 6, "", 5, "", 8],
      ["8441", "", 5, "", 8],
      ["8461", "", 18],
      ["8481", "", 7, "", 6, "", 5, "", 10, "", 5, "", 18, "", 5, "", 6, "", 5, "", 26, ""],
      ["8541", "", 5, "", 4, "", 6, "", 4],
      ["8561", "", 5, "", 5, "", 6, ""],
      ["8581", "", 6, "", 6, "", 9, "", 26, "", 29, "", 6, "", 5, ""],
      ["8641", "", 6, "", 5, ""],
      ["8661", "", 6, "", 10],
      ["8681", "", 22, "", 4, "", 6, "", 5, "", 6, "", 22, "", 4, ""],
      ["8741", "", 9, "", 15],
      ["8761", "", 18, ""],
      ["8781", "", 5, "", 7, "", 7, "", 5, "", 6, "", 5, "", 18, "", 6, "", 26, "", 6, "", 4],
      ["8841", "", 4, "", 5, "", 6, "", 4],
      ["8861", "", 4, ""],
      ["8881", "", 15, "", 4, "", 6, "", 5, "", 54, ""],
      ["8941", "", 6, "", 5, ""],
      ["8961", "", 10, "", 5, ""],
      ["8981", "", 21, "", 18, "", 18, "", 6, "", 6, "", 7, "", 15],
      ["8a41", "", 10, "", 6, ""],
      ["8a61", "", 4, "", 18, ""],
      ["8a81", "", 4, "", 19, "", 5, "", 7, "", 5, "", 6, "", 5, "", 4, "", 5, "", 26, ""],
      ["8b41", "", 5, "", 4, "", 6, ""],
      ["8b61", "", 6, "", 8],
      ["8b81", "", 52, "", 4, "", 6, "", 5, "", 18, "", 18],
      ["8c41", "", 15, "", 4],
      ["8c61", "", 6, "", 5, "", 6, "", 5],
      ["8c81", "", 12, "", 26, "", 50, "", 5, "", 16],
      ["8d41", "", 16, "", 8],
      ["8d61", "", 17, ""],
      ["8d81", "", 4, "", 33, "", 6, "", 7, "", 6, "", 9, "", 6, "", 5, "", 6, ""],
      ["8e41", "", 6, "", 5, "", 8],
      ["8e61", "", 4, "", 19],
      ["8e81", "", 13, "", 6, "", 4, "", 6, "", 5, "", 6, "", 5, "", 11, "", 7, "", 6, "", 5, "", 7],
      ["8f41", "", 7, "", 17],
      ["8f61", "", 7, "", 6, "", 4],
      ["8f81", "", 5, "", 7, "", 5, "", 6, "", 5, "", 18, "", 6, "", 26, "", 6, "", 5],
      ["9041", "", 6, "", 5, ""],
      ["9061", "", 5, "", 15],
      ["9081", "", 12, "", 6, "", 5, "", 4, "", 6, "", 4, "", 5, "", 11, "", 33, ""],
      ["9141", "", 6, "", 5],
      ["9161", "", 9, "", 5],
      ["9181", "", 20, "", 4, "", 5, "", 14, "", 33, "", 7, "", 5, "", 6],
      ["9241", "", 7, "", 4, ""],
      ["9261", "", 7, "", 7, "", 4],
      ["9281", "", 21, "", 18, "", 6, "", 7, "", 6, "", 35, ""],
      ["9341", "", 4, ""],
      ["9361", "", 6, "", 8],
      ["9381", "", 37, "", 4, "", 4, "", 6, "", 5, "", 7, "", 22, ""],
      ["9441", "", 5, "", 5, "", 8],
      ["9461", "", 5, "", 6, "", 12],
      ["9481", "", 5, "", 6, "", 6, "", 9, "", 22, "", 4, "", 6, "", 10, "", 6, "", 24],
      ["9541", "", 11, "", 5, ""],
      ["9561", "", 6, "", 5, ""],
      ["9581", "", 6, "", 35, "", 4, "", 4, "", 4, "", 6, "", 5, "", 13, "", 14],
      ["9641", "", 23, ""],
      ["9661", "", 6, "", 5, "", 8],
      ["9681", "", 10, "", 5, "", 13, "", 33, "", 6, "", 44],
      ["9741", "", 16, "", 8],
      ["9761", "", 17, "", 7],
      ["9781", "", 11, "", 5, "", 6, "", 89, ""],
      ["9841", "", 16, "", 5, ""],
      ["9861", "", 6, "", 15],
      ["9881", "", 21, "", 6, "", 5, "", 4, "", 6, "", 5, "", 6, "", 5, "", 6, "", 5, ""],
      ["9941", "", 6, "", 5, ""],
      ["9961", "", 6, "", 5, ""],
      ["9981", "", 8, "", 5, "", 4, "", 11, "", 5, "", 6, "", 6, "", 6, "", 7, "", 6, "", 5, ""],
      ["9a41", "", 16],
      ["9a61", "", 6, "", 6, ""],
      ["9a81", "", 4, "", 6, "", 5, "", 5, "", 6, "", 5, "", 5, "", 33, "", 5, "", 6, ""],
      ["9b41", "", 6, "", 8],
      ["9b61", "", 17, "", 7],
      ["9b81", "", 25, "", 4, "", 5, "", 50, "", 22, ""],
      ["9c41", "", 4, "", 5, "", 5],
      ["9c61", "", 8, "", 6, "", 9],
      ["9c81", "", 8, "", 6, "", 6, "", 9, "", 26, "", 6, "", 5, "", 18, "", 6, "", 12],
      ["9d41", "", 13, "", 8],
      ["9d61", "", 25],
      ["9d81", "", 8, "", 5, "", 9, "", 6, "", 10, "", 6, "", 5, "", 6, "", 5, ""],
      ["9e41", "", 7, "", 9, ""],
      ["9e61", "", 4, "", 6, ""],
      ["9e81", "", 6, "", 6, "", 6, "", 5, "", 10, "", 5, "", 6, "", 5, "", 6, ""],
      ["9f41", "", 5, "", 4, "", 5, ""],
      ["9f61", "", 6, "", 5, ""],
      ["9f81", "", 4, "", 5, "", 6, "", 5, "", 6, "", 4, "", 6, "", 7, "", 4, "", 4, ""],
      ["a041", "", 5, "", 6, ""],
      ["a061", "", 5, "", 13],
      ["a081", "", 4, "", 4, "", 4, "", 6, "", 5, "", 6, "", 5, "", 26, "", 4, "", 5, "", 7, ""],
      ["a141", "", 18, ""],
      ["a161", "", 6, "", 5, ""],
      ["a181", "", 14, "", 5, "", 4, "", 9, ""],
      ["a241", "", 5, "", 18],
      ["a261", "", 6, "", 18],
      ["a281", "", 7, "", 6, "", 7, ""],
      ["a341", "", 6, "", 10, ""],
      ["a361", "", 6, "", 16],
      ["a381", "", 16, "", 4, "", 58, "", 32, ""],
      ["a441", "", 5, ""],
      ["a461", "", 5, "", 12],
      ["a481", "", 28, "", 93],
      ["a541", "", 4, "", 6, "", 5, ""],
      ["a561", "", 17, "", 5, ""],
      ["a581", "", 16, "", 14, "", 9],
      ["a5b0", "", 9],
      ["a5c1", "", 16, "", 6],
      ["a5e1", "", 16, "", 6],
      ["a641", "", 19, ""],
      ["a661", "", 5, "", 5, "", 6],
      ["a681", "", 6, "", 18, "", 7],
      ["a741", "", 4, "", 6, "", 7],
      ["a761", "", 22, ""],
      ["a781", "", 6, "", 5, "", 7, "", 9, "", 9, "", 4, "", 5, "", 4, ""],
      ["a841", "", 10, "", 14],
      ["a861", "", 18, "", 6],
      ["a881", "", 19, "", 11, ""],
      ["a8a6", ""],
      ["a8a8", ""],
      ["a8b1", "", 27, "", 25, "", 14, ""],
      ["a941", "", 14, "", 10],
      ["a961", "", 18],
      ["a981", "", 14, "", 6, "", 27, "", 25, "", 14, ""],
      ["aa41", "", 6, "", 4, ""],
      ["aa61", "", 4, "", 5, "", 6, ""],
      ["aa81", "", 29, "", 82],
      ["ab41", "", 6, "", 5, ""],
      ["ab61", "", 6, "", 5, "", 5],
      ["ab81", "", 8, "", 6, "", 12, "", 85],
      ["ac41", "", 5, "", 6, ""],
      ["ac61", "", 11, "", 4],
      ["ac81", "", 28, "", 5, "", 25],
      ["acd1", "", 5, "", 25],
      ["ad41", "", 6, "", 5, "", 7],
      ["ad61", "", 6, "", 10, ""],
      ["ad81", "", 5, "", 18, ""],
      ["ae41", "", 5, "", 16],
      ["ae61", "", 5, "", 6, "", 4],
      ["ae81", "", 6, "", 5, ""],
      ["af41", "", 19],
      ["af61", "", 13, "", 5, ""],
      ["af81", "", 5, "", 6, "", 5, ""],
      ["b041", "", 5, "", 5, "", 12],
      ["b061", "", 5, "", 19],
      ["b081", "", 13, "", 6, "", 5, "", 7, "", 4, ""],
      ["b141", "", 6, "", 5, ""],
      ["b161", "", 6, "", 5, "", 11],
      ["b181", "", 14, "", 6, ""],
      ["b241", "", 6, "", 5, ""],
      ["b261", "", 18, "", 5, ""],
      ["b281", "", 5, "", 18, "", 6, ""],
      ["b341", "", 19, ""],
      ["b361", "", 5, "", 5, "", 5],
      ["b381", "", 5, "", 5, "", 19, "", 4, ""],
      ["b441", "", 5, "", 6, "", 5],
      ["b461", "", 6, "", 10, ""],
      ["b481", "", 6, "", 18, "", 4, "", 4, ""],
      ["b541", "", 14, "", 5],
      ["b561", "", 5, "", 5, "", 4],
      ["b581", "", 6, "", 5, "", 11, ""],
      ["b641", "", 7, "", 17],
      ["b661", "", 15, ""],
      ["b681", "", 5, "", 6, "", 5, ""],
      ["b741", "", 13, "", 6, ""],
      ["b761", "", 20, ""],
      ["b781", "", 6, "", 14, ""],
      ["b841", "", 7, "", 17],
      ["b861", "", 8, "", 13],
      ["b881", "", 5, "", 24, "", 4, ""],
      ["b941", "", 6, "", 5, ""],
      ["b961", "", 14, "", 6, ""],
      ["b981", "", 22, "", 4, "", 4, ""],
      ["ba41", "", 5, "", 6, ""],
      ["ba61", "", 5, "", 4, "", 5],
      ["ba81", "", 6, "", 9, ""],
      ["bb41", "", 4, "", 5, "", 4, ""],
      ["bb61", "", 6, "", 5, ""],
      ["bb81", "", 31, ""],
      ["bc41", "", 17, ""],
      ["bc61", "", 5, "", 6, ""],
      ["bc81", "", 4, "", 6, "", 5, "", 5, "", 4, ""],
      ["bd41", "", 7, "", 7, ""],
      ["bd61", "", 5, "", 13],
      ["bd81", "", 5, "", 25, ""],
      ["be41", "", 7, "", 14],
      ["be61", "", 7, "", 7, ""],
      ["be81", "", 4, "", 4, "", 5, "", 8, "", 6, ""],
      ["bf41", "", 10, "", 14],
      ["bf61", "", 18, ""],
      ["bf81", "", 5, "", 7, "", 6, "", 5, ""],
      ["c041", "", 5, "", 6, "", 5],
      ["c061", "", 25],
      ["c081", "", 6, "", 5, "", 7, ""],
      ["c141", "", 5, "", 6, ""],
      ["c161", "", 19, ""],
      ["c181", "", 31, ""],
      ["c241", "", 4, "", 5, ""],
      ["c261", "", 4, "", 5, "", 6, ""],
      ["c281", "", 5, "", 7, "", 9, ""],
      ["c341", "", 4],
      ["c361", "", 4, "", 5, "", 11],
      ["c381", "", 5, "", 7, "", 5, ""],
      ["c441", "", 7, "", 7, ""],
      ["c461", "", 5, "", 4],
      ["c481", "", 5, "", 11, ""],
      ["c541", "", 6, "", 5, ""],
      ["c561", "", 6, "", 5, "", 4],
      ["c581", "", 6, "", 5, ""],
      ["c641", "", 6, "", 5],
      ["c6a1", ""],
      ["c7a1", ""],
      ["c8a1", ""],
      ["caa1", ""],
      ["cba1", ""],
      ["cca1", ""],
      ["cda1", ""],
      ["cea1", ""],
      ["cfa1", ""],
      ["d0a1", ""],
      ["d1a1", "", 5, "", 4, ""],
      ["d2a1", "", 4, "", 5, "", 10, "", 7, "", 5, ""],
      ["d3a1", ""],
      ["d4a1", ""],
      ["d5a1", ""],
      ["d6a1", ""],
      ["d7a1", ""],
      ["d8a1", ""],
      ["d9a1", ""],
      ["daa1", ""],
      ["dba1", ""],
      ["dca1", ""],
      ["dda1", ""],
      ["dea1", ""],
      ["dfa1", ""],
      ["e0a1", ""],
      ["e1a1", ""],
      ["e2a1", ""],
      ["e3a1", ""],
      ["e4a1", ""],
      ["e5a1", ""],
      ["e6a1", ""],
      ["e7a1", ""],
      ["e8a1", ""],
      ["e9a1", ""],
      ["eaa1", ""],
      ["eba1", ""],
      ["eca1", ""],
      ["eda1", ""],
      ["eea1", ""],
      ["efa1", ""],
      ["f0a1", ""],
      ["f1a1", ""],
      ["f2a1", ""],
      ["f3a1", ""],
      ["f4a1", ""],
      ["f5a1", ""],
      ["f6a1", ""],
      ["f7a1", ""],
      ["f8a1", ""],
      ["f9a1", ""],
      ["faa1", ""],
      ["fba1", ""],
      ["fca1", ""],
      ["fda1", ""]
    ];
  }
});

// node_modules/mariadb/node_modules/iconv-lite/encodings/tables/cp950.json
var require_cp950 = __commonJS({
  "node_modules/mariadb/node_modules/iconv-lite/encodings/tables/cp950.json"(exports, module) {
    module.exports = [
      ["0", "\0", 127],
      ["a140", ""],
      ["a1a1", "", 4, ""],
      ["a240", "", 7, ""],
      ["a2a1", "", 9, "", 9, "", 8, "", 25, "", 21],
      ["a340", "", 16, "", 6, "", 16, "", 6, "", 10],
      ["a3a1", "", 25, ""],
      ["a3e1", ""],
      ["a440", ""],
      ["a4a1", ""],
      ["a540", ""],
      ["a5a1", ""],
      ["a640", ""],
      ["a6a1", ""],
      ["a740", ""],
      ["a7a1", ""],
      ["a840", ""],
      ["a8a1", ""],
      ["a940", ""],
      ["a9a1", ""],
      ["aa40", ""],
      ["aaa1", ""],
      ["ab40", ""],
      ["aba1", ""],
      ["ac40", ""],
      ["aca1", ""],
      ["ad40", ""],
      ["ada1", ""],
      ["ae40", ""],
      ["aea1", ""],
      ["af40", ""],
      ["afa1", ""],
      ["b040", ""],
      ["b0a1", ""],
      ["b140", ""],
      ["b1a1", ""],
      ["b240", ""],
      ["b2a1", ""],
      ["b340", ""],
      ["b3a1", ""],
      ["b440", ""],
      ["b4a1", ""],
      ["b540", ""],
      ["b5a1", ""],
      ["b640", ""],
      ["b6a1", ""],
      ["b740", ""],
      ["b7a1", ""],
      ["b840", ""],
      ["b8a1", ""],
      ["b940", ""],
      ["b9a1", ""],
      ["ba40", ""],
      ["baa1", ""],
      ["bb40", ""],
      ["bba1", ""],
      ["bc40", ""],
      ["bca1", ""],
      ["bd40", ""],
      ["bda1", ""],
      ["be40", ""],
      ["bea1", ""],
      ["bf40", ""],
      ["bfa1", ""],
      ["c040", ""],
      ["c0a1", ""],
      ["c140", ""],
      ["c1a1", ""],
      ["c240", ""],
      ["c2a1", ""],
      ["c340", ""],
      ["c3a1", ""],
      ["c440", ""],
      ["c4a1", ""],
      ["c540", ""],
      ["c5a1", ""],
      ["c640", ""],
      ["c940", ""],
      ["c9a1", ""],
      ["ca40", ""],
      ["caa1", ""],
      ["cb40", ""],
      ["cba1", ""],
      ["cc40", ""],
      ["cca1", ""],
      ["cd40", ""],
      ["cda1", ""],
      ["ce40", ""],
      ["cea1", ""],
      ["cf40", ""],
      ["cfa1", ""],
      ["d040", ""],
      ["d0a1", ""],
      ["d140", ""],
      ["d1a1", ""],
      ["d240", ""],
      ["d2a1", ""],
      ["d340", ""],
      ["d3a1", ""],
      ["d440", ""],
      ["d4a1", ""],
      ["d540", ""],
      ["d5a1", ""],
      ["d640", ""],
      ["d6a1", ""],
      ["d740", ""],
      ["d7a1", ""],
      ["d840", ""],
      ["d8a1", ""],
      ["d940", ""],
      ["d9a1", ""],
      ["da40", ""],
      ["daa1", ""],
      ["db40", ""],
      ["dba1", ""],
      ["dc40", ""],
      ["dca1", ""],
      ["dd40", ""],
      ["dda1", ""],
      ["de40", ""],
      ["dea1", ""],
      ["df40", ""],
      ["dfa1", ""],
      ["e040", ""],
      ["e0a1", ""],
      ["e140", ""],
      ["e1a1", ""],
      ["e240", ""],
      ["e2a1", ""],
      ["e340", ""],
      ["e3a1", ""],
      ["e440", ""],
      ["e4a1", ""],
      ["e540", ""],
      ["e5a1", ""],
      ["e640", ""],
      ["e6a1", ""],
      ["e740", ""],
      ["e7a1", ""],
      ["e840", ""],
      ["e8a1", ""],
      ["e940", ""],
      ["e9a1", ""],
      ["ea40", ""],
      ["eaa1", ""],
      ["eb40", ""],
      ["eba1", ""],
      ["ec40", ""],
      ["eca1", ""],
      ["ed40", ""],
      ["eda1", ""],
      ["ee40", ""],
      ["eea1", ""],
      ["ef40", ""],
      ["efa1", ""],
      ["f040", ""],
      ["f0a1", ""],
      ["f140", ""],
      ["f1a1", ""],
      ["f240", ""],
      ["f2a1", ""],
      ["f340", ""],
      ["f3a1", ""],
      ["f440", ""],
      ["f4a1", ""],
      ["f540", ""],
      ["f5a1", ""],
      ["f640", ""],
      ["f6a1", ""],
      ["f740", ""],
      ["f7a1", ""],
      ["f840", ""],
      ["f8a1", ""],
      ["f940", ""],
      ["f9a1", ""]
    ];
  }
});

// node_modules/mariadb/node_modules/iconv-lite/encodings/tables/big5-added.json
var require_big5_added = __commonJS({
  "node_modules/mariadb/node_modules/iconv-lite/encodings/tables/big5-added.json"(exports, module) {
    module.exports = [
      ["8740", ""],
      ["8767", ""],
      ["87a1", ""],
      ["8840", "", 4, ""],
      ["88a1", ""],
      ["8940", ""],
      ["8943", ""],
      ["8946", ""],
      ["894c", ""],
      ["89a1", ""],
      ["89ab", ""],
      ["89b0", ""],
      ["89b5", ""],
      ["89c1", ""],
      ["89c5", ""],
      ["8a40", ""],
      ["8a43", ""],
      ["8a64", ""],
      ["8a76", ""],
      ["8aa1", ""],
      ["8aac", ""],
      ["8ab2", ""],
      ["8abb", ""],
      ["8ac9", ""],
      ["8ace", ""],
      ["8adf", ""],
      ["8af6", ""],
      ["8b40", ""],
      ["8b55", ""],
      ["8ba1", ""],
      ["8bde", ""],
      ["8c40", ""],
      ["8ca1", ""],
      ["8ca7", ""],
      ["8cc9", ""],
      ["8cce", ""],
      ["8ce6", ""],
      ["8d40", ""],
      ["8d42", ""],
      ["8da1", ""],
      ["8e40", ""],
      ["8ea1", ""],
      ["8f40", ""],
      ["8fa1", ""],
      ["9040", ""],
      ["90a1", ""],
      ["9140", ""],
      ["91a1", ""],
      ["9240", ""],
      ["92a1", ""],
      ["9340", ""],
      ["93a1", ""],
      ["9440", ""],
      ["94a1", ""],
      ["9540", ""],
      ["95a1", ""],
      ["9640", ""],
      ["96a1", ""],
      ["9740", ""],
      ["97a1", ""],
      ["9840", ""],
      ["98a1", ""],
      ["9940", ""],
      ["99a1", ""],
      ["9a40", ""],
      ["9aa1", ""],
      ["9b40", ""],
      ["9b62", ""],
      ["9ba1", ""],
      ["9c40", ""],
      ["9ca1", ""],
      ["9d40", ""],
      ["9da1", ""],
      ["9e40", ""],
      ["9ea1", ""],
      ["9ead", ""],
      ["9ec5", ""],
      ["9ef5", ""],
      ["9f40", ""],
      ["9f4f", ""],
      ["9fa1", ""],
      ["9fae", ""],
      ["9fb2", ""],
      ["9fc1", ""],
      ["9fc9", ""],
      ["9fdb", ""],
      ["9fe7", ""],
      ["9feb", ""],
      ["9ff0", ""],
      ["a040", ""],
      ["a055", ""],
      ["a058", ""],
      ["a05b", ""],
      ["a063", ""],
      ["a073", ""],
      ["a0a1", ""],
      ["a0a6", ""],
      ["a0ae", ""],
      ["a0b0", ""],
      ["a0d4", ""],
      ["a0e2", ""],
      ["a3c0", "", 31, ""],
      ["c6a1", "", 9, "", 9, "", 9, "", 23],
      ["c740", "", 58, ""],
      ["c7a1", "", 81, "", 5, "", 4],
      ["c840", "", 26, "", 25, ""],
      ["c8a1", ""],
      ["c8cd", ""],
      ["c8f5", ""],
      ["f9fe", ""],
      ["fa40", ""],
      ["faa1", ""],
      ["fb40", ""],
      ["fba1", ""],
      ["fc40", ""],
      ["fca1", ""],
      ["fd40", ""],
      ["fda1", ""],
      ["fe40", ""],
      ["fea1", ""]
    ];
  }
});

// node_modules/mariadb/node_modules/iconv-lite/encodings/dbcs-data.js
var require_dbcs_data = __commonJS({
  "node_modules/mariadb/node_modules/iconv-lite/encodings/dbcs-data.js"(exports, module) {
    "use strict";
    module.exports = {
      // == Japanese/ShiftJIS ====================================================
      // All japanese encodings are based on JIS X set of standards:
      // JIS X 0201 - Single-byte encoding of ASCII +  + Kana chars at 0xA1-0xDF.
      // JIS X 0208 - Main set of 6879 characters, placed in 94x94 plane, to be encoded by 2 bytes. 
      //              Has several variations in 1978, 1983, 1990 and 1997.
      // JIS X 0212 - Supplementary plane of 6067 chars in 94x94 plane. 1990. Effectively dead.
      // JIS X 0213 - Extension and modern replacement of 0208 and 0212. Total chars: 11233.
      //              2 planes, first is superset of 0208, second - revised 0212.
      //              Introduced in 2000, revised 2004. Some characters are in Unicode Plane 2 (0x2xxxx)
      // Byte encodings are:
      //  * Shift_JIS: Compatible with 0201, uses not defined chars in top half as lead bytes for double-byte
      //               encoding of 0208. Lead byte ranges: 0x81-0x9F, 0xE0-0xEF; Trail byte ranges: 0x40-0x7E, 0x80-0x9E, 0x9F-0xFC.
      //               Windows CP932 is a superset of Shift_JIS. Some companies added more chars, notably KDDI.
      //  * EUC-JP:    Up to 3 bytes per character. Used mostly on *nixes.
      //               0x00-0x7F       - lower part of 0201
      //               0x8E, 0xA1-0xDF - upper part of 0201
      //               (0xA1-0xFE)x2   - 0208 plane (94x94).
      //               0x8F, (0xA1-0xFE)x2 - 0212 plane (94x94).
      //  * JIS X 208: 7-bit, direct encoding of 0208. Byte ranges: 0x21-0x7E (94 values). Uncommon.
      //               Used as-is in ISO2022 family.
      //  * ISO2022-JP: Stateful encoding, with escape sequences to switch between ASCII, 
      //                0201-1976 Roman, 0208-1978, 0208-1983.
      //  * ISO2022-JP-1: Adds esc seq for 0212-1990.
      //  * ISO2022-JP-2: Adds esc seq for GB2313-1980, KSX1001-1992, ISO8859-1, ISO8859-7.
      //  * ISO2022-JP-3: Adds esc seq for 0201-1976 Kana set, 0213-2000 Planes 1, 2.
      //  * ISO2022-JP-2004: Adds 0213-2004 Plane 1.
      //
      // After JIS X 0213 appeared, Shift_JIS-2004, EUC-JISX0213 and ISO2022-JP-2004 followed, with just changing the planes.
      //
      // Overall, it seems that it's a mess :( http://www8.plala.or.jp/tkubota1/unicode-symbols-map2.html
      "shiftjis": {
        type: "_dbcs",
        table: function() {
          return require_shiftjis();
        },
        encodeAdd: { "": 92, "": 126 },
        encodeSkipVals: [{ from: 60736, to: 63808 }]
      },
      "csshiftjis": "shiftjis",
      "mskanji": "shiftjis",
      "sjis": "shiftjis",
      "windows31j": "shiftjis",
      "ms31j": "shiftjis",
      "xsjis": "shiftjis",
      "windows932": "shiftjis",
      "ms932": "shiftjis",
      "932": "shiftjis",
      "cp932": "shiftjis",
      "eucjp": {
        type: "_dbcs",
        table: function() {
          return require_eucjp();
        },
        encodeAdd: { "": 92, "": 126 }
      },
      // TODO: KDDI extension to Shift_JIS
      // TODO: IBM CCSID 942 = CP932, but F0-F9 custom chars and other char changes.
      // TODO: IBM CCSID 943 = Shift_JIS = CP932 with original Shift_JIS lower 128 chars.
      // == Chinese/GBK ==========================================================
      // http://en.wikipedia.org/wiki/GBK
      // We mostly implement W3C recommendation: https://www.w3.org/TR/encoding/#gbk-encoder
      // Oldest GB2312 (1981, ~7600 chars) is a subset of CP936
      "gb2312": "cp936",
      "gb231280": "cp936",
      "gb23121980": "cp936",
      "csgb2312": "cp936",
      "csiso58gb231280": "cp936",
      "euccn": "cp936",
      // Microsoft's CP936 is a subset and approximation of GBK.
      "windows936": "cp936",
      "ms936": "cp936",
      "936": "cp936",
      "cp936": {
        type: "_dbcs",
        table: function() {
          return require_cp936();
        }
      },
      // GBK (~22000 chars) is an extension of CP936 that added user-mapped chars and some other.
      "gbk": {
        type: "_dbcs",
        table: function() {
          return require_cp936().concat(require_gbk_added());
        }
      },
      "xgbk": "gbk",
      "isoir58": "gbk",
      // GB18030 is an algorithmic extension of GBK.
      // Main source: https://www.w3.org/TR/encoding/#gbk-encoder
      // http://icu-project.org/docs/papers/gb18030.html
      // http://source.icu-project.org/repos/icu/data/trunk/charset/data/xml/gb-18030-2000.xml
      // http://www.khngai.com/chinese/charmap/tblgbk.php?page=0
      "gb18030": {
        type: "_dbcs",
        table: function() {
          return require_cp936().concat(require_gbk_added());
        },
        gb18030: function() {
          return require_gb18030_ranges();
        },
        encodeSkipVals: [128],
        encodeAdd: { "": 41699 }
      },
      "chinese": "gb18030",
      // == Korean ===============================================================
      // EUC-KR, KS_C_5601 and KS X 1001 are exactly the same.
      "windows949": "cp949",
      "ms949": "cp949",
      "949": "cp949",
      "cp949": {
        type: "_dbcs",
        table: function() {
          return require_cp949();
        }
      },
      "cseuckr": "cp949",
      "csksc56011987": "cp949",
      "euckr": "cp949",
      "isoir149": "cp949",
      "korean": "cp949",
      "ksc56011987": "cp949",
      "ksc56011989": "cp949",
      "ksc5601": "cp949",
      // == Big5/Taiwan/Hong Kong ================================================
      // There are lots of tables for Big5 and cp950. Please see the following links for history:
      // http://moztw.org/docs/big5/  http://www.haible.de/bruno/charsets/conversion-tables/Big5.html
      // Variations, in roughly number of defined chars:
      //  * Windows CP 950: Microsoft variant of Big5. Canonical: http://www.unicode.org/Public/MAPPINGS/VENDORS/MICSFT/WINDOWS/CP950.TXT
      //  * Windows CP 951: Microsoft variant of Big5-HKSCS-2001. Seems to be never public. http://me.abelcheung.org/articles/research/what-is-cp951/
      //  * Big5-2003 (Taiwan standard) almost superset of cp950.
      //  * Unicode-at-on (UAO) / Mozilla 1.8. Falling out of use on the Web. Not supported by other browsers.
      //  * Big5-HKSCS (-2001, -2004, -2008). Hong Kong standard. 
      //    many unicode code points moved from PUA to Supplementary plane (U+2XXXX) over the years.
      //    Plus, it has 4 combining sequences.
      //    Seems that Mozilla refused to support it for 10 yrs. https://bugzilla.mozilla.org/show_bug.cgi?id=162431 https://bugzilla.mozilla.org/show_bug.cgi?id=310299
      //    because big5-hkscs is the only encoding to include astral characters in non-algorithmic way.
      //    Implementations are not consistent within browsers; sometimes labeled as just big5.
      //    MS Internet Explorer switches from big5 to big5-hkscs when a patch applied.
      //    Great discussion & recap of what's going on https://bugzilla.mozilla.org/show_bug.cgi?id=912470#c31
      //    In the encoder, it might make sense to support encoding old PUA mappings to Big5 bytes seq-s.
      //    Official spec: http://www.ogcio.gov.hk/en/business/tech_promotion/ccli/terms/doc/2003cmp_2008.txt
      //                   http://www.ogcio.gov.hk/tc/business/tech_promotion/ccli/terms/doc/hkscs-2008-big5-iso.txt
      // 
      // Current understanding of how to deal with Big5(-HKSCS) is in the Encoding Standard, http://encoding.spec.whatwg.org/#big5-encoder
      // Unicode mapping (http://www.unicode.org/Public/MAPPINGS/OBSOLETE/EASTASIA/OTHER/BIG5.TXT) is said to be wrong.
      "windows950": "cp950",
      "ms950": "cp950",
      "950": "cp950",
      "cp950": {
        type: "_dbcs",
        table: function() {
          return require_cp950();
        }
      },
      // Big5 has many variations and is an extension of cp950. We use Encoding Standard's as a consensus.
      "big5": "big5hkscs",
      "big5hkscs": {
        type: "_dbcs",
        table: function() {
          return require_cp950().concat(require_big5_added());
        },
        encodeSkipVals: [
          // Although Encoding Standard says we should avoid encoding to HKSCS area (See Step 1 of
          // https://encoding.spec.whatwg.org/#index-big5-pointer), we still do it to increase compatibility with ICU.
          // But if a single unicode point can be encoded both as HKSCS and regular Big5, we prefer the latter.
          36457,
          36463,
          36478,
          36523,
          36532,
          36557,
          36560,
          36695,
          36713,
          36718,
          36811,
          36862,
          36973,
          36986,
          37060,
          37084,
          37105,
          37311,
          37551,
          37552,
          37553,
          37554,
          37585,
          37959,
          38090,
          38361,
          38652,
          39285,
          39798,
          39800,
          39803,
          39878,
          39902,
          39916,
          39926,
          40002,
          40019,
          40034,
          40040,
          40043,
          40055,
          40124,
          40125,
          40144,
          40279,
          40282,
          40388,
          40431,
          40443,
          40617,
          40687,
          40701,
          40800,
          40907,
          41079,
          41180,
          41183,
          36812,
          37576,
          38468,
          38637,
          // Step 2 of https://encoding.spec.whatwg.org/#index-big5-pointer: Use last pointer for U+2550, U+255E, U+2561, U+256A, U+5341, or U+5345
          41636,
          41637,
          41639,
          41638,
          41676,
          41678
        ]
      },
      "cnbig5": "big5hkscs",
      "csbig5": "big5hkscs",
      "xxbig5": "big5hkscs"
    };
  }
});

// node_modules/mariadb/node_modules/iconv-lite/encodings/index.js
var require_encodings = __commonJS({
  "node_modules/mariadb/node_modules/iconv-lite/encodings/index.js"(exports, module) {
    "use strict";
    var modules = [
      require_internal(),
      require_utf32(),
      require_utf16(),
      require_utf7(),
      require_sbcs_codec(),
      require_sbcs_data(),
      require_sbcs_data_generated(),
      require_dbcs_codec(),
      require_dbcs_data()
    ];
    for (i = 0; i < modules.length; i++) {
      module = modules[i];
      for (enc in module)
        if (Object.prototype.hasOwnProperty.call(module, enc))
          exports[enc] = module[enc];
    }
    var module;
    var enc;
    var i;
  }
});

// node_modules/mariadb/node_modules/iconv-lite/lib/streams.js
var require_streams = __commonJS({
  "node_modules/mariadb/node_modules/iconv-lite/lib/streams.js"(exports, module) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    module.exports = function(stream_module) {
      var Transform = stream_module.Transform;
      function IconvLiteEncoderStream(conv, options) {
        this.conv = conv;
        options = options || {};
        options.decodeStrings = false;
        Transform.call(this, options);
      }
      IconvLiteEncoderStream.prototype = Object.create(Transform.prototype, {
        constructor: { value: IconvLiteEncoderStream }
      });
      IconvLiteEncoderStream.prototype._transform = function(chunk, encoding, done) {
        if (typeof chunk != "string")
          return done(new Error("Iconv encoding stream needs strings as its input."));
        try {
          var res = this.conv.write(chunk);
          if (res && res.length) this.push(res);
          done();
        } catch (e) {
          done(e);
        }
      };
      IconvLiteEncoderStream.prototype._flush = function(done) {
        try {
          var res = this.conv.end();
          if (res && res.length) this.push(res);
          done();
        } catch (e) {
          done(e);
        }
      };
      IconvLiteEncoderStream.prototype.collect = function(cb) {
        var chunks = [];
        this.on("error", cb);
        this.on("data", function(chunk) {
          chunks.push(chunk);
        });
        this.on("end", function() {
          cb(null, Buffer2.concat(chunks));
        });
        return this;
      };
      function IconvLiteDecoderStream(conv, options) {
        this.conv = conv;
        options = options || {};
        options.encoding = this.encoding = "utf8";
        Transform.call(this, options);
      }
      IconvLiteDecoderStream.prototype = Object.create(Transform.prototype, {
        constructor: { value: IconvLiteDecoderStream }
      });
      IconvLiteDecoderStream.prototype._transform = function(chunk, encoding, done) {
        if (!Buffer2.isBuffer(chunk) && !(chunk instanceof Uint8Array))
          return done(new Error("Iconv decoding stream needs buffers as its input."));
        try {
          var res = this.conv.write(chunk);
          if (res && res.length) this.push(res, this.encoding);
          done();
        } catch (e) {
          done(e);
        }
      };
      IconvLiteDecoderStream.prototype._flush = function(done) {
        try {
          var res = this.conv.end();
          if (res && res.length) this.push(res, this.encoding);
          done();
        } catch (e) {
          done(e);
        }
      };
      IconvLiteDecoderStream.prototype.collect = function(cb) {
        var res = "";
        this.on("error", cb);
        this.on("data", function(chunk) {
          res += chunk;
        });
        this.on("end", function() {
          cb(null, res);
        });
        return this;
      };
      return {
        IconvLiteEncoderStream,
        IconvLiteDecoderStream
      };
    };
  }
});

// node_modules/mariadb/node_modules/iconv-lite/lib/index.js
var require_lib = __commonJS({
  "node_modules/mariadb/node_modules/iconv-lite/lib/index.js"(exports, module) {
    "use strict";
    var Buffer2 = require_safer().Buffer;
    var bomHandling = require_bom_handling();
    var iconv = module.exports;
    iconv.encodings = null;
    iconv.defaultCharUnicode = "";
    iconv.defaultCharSingleByte = "?";
    iconv.encode = function encode(str, encoding, options) {
      str = "" + (str || "");
      var encoder = iconv.getEncoder(encoding, options);
      var res = encoder.write(str);
      var trail = encoder.end();
      return trail && trail.length > 0 ? Buffer2.concat([res, trail]) : res;
    };
    iconv.decode = function decode(buf, encoding, options) {
      if (typeof buf === "string") {
        if (!iconv.skipDecodeWarning) {
          console.error("Iconv-lite warning: decode()-ing strings is deprecated. Refer to https://github.com/ashtuchkin/iconv-lite/wiki/Use-Buffers-when-decoding");
          iconv.skipDecodeWarning = true;
        }
        buf = Buffer2.from("" + (buf || ""), "binary");
      }
      var decoder = iconv.getDecoder(encoding, options);
      var res = decoder.write(buf);
      var trail = decoder.end();
      return trail ? res + trail : res;
    };
    iconv.encodingExists = function encodingExists(enc) {
      try {
        iconv.getCodec(enc);
        return true;
      } catch (e) {
        return false;
      }
    };
    iconv.toEncoding = iconv.encode;
    iconv.fromEncoding = iconv.decode;
    iconv._codecDataCache = {};
    iconv.getCodec = function getCodec(encoding) {
      if (!iconv.encodings)
        iconv.encodings = require_encodings();
      var enc = iconv._canonicalizeEncoding(encoding);
      var codecOptions = {};
      while (true) {
        var codec = iconv._codecDataCache[enc];
        if (codec)
          return codec;
        var codecDef = iconv.encodings[enc];
        switch (typeof codecDef) {
          case "string":
            enc = codecDef;
            break;
          case "object":
            for (var key in codecDef)
              codecOptions[key] = codecDef[key];
            if (!codecOptions.encodingName)
              codecOptions.encodingName = enc;
            enc = codecDef.type;
            break;
          case "function":
            if (!codecOptions.encodingName)
              codecOptions.encodingName = enc;
            codec = new codecDef(codecOptions, iconv);
            iconv._codecDataCache[codecOptions.encodingName] = codec;
            return codec;
          default:
            throw new Error("Encoding not recognized: '" + encoding + "' (searched as: '" + enc + "')");
        }
      }
    };
    iconv._canonicalizeEncoding = function(encoding) {
      return ("" + encoding).toLowerCase().replace(/:\d{4}$|[^0-9a-z]/g, "");
    };
    iconv.getEncoder = function getEncoder(encoding, options) {
      var codec = iconv.getCodec(encoding), encoder = new codec.encoder(options, codec);
      if (codec.bomAware && options && options.addBOM)
        encoder = new bomHandling.PrependBOM(encoder, options);
      return encoder;
    };
    iconv.getDecoder = function getDecoder(encoding, options) {
      var codec = iconv.getCodec(encoding), decoder = new codec.decoder(options, codec);
      if (codec.bomAware && !(options && options.stripBOM === false))
        decoder = new bomHandling.StripBOM(decoder, options);
      return decoder;
    };
    iconv.enableStreamingAPI = function enableStreamingAPI(stream_module2) {
      if (iconv.supportsStreams)
        return;
      var streams = require_streams()(stream_module2);
      iconv.IconvLiteEncoderStream = streams.IconvLiteEncoderStream;
      iconv.IconvLiteDecoderStream = streams.IconvLiteDecoderStream;
      iconv.encodeStream = function encodeStream(encoding, options) {
        return new iconv.IconvLiteEncoderStream(iconv.getEncoder(encoding, options), options);
      };
      iconv.decodeStream = function decodeStream(encoding, options) {
        return new iconv.IconvLiteDecoderStream(iconv.getDecoder(encoding, options), options);
      };
      iconv.supportsStreams = true;
    };
    var stream_module;
    try {
      stream_module = require_stream();
    } catch (e) {
    }
    if (stream_module && stream_module.Transform) {
      iconv.enableStreamingAPI(stream_module);
    } else {
      iconv.encodeStream = iconv.decodeStream = function() {
        throw new Error("iconv-lite Streaming API is not enabled. Use iconv.enableStreamingAPI(require('stream')); to enable it.");
      };
    }
    if (false) {
      console.error("iconv-lite warning: js files use non-utf8 encoding. See https://github.com/ashtuchkin/iconv-lite/wiki/Javascript-source-file-encodings for more info.");
    }
  }
});

// node_modules/mariadb/lib/io/packet-node-iconv.js
var require_packet_node_iconv = __commonJS({
  "node_modules/mariadb/lib/io/packet-node-iconv.js"(exports, module) {
    "use strict";
    var Packet = require_packet();
    var Iconv = require_lib();
    var PacketIconvEncoded = class _PacketIconvEncoded extends Packet {
      constructor(encoding) {
        super();
        this.encoding = encoding;
      }
      readStringLengthEncoded() {
        const len = this.readUnsignedLength();
        if (len === null) return null;
        this.pos += len;
        return Iconv.decode(this.buf.subarray(this.pos - len, this.pos), this.encoding);
      }
      static readString(encoding, buf, beg, len) {
        return Iconv.decode(buf.subarray(beg, beg + len), encoding);
      }
      subPacketLengthEncoded(len) {
        this.skip(len);
        return new _PacketIconvEncoded(this.encoding).update(this.buf, this.pos - len, this.pos);
      }
      readStringRemaining() {
        const str = Iconv.decode(this.buf.subarray(this.pos, this.end), this.encoding);
        this.pos = this.end;
        return str;
      }
    };
    module.exports = PacketIconvEncoded;
  }
});

// node_modules/mariadb/lib/const/collations.js
var require_collations = __commonJS({
  "node_modules/mariadb/lib/const/collations.js"(exports, module) {
    "use strict";
    var charsets = [];
    var defaultCharsets = [];
    var Collation = class {
      constructor(index, name, charset, maxLength) {
        this.index = index;
        this.name = name;
        this.charset = charset;
        this.maxLength = maxLength;
      }
      static fromCharset(charset) {
        return defaultCharsets[charset === "utf8mb3" ? "utf8" : charset];
      }
      static fromIndex(index) {
        if (index >= charsets.length) return void 0;
        return charsets[index];
      }
      static fromName(name) {
        for (let i = 0; i < charsets.length; i++) {
          let collation = charsets[i];
          if (collation && collation.name === name) {
            return collation;
          }
        }
        const nameWithMb4 = name.replace("UTF8_", "UTF8MB4_");
        for (let i = 0; i < charsets.length; i++) {
          let collation = charsets[i];
          if (collation && collation.name === nameWithMb4) {
            return collation;
          }
        }
        return void 0;
      }
    };
    charsets[1] = new Collation(1, "BIG5_CHINESE_CI", "big5", 2);
    charsets[2] = new Collation(2, "LATIN2_CZECH_CS", "latin2", 1);
    charsets[3] = new Collation(3, "DEC8_SWEDISH_CI", "dec8", 1);
    charsets[4] = new Collation(4, "CP850_GENERAL_CI", "cp850", 1);
    charsets[5] = new Collation(5, "LATIN1_GERMAN1_CI", "latin1", 1);
    charsets[6] = new Collation(6, "HP8_ENGLISH_CI", "hp8", 1);
    charsets[7] = new Collation(7, "KOI8R_GENERAL_CI", "koi8r", 1);
    charsets[8] = new Collation(8, "LATIN1_SWEDISH_CI", "latin1", 1);
    charsets[9] = new Collation(9, "LATIN2_GENERAL_CI", "latin2", 1);
    charsets[10] = new Collation(10, "SWE7_SWEDISH_CI", "swe7", 1);
    charsets[11] = new Collation(11, "ASCII_GENERAL_CI", "ascii", 1);
    charsets[12] = new Collation(12, "UJIS_JAPANESE_CI", "ujis", 3);
    charsets[13] = new Collation(13, "SJIS_JAPANESE_CI", "sjis", 2);
    charsets[14] = new Collation(14, "CP1251_BULGARIAN_CI", "cp1251", 1);
    charsets[15] = new Collation(15, "LATIN1_DANISH_CI", "latin1", 1);
    charsets[16] = new Collation(16, "HEBREW_GENERAL_CI", "hebrew", 1);
    charsets[18] = new Collation(18, "TIS620_THAI_CI", "tis620", 1);
    charsets[19] = new Collation(19, "EUCKR_KOREAN_CI", "euckr", 2);
    charsets[20] = new Collation(20, "LATIN7_ESTONIAN_CS", "latin7", 1);
    charsets[21] = new Collation(21, "LATIN2_HUNGARIAN_CI", "latin2", 1);
    charsets[22] = new Collation(22, "KOI8U_GENERAL_CI", "koi8u", 1);
    charsets[23] = new Collation(23, "CP1251_UKRAINIAN_CI", "cp1251", 1);
    charsets[24] = new Collation(24, "GB2312_CHINESE_CI", "gb2312", 2);
    charsets[25] = new Collation(25, "GREEK_GENERAL_CI", "greek", 1);
    charsets[26] = new Collation(26, "CP1250_GENERAL_CI", "cp1250", 1);
    charsets[27] = new Collation(27, "LATIN2_CROATIAN_CI", "latin2", 1);
    charsets[28] = new Collation(28, "GBK_CHINESE_CI", "gbk", 2);
    charsets[29] = new Collation(29, "CP1257_LITHUANIAN_CI", "cp1257", 1);
    charsets[30] = new Collation(30, "LATIN5_TURKISH_CI", "latin5", 1);
    charsets[31] = new Collation(31, "LATIN1_GERMAN2_CI", "latin1", 1);
    charsets[32] = new Collation(32, "ARMSCII8_GENERAL_CI", "armscii8", 1);
    charsets[33] = new Collation(33, "UTF8MB3_GENERAL_CI", "utf8", 3);
    charsets[34] = new Collation(34, "CP1250_CZECH_CS", "cp1250", 1);
    charsets[35] = new Collation(35, "UCS2_GENERAL_CI", "ucs2", 2);
    charsets[36] = new Collation(36, "CP866_GENERAL_CI", "cp866", 1);
    charsets[37] = new Collation(37, "KEYBCS2_GENERAL_CI", "keybcs2", 1);
    charsets[38] = new Collation(38, "MACCE_GENERAL_CI", "macce", 1);
    charsets[39] = new Collation(39, "MACROMAN_GENERAL_CI", "macroman", 1);
    charsets[40] = new Collation(40, "CP852_GENERAL_CI", "cp852", 1);
    charsets[41] = new Collation(41, "LATIN7_GENERAL_CI", "latin7", 1);
    charsets[42] = new Collation(42, "LATIN7_GENERAL_CS", "latin7", 1);
    charsets[43] = new Collation(43, "MACCE_BIN", "macce", 1);
    charsets[44] = new Collation(44, "CP1250_CROATIAN_CI", "cp1250", 1);
    charsets[45] = new Collation(45, "UTF8MB4_GENERAL_CI", "utf8", 4);
    charsets[46] = new Collation(46, "UTF8MB4_BIN", "utf8", 4);
    charsets[47] = new Collation(47, "LATIN1_BIN", "latin1", 1);
    charsets[48] = new Collation(48, "LATIN1_GENERAL_CI", "latin1", 1);
    charsets[49] = new Collation(49, "LATIN1_GENERAL_CS", "latin1", 1);
    charsets[50] = new Collation(50, "CP1251_BIN", "cp1251", 1);
    charsets[51] = new Collation(51, "CP1251_GENERAL_CI", "cp1251", 1);
    charsets[52] = new Collation(52, "CP1251_GENERAL_CS", "cp1251", 1);
    charsets[53] = new Collation(53, "MACROMAN_BIN", "macroman", 1);
    charsets[54] = new Collation(54, "UTF16_GENERAL_CI", "utf16", 4);
    charsets[55] = new Collation(55, "UTF16_BIN", "utf16", 4);
    charsets[56] = new Collation(56, "UTF16LE_GENERAL_CI", "utf16le", 4);
    charsets[57] = new Collation(57, "CP1256_GENERAL_CI", "cp1256", 1);
    charsets[58] = new Collation(58, "CP1257_BIN", "cp1257", 1);
    charsets[59] = new Collation(59, "CP1257_GENERAL_CI", "cp1257", 1);
    charsets[60] = new Collation(60, "UTF32_GENERAL_CI", "utf32", 4);
    charsets[61] = new Collation(61, "UTF32_BIN", "utf32", 4);
    charsets[62] = new Collation(62, "UTF16LE_BIN", "utf16le", 4);
    charsets[63] = new Collation(63, "BINARY", "binary", 1);
    charsets[64] = new Collation(64, "ARMSCII8_BIN", "armscii8", 1);
    charsets[65] = new Collation(65, "ASCII_BIN", "ascii", 1);
    charsets[66] = new Collation(66, "CP1250_BIN", "cp1250", 1);
    charsets[67] = new Collation(67, "CP1256_BIN", "cp1256", 1);
    charsets[68] = new Collation(68, "CP866_BIN", "cp866", 1);
    charsets[69] = new Collation(69, "DEC8_BIN", "dec8", 1);
    charsets[70] = new Collation(70, "GREEK_BIN", "greek", 1);
    charsets[71] = new Collation(71, "HEBREW_BIN", "hebrew", 1);
    charsets[72] = new Collation(72, "HP8_BIN", "hp8", 1);
    charsets[73] = new Collation(73, "KEYBCS2_BIN", "keybcs2", 1);
    charsets[74] = new Collation(74, "KOI8R_BIN", "koi8r", 1);
    charsets[75] = new Collation(75, "KOI8U_BIN", "koi8u", 1);
    charsets[76] = new Collation(76, "UTF8_TOLOWER_CI", "utf8", 3);
    charsets[77] = new Collation(77, "LATIN2_BIN", "latin2", 1);
    charsets[78] = new Collation(78, "LATIN5_BIN", "latin5", 1);
    charsets[79] = new Collation(79, "LATIN7_BIN", "latin7", 1);
    charsets[80] = new Collation(80, "CP850_BIN", "cp850", 1);
    charsets[81] = new Collation(81, "CP852_BIN", "cp852", 1);
    charsets[82] = new Collation(82, "SWE7_BIN", "swe7", 1);
    charsets[83] = new Collation(83, "UTF8MB3_BIN", "utf8", 3);
    charsets[84] = new Collation(84, "BIG5_BIN", "big5", 2);
    charsets[85] = new Collation(85, "EUCKR_BIN", "euckr", 2);
    charsets[86] = new Collation(86, "GB2312_BIN", "gb2312", 2);
    charsets[87] = new Collation(87, "GBK_BIN", "gbk", 2);
    charsets[88] = new Collation(88, "SJIS_BIN", "sjis", 2);
    charsets[89] = new Collation(89, "TIS620_BIN", "tis620", 1);
    charsets[90] = new Collation(90, "UCS2_BIN", "ucs2", 2);
    charsets[91] = new Collation(91, "UJIS_BIN", "ujis", 3);
    charsets[92] = new Collation(92, "GEOSTD8_GENERAL_CI", "geostd8", 1);
    charsets[93] = new Collation(93, "GEOSTD8_BIN", "geostd8", 1);
    charsets[94] = new Collation(94, "LATIN1_SPANISH_CI", "latin1", 1);
    charsets[95] = new Collation(95, "CP932_JAPANESE_CI", "cp932", 2);
    charsets[96] = new Collation(96, "CP932_BIN", "cp932", 2);
    charsets[97] = new Collation(97, "EUCJPMS_JAPANESE_CI", "eucjpms", 3);
    charsets[98] = new Collation(98, "EUCJPMS_BIN", "eucjpms", 3);
    charsets[99] = new Collation(99, "CP1250_POLISH_CI", "cp1250", 1);
    charsets[101] = new Collation(101, "UTF16_UNICODE_CI", "utf16", 4);
    charsets[102] = new Collation(102, "UTF16_ICELANDIC_CI", "utf16", 4);
    charsets[103] = new Collation(103, "UTF16_LATVIAN_CI", "utf16", 4);
    charsets[104] = new Collation(104, "UTF16_ROMANIAN_CI", "utf16", 4);
    charsets[105] = new Collation(105, "UTF16_SLOVENIAN_CI", "utf16", 4);
    charsets[106] = new Collation(106, "UTF16_POLISH_CI", "utf16", 4);
    charsets[107] = new Collation(107, "UTF16_ESTONIAN_CI", "utf16", 4);
    charsets[108] = new Collation(108, "UTF16_SPANISH_CI", "utf16", 4);
    charsets[109] = new Collation(109, "UTF16_SWEDISH_CI", "utf16", 4);
    charsets[110] = new Collation(110, "UTF16_TURKISH_CI", "utf16", 4);
    charsets[111] = new Collation(111, "UTF16_CZECH_CI", "utf16", 4);
    charsets[112] = new Collation(112, "UTF16_DANISH_CI", "utf16", 4);
    charsets[113] = new Collation(113, "UTF16_LITHUANIAN_CI", "utf16", 4);
    charsets[114] = new Collation(114, "UTF16_SLOVAK_CI", "utf16", 4);
    charsets[115] = new Collation(115, "UTF16_SPANISH2_CI", "utf16", 4);
    charsets[116] = new Collation(116, "UTF16_ROMAN_CI", "utf16", 4);
    charsets[117] = new Collation(117, "UTF16_PERSIAN_CI", "utf16", 4);
    charsets[118] = new Collation(118, "UTF16_ESPERANTO_CI", "utf16", 4);
    charsets[119] = new Collation(119, "UTF16_HUNGARIAN_CI", "utf16", 4);
    charsets[120] = new Collation(120, "UTF16_SINHALA_CI", "utf16", 4);
    charsets[121] = new Collation(121, "UTF16_GERMAN2_CI", "utf16", 4);
    charsets[122] = new Collation(122, "UTF16_CROATIAN_MYSQL561_CI", "utf16", 4);
    charsets[123] = new Collation(123, "UTF16_UNICODE_520_CI", "utf16", 4);
    charsets[124] = new Collation(124, "UTF16_VIETNAMESE_CI", "utf16", 4);
    charsets[128] = new Collation(128, "UCS2_UNICODE_CI", "ucs2", 2);
    charsets[129] = new Collation(129, "UCS2_ICELANDIC_CI", "ucs2", 2);
    charsets[130] = new Collation(130, "UCS2_LATVIAN_CI", "ucs2", 2);
    charsets[131] = new Collation(131, "UCS2_ROMANIAN_CI", "ucs2", 2);
    charsets[132] = new Collation(132, "UCS2_SLOVENIAN_CI", "ucs2", 2);
    charsets[133] = new Collation(133, "UCS2_POLISH_CI", "ucs2", 2);
    charsets[134] = new Collation(134, "UCS2_ESTONIAN_CI", "ucs2", 2);
    charsets[135] = new Collation(135, "UCS2_SPANISH_CI", "ucs2", 2);
    charsets[136] = new Collation(136, "UCS2_SWEDISH_CI", "ucs2", 2);
    charsets[137] = new Collation(137, "UCS2_TURKISH_CI", "ucs2", 2);
    charsets[138] = new Collation(138, "UCS2_CZECH_CI", "ucs2", 2);
    charsets[139] = new Collation(139, "UCS2_DANISH_CI", "ucs2", 2);
    charsets[140] = new Collation(140, "UCS2_LITHUANIAN_CI", "ucs2", 2);
    charsets[141] = new Collation(141, "UCS2_SLOVAK_CI", "ucs2", 2);
    charsets[142] = new Collation(142, "UCS2_SPANISH2_CI", "ucs2", 2);
    charsets[143] = new Collation(143, "UCS2_ROMAN_CI", "ucs2", 2);
    charsets[144] = new Collation(144, "UCS2_PERSIAN_CI", "ucs2", 2);
    charsets[145] = new Collation(145, "UCS2_ESPERANTO_CI", "ucs2", 2);
    charsets[146] = new Collation(146, "UCS2_HUNGARIAN_CI", "ucs2", 2);
    charsets[147] = new Collation(147, "UCS2_SINHALA_CI", "ucs2", 2);
    charsets[148] = new Collation(148, "UCS2_GERMAN2_CI", "ucs2", 2);
    charsets[149] = new Collation(149, "UCS2_CROATIAN_MYSQL561_CI", "ucs2", 2);
    charsets[150] = new Collation(150, "UCS2_UNICODE_520_CI", "ucs2", 2);
    charsets[151] = new Collation(151, "UCS2_VIETNAMESE_CI", "ucs2", 2);
    charsets[159] = new Collation(159, "UCS2_GENERAL_MYSQL500_CI", "ucs2", 2);
    charsets[160] = new Collation(160, "UTF32_UNICODE_CI", "utf32", 4);
    charsets[161] = new Collation(161, "UTF32_ICELANDIC_CI", "utf32", 4);
    charsets[162] = new Collation(162, "UTF32_LATVIAN_CI", "utf32", 4);
    charsets[163] = new Collation(163, "UTF32_ROMANIAN_CI", "utf32", 4);
    charsets[164] = new Collation(164, "UTF32_SLOVENIAN_CI", "utf32", 4);
    charsets[165] = new Collation(165, "UTF32_POLISH_CI", "utf32", 4);
    charsets[166] = new Collation(166, "UTF32_ESTONIAN_CI", "utf32", 4);
    charsets[167] = new Collation(167, "UTF32_SPANISH_CI", "utf32", 4);
    charsets[168] = new Collation(168, "UTF32_SWEDISH_CI", "utf32", 4);
    charsets[169] = new Collation(169, "UTF32_TURKISH_CI", "utf32", 4);
    charsets[170] = new Collation(170, "UTF32_CZECH_CI", "utf32", 4);
    charsets[171] = new Collation(171, "UTF32_DANISH_CI", "utf32", 4);
    charsets[172] = new Collation(172, "UTF32_LITHUANIAN_CI", "utf32", 4);
    charsets[173] = new Collation(173, "UTF32_SLOVAK_CI", "utf32", 4);
    charsets[174] = new Collation(174, "UTF32_SPANISH2_CI", "utf32", 4);
    charsets[175] = new Collation(175, "UTF32_ROMAN_CI", "utf32", 4);
    charsets[176] = new Collation(176, "UTF32_PERSIAN_CI", "utf32", 4);
    charsets[177] = new Collation(177, "UTF32_ESPERANTO_CI", "utf32", 4);
    charsets[178] = new Collation(178, "UTF32_HUNGARIAN_CI", "utf32", 4);
    charsets[179] = new Collation(179, "UTF32_SINHALA_CI", "utf32", 4);
    charsets[180] = new Collation(180, "UTF32_GERMAN2_CI", "utf32", 4);
    charsets[181] = new Collation(181, "UTF32_CROATIAN_MYSQL561_CI", "utf32", 4);
    charsets[182] = new Collation(182, "UTF32_UNICODE_520_CI", "utf32", 4);
    charsets[183] = new Collation(183, "UTF32_VIETNAMESE_CI", "utf32", 4);
    charsets[192] = new Collation(192, "UTF8MB3_UNICODE_CI", "utf8", 3);
    charsets[193] = new Collation(193, "UTF8MB3_ICELANDIC_CI", "utf8", 3);
    charsets[194] = new Collation(194, "UTF8MB3_LATVIAN_CI", "utf8", 3);
    charsets[195] = new Collation(195, "UTF8MB3_ROMANIAN_CI", "utf8", 3);
    charsets[196] = new Collation(196, "UTF8MB3_SLOVENIAN_CI", "utf8", 3);
    charsets[197] = new Collation(197, "UTF8MB3_POLISH_CI", "utf8", 3);
    charsets[198] = new Collation(198, "UTF8MB3_ESTONIAN_CI", "utf8", 3);
    charsets[199] = new Collation(199, "UTF8MB3_SPANISH_CI", "utf8", 3);
    charsets[200] = new Collation(200, "UTF8MB3_SWEDISH_CI", "utf8", 3);
    charsets[201] = new Collation(201, "UTF8MB3_TURKISH_CI", "utf8", 3);
    charsets[202] = new Collation(202, "UTF8MB3_CZECH_CI", "utf8", 3);
    charsets[203] = new Collation(203, "UTF8MB3_DANISH_CI", "utf8", 3);
    charsets[204] = new Collation(204, "UTF8MB3_LITHUANIAN_CI", "utf8", 3);
    charsets[205] = new Collation(205, "UTF8MB3_SLOVAK_CI", "utf8", 3);
    charsets[206] = new Collation(206, "UTF8MB3_SPANISH2_CI", "utf8", 3);
    charsets[207] = new Collation(207, "UTF8MB3_ROMAN_CI", "utf8", 3);
    charsets[208] = new Collation(208, "UTF8MB3_PERSIAN_CI", "utf8", 3);
    charsets[209] = new Collation(209, "UTF8MB3_ESPERANTO_CI", "utf8", 3);
    charsets[210] = new Collation(210, "UTF8MB3_HUNGARIAN_CI", "utf8", 3);
    charsets[211] = new Collation(211, "UTF8MB3_SINHALA_CI", "utf8", 3);
    charsets[212] = new Collation(212, "UTF8MB3_GERMAN2_CI", "utf8", 3);
    charsets[213] = new Collation(213, "UTF8MB3_CROATIAN_MYSQL561_CI", "utf8", 3);
    charsets[214] = new Collation(214, "UTF8MB3_UNICODE_520_CI", "utf8", 3);
    charsets[215] = new Collation(215, "UTF8MB3_VIETNAMESE_CI", "utf8", 3);
    charsets[223] = new Collation(223, "UTF8MB3_GENERAL_MYSQL500_CI", "utf8", 3);
    charsets[224] = new Collation(224, "UTF8MB4_UNICODE_CI", "utf8", 4);
    charsets[225] = new Collation(225, "UTF8MB4_ICELANDIC_CI", "utf8", 4);
    charsets[226] = new Collation(226, "UTF8MB4_LATVIAN_CI", "utf8", 4);
    charsets[227] = new Collation(227, "UTF8MB4_ROMANIAN_CI", "utf8", 4);
    charsets[228] = new Collation(228, "UTF8MB4_SLOVENIAN_CI", "utf8", 4);
    charsets[229] = new Collation(229, "UTF8MB4_POLISH_CI", "utf8", 4);
    charsets[230] = new Collation(230, "UTF8MB4_ESTONIAN_CI", "utf8", 4);
    charsets[231] = new Collation(231, "UTF8MB4_SPANISH_CI", "utf8", 4);
    charsets[232] = new Collation(232, "UTF8MB4_SWEDISH_CI", "utf8", 4);
    charsets[233] = new Collation(233, "UTF8MB4_TURKISH_CI", "utf8", 4);
    charsets[234] = new Collation(234, "UTF8MB4_CZECH_CI", "utf8", 4);
    charsets[235] = new Collation(235, "UTF8MB4_DANISH_CI", "utf8", 4);
    charsets[236] = new Collation(236, "UTF8MB4_LITHUANIAN_CI", "utf8", 4);
    charsets[237] = new Collation(237, "UTF8MB4_SLOVAK_CI", "utf8", 4);
    charsets[238] = new Collation(238, "UTF8MB4_SPANISH2_CI", "utf8", 4);
    charsets[239] = new Collation(239, "UTF8MB4_ROMAN_CI", "utf8", 4);
    charsets[240] = new Collation(240, "UTF8MB4_PERSIAN_CI", "utf8", 4);
    charsets[241] = new Collation(241, "UTF8MB4_ESPERANTO_CI", "utf8", 4);
    charsets[242] = new Collation(242, "UTF8MB4_HUNGARIAN_CI", "utf8", 4);
    charsets[243] = new Collation(243, "UTF8MB4_SINHALA_CI", "utf8", 4);
    charsets[244] = new Collation(244, "UTF8MB4_GERMAN2_CI", "utf8", 4);
    charsets[245] = new Collation(245, "UTF8MB4_CROATIAN_MYSQL561_CI", "utf8", 4);
    charsets[246] = new Collation(246, "UTF8MB4_UNICODE_520_CI", "utf8", 4);
    charsets[247] = new Collation(247, "UTF8MB4_VIETNAMESE_CI", "utf8", 4);
    charsets[248] = new Collation(248, "GB18030_CHINESE_CI", "gb18030", 4);
    charsets[249] = new Collation(249, "GB18030_BIN", "gb18030", 4);
    charsets[250] = new Collation(250, "GB18030_UNICODE_520_CI", "gb18030", 4);
    charsets[255] = new Collation(255, "UTF8MB4_0900_AI_CI", "utf8", 4);
    charsets[256] = new Collation(256, "UTF8MB4_DE_PB_0900_AI_CI", "utf8", 4);
    charsets[257] = new Collation(257, "UTF8MB4_IS_0900_AI_CI", "utf8", 4);
    charsets[258] = new Collation(258, "UTF8MB4_LV_0900_AI_CI", "utf8", 4);
    charsets[259] = new Collation(259, "UTF8MB4_RO_0900_AI_CI", "utf8", 4);
    charsets[260] = new Collation(260, "UTF8MB4_SL_0900_AI_CI", "utf8", 4);
    charsets[261] = new Collation(261, "UTF8MB4_PL_0900_AI_CI", "utf8", 4);
    charsets[262] = new Collation(262, "UTF8MB4_ET_0900_AI_CI", "utf8", 4);
    charsets[263] = new Collation(263, "UTF8MB4_ES_0900_AI_CI", "utf8", 4);
    charsets[264] = new Collation(264, "UTF8MB4_SV_0900_AI_CI", "utf8", 4);
    charsets[265] = new Collation(265, "UTF8MB4_TR_0900_AI_CI", "utf8", 4);
    charsets[266] = new Collation(266, "UTF8MB4_CS_0900_AI_CI", "utf8", 4);
    charsets[267] = new Collation(267, "UTF8MB4_DA_0900_AI_CI", "utf8", 4);
    charsets[268] = new Collation(268, "UTF8MB4_LT_0900_AI_CI", "utf8", 4);
    charsets[269] = new Collation(269, "UTF8MB4_SK_0900_AI_CI", "utf8", 4);
    charsets[270] = new Collation(270, "UTF8MB4_ES_TRAD_0900_AI_CI", "utf8", 4);
    charsets[271] = new Collation(271, "UTF8MB4_LA_0900_AI_CI", "utf8", 4);
    charsets[273] = new Collation(273, "UTF8MB4_EO_0900_AI_CI", "utf8", 4);
    charsets[274] = new Collation(274, "UTF8MB4_HU_0900_AI_CI", "utf8", 4);
    charsets[275] = new Collation(275, "UTF8MB4_HR_0900_AI_CI", "utf8", 4);
    charsets[277] = new Collation(277, "UTF8MB4_VI_0900_AI_CI", "utf8", 4);
    charsets[278] = new Collation(278, "UTF8MB4_0900_AS_CS", "utf8", 4);
    charsets[279] = new Collation(279, "UTF8MB4_DE_PB_0900_AS_CS", "utf8", 4);
    charsets[280] = new Collation(280, "UTF8MB4_IS_0900_AS_CS", "utf8", 4);
    charsets[281] = new Collation(281, "UTF8MB4_LV_0900_AS_CS", "utf8", 4);
    charsets[282] = new Collation(282, "UTF8MB4_RO_0900_AS_CS", "utf8", 4);
    charsets[283] = new Collation(283, "UTF8MB4_SL_0900_AS_CS", "utf8", 4);
    charsets[284] = new Collation(284, "UTF8MB4_PL_0900_AS_CS", "utf8", 4);
    charsets[285] = new Collation(285, "UTF8MB4_ET_0900_AS_CS", "utf8", 4);
    charsets[286] = new Collation(286, "UTF8MB4_ES_0900_AS_CS", "utf8", 4);
    charsets[287] = new Collation(287, "UTF8MB4_SV_0900_AS_CS", "utf8", 4);
    charsets[288] = new Collation(288, "UTF8MB4_TR_0900_AS_CS", "utf8", 4);
    charsets[289] = new Collation(289, "UTF8MB4_CS_0900_AS_CS", "utf8", 4);
    charsets[290] = new Collation(290, "UTF8MB4_DA_0900_AS_CS", "utf8", 4);
    charsets[291] = new Collation(291, "UTF8MB4_LT_0900_AS_CS", "utf8", 4);
    charsets[292] = new Collation(292, "UTF8MB4_SK_0900_AS_CS", "utf8", 4);
    charsets[293] = new Collation(293, "UTF8MB4_ES_TRAD_0900_AS_CS", "utf8", 4);
    charsets[294] = new Collation(294, "UTF8MB4_LA_0900_AS_CS", "utf8", 4);
    charsets[296] = new Collation(296, "UTF8MB4_EO_0900_AS_CS", "utf8", 4);
    charsets[297] = new Collation(297, "UTF8MB4_HU_0900_AS_CS", "utf8", 4);
    charsets[298] = new Collation(298, "UTF8MB4_HR_0900_AS_CS", "utf8", 4);
    charsets[300] = new Collation(300, "UTF8MB4_VI_0900_AS_CS", "utf8", 4);
    charsets[303] = new Collation(303, "UTF8MB4_JA_0900_AS_CS", "utf8", 4);
    charsets[304] = new Collation(304, "UTF8MB4_JA_0900_AS_CS_KS", "utf8", 4);
    charsets[305] = new Collation(305, "UTF8MB4_0900_AS_CI", "utf8", 4);
    charsets[306] = new Collation(306, "UTF8MB4_RU_0900_AI_CI", "utf8", 4);
    charsets[307] = new Collation(307, "UTF8MB4_RU_0900_AS_CS", "utf8", 4);
    charsets[308] = new Collation(308, "UTF8MB4_ZH_0900_AS_CS", "utf8", 4);
    charsets[309] = new Collation(309, "UTF8MB4_0900_BIN", "utf8", 4);
    charsets[576] = new Collation(576, "UTF8MB3_CROATIAN_CI", "utf8", 3);
    charsets[577] = new Collation(577, "UTF8MB3_MYANMAR_CI", "utf8", 3);
    charsets[578] = new Collation(578, "UTF8MB3_THAI_520_W2", "utf8", 3);
    charsets[608] = new Collation(608, "UTF8MB4_CROATIAN_CI", "utf8", 4);
    charsets[609] = new Collation(609, "UTF8MB4_MYANMAR_CI", "utf8", 4);
    charsets[610] = new Collation(610, "UTF8MB4_THAI_520_W2", "utf8", 4);
    charsets[640] = new Collation(640, "UCS2_CROATIAN_CI", "ucs2", 2);
    charsets[641] = new Collation(641, "UCS2_MYANMAR_CI", "ucs2", 2);
    charsets[642] = new Collation(642, "UCS2_THAI_520_W2", "ucs2", 2);
    charsets[672] = new Collation(672, "UTF16_CROATIAN_CI", "utf16", 4);
    charsets[673] = new Collation(673, "UTF16_MYANMAR_CI", "utf16", 4);
    charsets[674] = new Collation(674, "UTF16_THAI_520_W2", "utf16", 4);
    charsets[736] = new Collation(736, "UTF32_CROATIAN_CI", "utf32", 4);
    charsets[737] = new Collation(737, "UTF32_MYANMAR_CI", "utf32", 4);
    charsets[738] = new Collation(738, "UTF32_THAI_520_W2", "utf32", 4);
    charsets[1025] = new Collation(1025, "BIG5_CHINESE_NOPAD_CI", "big5", 2);
    charsets[1027] = new Collation(1027, "DEC8_SWEDISH_NOPAD_CI", "dec8", 1);
    charsets[1028] = new Collation(1028, "CP850_GENERAL_NOPAD_CI", "cp850", 1);
    charsets[1030] = new Collation(1030, "HP8_ENGLISH_NOPAD_CI", "hp8", 1);
    charsets[1031] = new Collation(1031, "KOI8R_GENERAL_NOPAD_CI", "koi8r", 1);
    charsets[1032] = new Collation(1032, "LATIN1_SWEDISH_NOPAD_CI", "latin1", 1);
    charsets[1033] = new Collation(1033, "LATIN2_GENERAL_NOPAD_CI", "latin2", 1);
    charsets[1034] = new Collation(1034, "SWE7_SWEDISH_NOPAD_CI", "swe7", 1);
    charsets[1035] = new Collation(1035, "ASCII_GENERAL_NOPAD_CI", "ascii", 1);
    charsets[1036] = new Collation(1036, "UJIS_JAPANESE_NOPAD_CI", "ujis", 3);
    charsets[1037] = new Collation(1037, "SJIS_JAPANESE_NOPAD_CI", "sjis", 2);
    charsets[1040] = new Collation(1040, "HEBREW_GENERAL_NOPAD_CI", "hebrew", 1);
    charsets[1042] = new Collation(1042, "TIS620_THAI_NOPAD_CI", "tis620", 1);
    charsets[1043] = new Collation(1043, "EUCKR_KOREAN_NOPAD_CI", "euckr", 2);
    charsets[1046] = new Collation(1046, "KOI8U_GENERAL_NOPAD_CI", "koi8u", 1);
    charsets[1048] = new Collation(1048, "GB2312_CHINESE_NOPAD_CI", "gb2312", 2);
    charsets[1049] = new Collation(1049, "GREEK_GENERAL_NOPAD_CI", "greek", 1);
    charsets[1050] = new Collation(1050, "CP1250_GENERAL_NOPAD_CI", "cp1250", 1);
    charsets[1052] = new Collation(1052, "GBK_CHINESE_NOPAD_CI", "gbk", 2);
    charsets[1054] = new Collation(1054, "LATIN5_TURKISH_NOPAD_CI", "latin5", 1);
    charsets[1056] = new Collation(1056, "ARMSCII8_GENERAL_NOPAD_CI", "armscii8", 1);
    charsets[1057] = new Collation(1057, "UTF8MB3_GENERAL_NOPAD_CI", "utf8", 3);
    charsets[1059] = new Collation(1059, "UCS2_GENERAL_NOPAD_CI", "ucs2", 2);
    charsets[1060] = new Collation(1060, "CP866_GENERAL_NOPAD_CI", "cp866", 1);
    charsets[1061] = new Collation(1061, "KEYBCS2_GENERAL_NOPAD_CI", "keybcs2", 1);
    charsets[1062] = new Collation(1062, "MACCE_GENERAL_NOPAD_CI", "macce", 1);
    charsets[1063] = new Collation(1063, "MACROMAN_GENERAL_NOPAD_CI", "macroman", 1);
    charsets[1064] = new Collation(1064, "CP852_GENERAL_NOPAD_CI", "cp852", 1);
    charsets[1065] = new Collation(1065, "LATIN7_GENERAL_NOPAD_CI", "latin7", 1);
    charsets[1067] = new Collation(1067, "MACCE_NOPAD_BIN", "macce", 1);
    charsets[1069] = new Collation(1069, "UTF8MB4_GENERAL_NOPAD_CI", "utf8", 4);
    charsets[1070] = new Collation(1070, "UTF8MB4_NOPAD_BIN", "utf8", 4);
    charsets[1071] = new Collation(1071, "LATIN1_NOPAD_BIN", "latin1", 1);
    charsets[1074] = new Collation(1074, "CP1251_NOPAD_BIN", "cp1251", 1);
    charsets[1075] = new Collation(1075, "CP1251_GENERAL_NOPAD_CI", "cp1251", 1);
    charsets[1077] = new Collation(1077, "MACROMAN_NOPAD_BIN", "macroman", 1);
    charsets[1078] = new Collation(1078, "UTF16_GENERAL_NOPAD_CI", "utf16", 4);
    charsets[1079] = new Collation(1079, "UTF16_NOPAD_BIN", "utf16", 4);
    charsets[1080] = new Collation(1080, "UTF16LE_GENERAL_NOPAD_CI", "utf16le", 4);
    charsets[1081] = new Collation(1081, "CP1256_GENERAL_NOPAD_CI", "cp1256", 1);
    charsets[1082] = new Collation(1082, "CP1257_NOPAD_BIN", "cp1257", 1);
    charsets[1083] = new Collation(1083, "CP1257_GENERAL_NOPAD_CI", "cp1257", 1);
    charsets[1084] = new Collation(1084, "UTF32_GENERAL_NOPAD_CI", "utf32", 4);
    charsets[1085] = new Collation(1085, "UTF32_NOPAD_BIN", "utf32", 4);
    charsets[1086] = new Collation(1086, "UTF16LE_NOPAD_BIN", "utf16le", 4);
    charsets[1088] = new Collation(1088, "ARMSCII8_NOPAD_BIN", "armscii8", 1);
    charsets[1089] = new Collation(1089, "ASCII_NOPAD_BIN", "ascii", 1);
    charsets[1090] = new Collation(1090, "CP1250_NOPAD_BIN", "cp1250", 1);
    charsets[1091] = new Collation(1091, "CP1256_NOPAD_BIN", "cp1256", 1);
    charsets[1092] = new Collation(1092, "CP866_NOPAD_BIN", "cp866", 1);
    charsets[1093] = new Collation(1093, "DEC8_NOPAD_BIN", "dec8", 1);
    charsets[1094] = new Collation(1094, "GREEK_NOPAD_BIN", "greek", 1);
    charsets[1095] = new Collation(1095, "HEBREW_NOPAD_BIN", "hebrew", 1);
    charsets[1096] = new Collation(1096, "HP8_NOPAD_BIN", "hp8", 1);
    charsets[1097] = new Collation(1097, "KEYBCS2_NOPAD_BIN", "keybcs2", 1);
    charsets[1098] = new Collation(1098, "KOI8R_NOPAD_BIN", "koi8r", 1);
    charsets[1099] = new Collation(1099, "KOI8U_NOPAD_BIN", "koi8u", 1);
    charsets[1101] = new Collation(1101, "LATIN2_NOPAD_BIN", "latin2", 1);
    charsets[1102] = new Collation(1102, "LATIN5_NOPAD_BIN", "latin5", 1);
    charsets[1103] = new Collation(1103, "LATIN7_NOPAD_BIN", "latin7", 1);
    charsets[1104] = new Collation(1104, "CP850_NOPAD_BIN", "cp850", 1);
    charsets[1105] = new Collation(1105, "CP852_NOPAD_BIN", "cp852", 1);
    charsets[1106] = new Collation(1106, "SWE7_NOPAD_BIN", "swe7", 1);
    charsets[1107] = new Collation(1107, "UTF8MB3_NOPAD_BIN", "utf8", 3);
    charsets[1108] = new Collation(1108, "BIG5_NOPAD_BIN", "big5", 2);
    charsets[1109] = new Collation(1109, "EUCKR_NOPAD_BIN", "euckr", 2);
    charsets[1110] = new Collation(1110, "GB2312_NOPAD_BIN", "gb2312", 2);
    charsets[1111] = new Collation(1111, "GBK_NOPAD_BIN", "gbk", 2);
    charsets[1112] = new Collation(1112, "SJIS_NOPAD_BIN", "sjis", 2);
    charsets[1113] = new Collation(1113, "TIS620_NOPAD_BIN", "tis620", 1);
    charsets[1114] = new Collation(1114, "UCS2_NOPAD_BIN", "ucs2", 2);
    charsets[1115] = new Collation(1115, "UJIS_NOPAD_BIN", "ujis", 3);
    charsets[1116] = new Collation(1116, "GEOSTD8_GENERAL_NOPAD_CI", "geostd8", 1);
    charsets[1117] = new Collation(1117, "GEOSTD8_NOPAD_BIN", "geostd8", 1);
    charsets[1119] = new Collation(1119, "CP932_JAPANESE_NOPAD_CI", "cp932", 2);
    charsets[1120] = new Collation(1120, "CP932_NOPAD_BIN", "cp932", 2);
    charsets[1121] = new Collation(1121, "EUCJPMS_JAPANESE_NOPAD_CI", "eucjpms", 3);
    charsets[1122] = new Collation(1122, "EUCJPMS_NOPAD_BIN", "eucjpms", 3);
    charsets[1125] = new Collation(1125, "UTF16_UNICODE_NOPAD_CI", "utf16", 4);
    charsets[1147] = new Collation(1147, "UTF16_UNICODE_520_NOPAD_CI", "utf16", 4);
    charsets[1152] = new Collation(1152, "UCS2_UNICODE_NOPAD_CI", "ucs2", 2);
    charsets[1174] = new Collation(1174, "UCS2_UNICODE_520_NOPAD_CI", "ucs2", 2);
    charsets[1184] = new Collation(1184, "UTF32_UNICODE_NOPAD_CI", "utf32", 4);
    charsets[1206] = new Collation(1206, "UTF32_UNICODE_520_NOPAD_CI", "utf32", 4);
    charsets[1216] = new Collation(1216, "UTF8MB3_UNICODE_NOPAD_CI", "utf8", 3);
    charsets[1238] = new Collation(1238, "UTF8MB3_UNICODE_520_NOPAD_CI", "utf8", 3);
    charsets[1248] = new Collation(1248, "UTF8MB4_UNICODE_NOPAD_CI", "utf8", 4);
    charsets[1270] = new Collation(1270, "UTF8MB4_UNICODE_520_NOPAD_CI", "utf8", 4);
    charsets[2048] = new Collation(2048, "UCA1400_AI_CI", "utf8", 3);
    charsets[2049] = new Collation(2049, "UCA1400_AI_CS", "utf8", 3);
    charsets[2050] = new Collation(2050, "UCA1400_AS_CI", "utf8", 3);
    charsets[2051] = new Collation(2051, "UCA1400_AS_CS", "utf8", 3);
    charsets[2052] = new Collation(2052, "UCA1400_NOPAD_AI_CI", "utf8", 3);
    charsets[2053] = new Collation(2053, "UCA1400_NOPAD_AI_CS", "utf8", 3);
    charsets[2054] = new Collation(2054, "UCA1400_NOPAD_AS_CI", "utf8", 3);
    charsets[2055] = new Collation(2055, "UCA1400_NOPAD_AS_CS", "utf8", 3);
    charsets[2056] = new Collation(2056, "UCA1400_ICELANDIC_AI_CI", "utf8", 3);
    charsets[2057] = new Collation(2057, "UCA1400_ICELANDIC_AI_CS", "utf8", 3);
    charsets[2058] = new Collation(2058, "UCA1400_ICELANDIC_AS_CI", "utf8", 3);
    charsets[2059] = new Collation(2059, "UCA1400_ICELANDIC_AS_CS", "utf8", 3);
    charsets[2060] = new Collation(2060, "UCA1400_ICELANDIC_NOPAD_AI_CI", "utf8", 3);
    charsets[2061] = new Collation(2061, "UCA1400_ICELANDIC_NOPAD_AI_CS", "utf8", 3);
    charsets[2062] = new Collation(2062, "UCA1400_ICELANDIC_NOPAD_AS_CI", "utf8", 3);
    charsets[2063] = new Collation(2063, "UCA1400_ICELANDIC_NOPAD_AS_CS", "utf8", 3);
    charsets[2064] = new Collation(2064, "UCA1400_LATVIAN_AI_CI", "utf8", 3);
    charsets[2065] = new Collation(2065, "UCA1400_LATVIAN_AI_CS", "utf8", 3);
    charsets[2066] = new Collation(2066, "UCA1400_LATVIAN_AS_CI", "utf8", 3);
    charsets[2067] = new Collation(2067, "UCA1400_LATVIAN_AS_CS", "utf8", 3);
    charsets[2068] = new Collation(2068, "UCA1400_LATVIAN_NOPAD_AI_CI", "utf8", 3);
    charsets[2069] = new Collation(2069, "UCA1400_LATVIAN_NOPAD_AI_CS", "utf8", 3);
    charsets[2070] = new Collation(2070, "UCA1400_LATVIAN_NOPAD_AS_CI", "utf8", 3);
    charsets[2071] = new Collation(2071, "UCA1400_LATVIAN_NOPAD_AS_CS", "utf8", 3);
    charsets[2072] = new Collation(2072, "UCA1400_ROMANIAN_AI_CI", "utf8", 3);
    charsets[2073] = new Collation(2073, "UCA1400_ROMANIAN_AI_CS", "utf8", 3);
    charsets[2074] = new Collation(2074, "UCA1400_ROMANIAN_AS_CI", "utf8", 3);
    charsets[2075] = new Collation(2075, "UCA1400_ROMANIAN_AS_CS", "utf8", 3);
    charsets[2076] = new Collation(2076, "UCA1400_ROMANIAN_NOPAD_AI_CI", "utf8", 3);
    charsets[2077] = new Collation(2077, "UCA1400_ROMANIAN_NOPAD_AI_CS", "utf8", 3);
    charsets[2078] = new Collation(2078, "UCA1400_ROMANIAN_NOPAD_AS_CI", "utf8", 3);
    charsets[2079] = new Collation(2079, "UCA1400_ROMANIAN_NOPAD_AS_CS", "utf8", 3);
    charsets[2080] = new Collation(2080, "UCA1400_SLOVENIAN_AI_CI", "utf8", 3);
    charsets[2081] = new Collation(2081, "UCA1400_SLOVENIAN_AI_CS", "utf8", 3);
    charsets[2082] = new Collation(2082, "UCA1400_SLOVENIAN_AS_CI", "utf8", 3);
    charsets[2083] = new Collation(2083, "UCA1400_SLOVENIAN_AS_CS", "utf8", 3);
    charsets[2084] = new Collation(2084, "UCA1400_SLOVENIAN_NOPAD_AI_CI", "utf8", 3);
    charsets[2085] = new Collation(2085, "UCA1400_SLOVENIAN_NOPAD_AI_CS", "utf8", 3);
    charsets[2086] = new Collation(2086, "UCA1400_SLOVENIAN_NOPAD_AS_CI", "utf8", 3);
    charsets[2087] = new Collation(2087, "UCA1400_SLOVENIAN_NOPAD_AS_CS", "utf8", 3);
    charsets[2088] = new Collation(2088, "UCA1400_POLISH_AI_CI", "utf8", 3);
    charsets[2089] = new Collation(2089, "UCA1400_POLISH_AI_CS", "utf8", 3);
    charsets[2090] = new Collation(2090, "UCA1400_POLISH_AS_CI", "utf8", 3);
    charsets[2091] = new Collation(2091, "UCA1400_POLISH_AS_CS", "utf8", 3);
    charsets[2092] = new Collation(2092, "UCA1400_POLISH_NOPAD_AI_CI", "utf8", 3);
    charsets[2093] = new Collation(2093, "UCA1400_POLISH_NOPAD_AI_CS", "utf8", 3);
    charsets[2094] = new Collation(2094, "UCA1400_POLISH_NOPAD_AS_CI", "utf8", 3);
    charsets[2095] = new Collation(2095, "UCA1400_POLISH_NOPAD_AS_CS", "utf8", 3);
    charsets[2096] = new Collation(2096, "UCA1400_ESTONIAN_AI_CI", "utf8", 3);
    charsets[2097] = new Collation(2097, "UCA1400_ESTONIAN_AI_CS", "utf8", 3);
    charsets[2098] = new Collation(2098, "UCA1400_ESTONIAN_AS_CI", "utf8", 3);
    charsets[2099] = new Collation(2099, "UCA1400_ESTONIAN_AS_CS", "utf8", 3);
    charsets[2100] = new Collation(2100, "UCA1400_ESTONIAN_NOPAD_AI_CI", "utf8", 3);
    charsets[2101] = new Collation(2101, "UCA1400_ESTONIAN_NOPAD_AI_CS", "utf8", 3);
    charsets[2102] = new Collation(2102, "UCA1400_ESTONIAN_NOPAD_AS_CI", "utf8", 3);
    charsets[2103] = new Collation(2103, "UCA1400_ESTONIAN_NOPAD_AS_CS", "utf8", 3);
    charsets[2104] = new Collation(2104, "UCA1400_SPANISH_AI_CI", "utf8", 3);
    charsets[2105] = new Collation(2105, "UCA1400_SPANISH_AI_CS", "utf8", 3);
    charsets[2106] = new Collation(2106, "UCA1400_SPANISH_AS_CI", "utf8", 3);
    charsets[2107] = new Collation(2107, "UCA1400_SPANISH_AS_CS", "utf8", 3);
    charsets[2108] = new Collation(2108, "UCA1400_SPANISH_NOPAD_AI_CI", "utf8", 3);
    charsets[2109] = new Collation(2109, "UCA1400_SPANISH_NOPAD_AI_CS", "utf8", 3);
    charsets[2110] = new Collation(2110, "UCA1400_SPANISH_NOPAD_AS_CI", "utf8", 3);
    charsets[2111] = new Collation(2111, "UCA1400_SPANISH_NOPAD_AS_CS", "utf8", 3);
    charsets[2112] = new Collation(2112, "UCA1400_SWEDISH_AI_CI", "utf8", 3);
    charsets[2113] = new Collation(2113, "UCA1400_SWEDISH_AI_CS", "utf8", 3);
    charsets[2114] = new Collation(2114, "UCA1400_SWEDISH_AS_CI", "utf8", 3);
    charsets[2115] = new Collation(2115, "UCA1400_SWEDISH_AS_CS", "utf8", 3);
    charsets[2116] = new Collation(2116, "UCA1400_SWEDISH_NOPAD_AI_CI", "utf8", 3);
    charsets[2117] = new Collation(2117, "UCA1400_SWEDISH_NOPAD_AI_CS", "utf8", 3);
    charsets[2118] = new Collation(2118, "UCA1400_SWEDISH_NOPAD_AS_CI", "utf8", 3);
    charsets[2119] = new Collation(2119, "UCA1400_SWEDISH_NOPAD_AS_CS", "utf8", 3);
    charsets[2120] = new Collation(2120, "UCA1400_TURKISH_AI_CI", "utf8", 3);
    charsets[2121] = new Collation(2121, "UCA1400_TURKISH_AI_CS", "utf8", 3);
    charsets[2122] = new Collation(2122, "UCA1400_TURKISH_AS_CI", "utf8", 3);
    charsets[2123] = new Collation(2123, "UCA1400_TURKISH_AS_CS", "utf8", 3);
    charsets[2124] = new Collation(2124, "UCA1400_TURKISH_NOPAD_AI_CI", "utf8", 3);
    charsets[2125] = new Collation(2125, "UCA1400_TURKISH_NOPAD_AI_CS", "utf8", 3);
    charsets[2126] = new Collation(2126, "UCA1400_TURKISH_NOPAD_AS_CI", "utf8", 3);
    charsets[2127] = new Collation(2127, "UCA1400_TURKISH_NOPAD_AS_CS", "utf8", 3);
    charsets[2128] = new Collation(2128, "UCA1400_CZECH_AI_CI", "utf8", 3);
    charsets[2129] = new Collation(2129, "UCA1400_CZECH_AI_CS", "utf8", 3);
    charsets[2130] = new Collation(2130, "UCA1400_CZECH_AS_CI", "utf8", 3);
    charsets[2131] = new Collation(2131, "UCA1400_CZECH_AS_CS", "utf8", 3);
    charsets[2132] = new Collation(2132, "UCA1400_CZECH_NOPAD_AI_CI", "utf8", 3);
    charsets[2133] = new Collation(2133, "UCA1400_CZECH_NOPAD_AI_CS", "utf8", 3);
    charsets[2134] = new Collation(2134, "UCA1400_CZECH_NOPAD_AS_CI", "utf8", 3);
    charsets[2135] = new Collation(2135, "UCA1400_CZECH_NOPAD_AS_CS", "utf8", 3);
    charsets[2136] = new Collation(2136, "UCA1400_DANISH_AI_CI", "utf8", 3);
    charsets[2137] = new Collation(2137, "UCA1400_DANISH_AI_CS", "utf8", 3);
    charsets[2138] = new Collation(2138, "UCA1400_DANISH_AS_CI", "utf8", 3);
    charsets[2139] = new Collation(2139, "UCA1400_DANISH_AS_CS", "utf8", 3);
    charsets[2140] = new Collation(2140, "UCA1400_DANISH_NOPAD_AI_CI", "utf8", 3);
    charsets[2141] = new Collation(2141, "UCA1400_DANISH_NOPAD_AI_CS", "utf8", 3);
    charsets[2142] = new Collation(2142, "UCA1400_DANISH_NOPAD_AS_CI", "utf8", 3);
    charsets[2143] = new Collation(2143, "UCA1400_DANISH_NOPAD_AS_CS", "utf8", 3);
    charsets[2144] = new Collation(2144, "UCA1400_LITHUANIAN_AI_CI", "utf8", 3);
    charsets[2145] = new Collation(2145, "UCA1400_LITHUANIAN_AI_CS", "utf8", 3);
    charsets[2146] = new Collation(2146, "UCA1400_LITHUANIAN_AS_CI", "utf8", 3);
    charsets[2147] = new Collation(2147, "UCA1400_LITHUANIAN_AS_CS", "utf8", 3);
    charsets[2148] = new Collation(2148, "UCA1400_LITHUANIAN_NOPAD_AI_CI", "utf8", 3);
    charsets[2149] = new Collation(2149, "UCA1400_LITHUANIAN_NOPAD_AI_CS", "utf8", 3);
    charsets[2150] = new Collation(2150, "UCA1400_LITHUANIAN_NOPAD_AS_CI", "utf8", 3);
    charsets[2151] = new Collation(2151, "UCA1400_LITHUANIAN_NOPAD_AS_CS", "utf8", 3);
    charsets[2152] = new Collation(2152, "UCA1400_SLOVAK_AI_CI", "utf8", 3);
    charsets[2153] = new Collation(2153, "UCA1400_SLOVAK_AI_CS", "utf8", 3);
    charsets[2154] = new Collation(2154, "UCA1400_SLOVAK_AS_CI", "utf8", 3);
    charsets[2155] = new Collation(2155, "UCA1400_SLOVAK_AS_CS", "utf8", 3);
    charsets[2156] = new Collation(2156, "UCA1400_SLOVAK_NOPAD_AI_CI", "utf8", 3);
    charsets[2157] = new Collation(2157, "UCA1400_SLOVAK_NOPAD_AI_CS", "utf8", 3);
    charsets[2158] = new Collation(2158, "UCA1400_SLOVAK_NOPAD_AS_CI", "utf8", 3);
    charsets[2159] = new Collation(2159, "UCA1400_SLOVAK_NOPAD_AS_CS", "utf8", 3);
    charsets[2160] = new Collation(2160, "UCA1400_SPANISH2_AI_CI", "utf8", 3);
    charsets[2161] = new Collation(2161, "UCA1400_SPANISH2_AI_CS", "utf8", 3);
    charsets[2162] = new Collation(2162, "UCA1400_SPANISH2_AS_CI", "utf8", 3);
    charsets[2163] = new Collation(2163, "UCA1400_SPANISH2_AS_CS", "utf8", 3);
    charsets[2164] = new Collation(2164, "UCA1400_SPANISH2_NOPAD_AI_CI", "utf8", 3);
    charsets[2165] = new Collation(2165, "UCA1400_SPANISH2_NOPAD_AI_CS", "utf8", 3);
    charsets[2166] = new Collation(2166, "UCA1400_SPANISH2_NOPAD_AS_CI", "utf8", 3);
    charsets[2167] = new Collation(2167, "UCA1400_SPANISH2_NOPAD_AS_CS", "utf8", 3);
    charsets[2168] = new Collation(2168, "UCA1400_ROMAN_AI_CI", "utf8", 3);
    charsets[2169] = new Collation(2169, "UCA1400_ROMAN_AI_CS", "utf8", 3);
    charsets[2170] = new Collation(2170, "UCA1400_ROMAN_AS_CI", "utf8", 3);
    charsets[2171] = new Collation(2171, "UCA1400_ROMAN_AS_CS", "utf8", 3);
    charsets[2172] = new Collation(2172, "UCA1400_ROMAN_NOPAD_AI_CI", "utf8", 3);
    charsets[2173] = new Collation(2173, "UCA1400_ROMAN_NOPAD_AI_CS", "utf8", 3);
    charsets[2174] = new Collation(2174, "UCA1400_ROMAN_NOPAD_AS_CI", "utf8", 3);
    charsets[2175] = new Collation(2175, "UCA1400_ROMAN_NOPAD_AS_CS", "utf8", 3);
    charsets[2176] = new Collation(2176, "UCA1400_PERSIAN_AI_CI", "utf8", 3);
    charsets[2177] = new Collation(2177, "UCA1400_PERSIAN_AI_CS", "utf8", 3);
    charsets[2178] = new Collation(2178, "UCA1400_PERSIAN_AS_CI", "utf8", 3);
    charsets[2179] = new Collation(2179, "UCA1400_PERSIAN_AS_CS", "utf8", 3);
    charsets[2180] = new Collation(2180, "UCA1400_PERSIAN_NOPAD_AI_CI", "utf8", 3);
    charsets[2181] = new Collation(2181, "UCA1400_PERSIAN_NOPAD_AI_CS", "utf8", 3);
    charsets[2182] = new Collation(2182, "UCA1400_PERSIAN_NOPAD_AS_CI", "utf8", 3);
    charsets[2183] = new Collation(2183, "UCA1400_PERSIAN_NOPAD_AS_CS", "utf8", 3);
    charsets[2184] = new Collation(2184, "UCA1400_ESPERANTO_AI_CI", "utf8", 3);
    charsets[2185] = new Collation(2185, "UCA1400_ESPERANTO_AI_CS", "utf8", 3);
    charsets[2186] = new Collation(2186, "UCA1400_ESPERANTO_AS_CI", "utf8", 3);
    charsets[2187] = new Collation(2187, "UCA1400_ESPERANTO_AS_CS", "utf8", 3);
    charsets[2188] = new Collation(2188, "UCA1400_ESPERANTO_NOPAD_AI_CI", "utf8", 3);
    charsets[2189] = new Collation(2189, "UCA1400_ESPERANTO_NOPAD_AI_CS", "utf8", 3);
    charsets[2190] = new Collation(2190, "UCA1400_ESPERANTO_NOPAD_AS_CI", "utf8", 3);
    charsets[2191] = new Collation(2191, "UCA1400_ESPERANTO_NOPAD_AS_CS", "utf8", 3);
    charsets[2192] = new Collation(2192, "UCA1400_HUNGARIAN_AI_CI", "utf8", 3);
    charsets[2193] = new Collation(2193, "UCA1400_HUNGARIAN_AI_CS", "utf8", 3);
    charsets[2194] = new Collation(2194, "UCA1400_HUNGARIAN_AS_CI", "utf8", 3);
    charsets[2195] = new Collation(2195, "UCA1400_HUNGARIAN_AS_CS", "utf8", 3);
    charsets[2196] = new Collation(2196, "UCA1400_HUNGARIAN_NOPAD_AI_CI", "utf8", 3);
    charsets[2197] = new Collation(2197, "UCA1400_HUNGARIAN_NOPAD_AI_CS", "utf8", 3);
    charsets[2198] = new Collation(2198, "UCA1400_HUNGARIAN_NOPAD_AS_CI", "utf8", 3);
    charsets[2199] = new Collation(2199, "UCA1400_HUNGARIAN_NOPAD_AS_CS", "utf8", 3);
    charsets[2200] = new Collation(2200, "UCA1400_SINHALA_AI_CI", "utf8", 3);
    charsets[2201] = new Collation(2201, "UCA1400_SINHALA_AI_CS", "utf8", 3);
    charsets[2202] = new Collation(2202, "UCA1400_SINHALA_AS_CI", "utf8", 3);
    charsets[2203] = new Collation(2203, "UCA1400_SINHALA_AS_CS", "utf8", 3);
    charsets[2204] = new Collation(2204, "UCA1400_SINHALA_NOPAD_AI_CI", "utf8", 3);
    charsets[2205] = new Collation(2205, "UCA1400_SINHALA_NOPAD_AI_CS", "utf8", 3);
    charsets[2206] = new Collation(2206, "UCA1400_SINHALA_NOPAD_AS_CI", "utf8", 3);
    charsets[2207] = new Collation(2207, "UCA1400_SINHALA_NOPAD_AS_CS", "utf8", 3);
    charsets[2208] = new Collation(2208, "UCA1400_GERMAN2_AI_CI", "utf8", 3);
    charsets[2209] = new Collation(2209, "UCA1400_GERMAN2_AI_CS", "utf8", 3);
    charsets[2210] = new Collation(2210, "UCA1400_GERMAN2_AS_CI", "utf8", 3);
    charsets[2211] = new Collation(2211, "UCA1400_GERMAN2_AS_CS", "utf8", 3);
    charsets[2212] = new Collation(2212, "UCA1400_GERMAN2_NOPAD_AI_CI", "utf8", 3);
    charsets[2213] = new Collation(2213, "UCA1400_GERMAN2_NOPAD_AI_CS", "utf8", 3);
    charsets[2214] = new Collation(2214, "UCA1400_GERMAN2_NOPAD_AS_CI", "utf8", 3);
    charsets[2215] = new Collation(2215, "UCA1400_GERMAN2_NOPAD_AS_CS", "utf8", 3);
    charsets[2232] = new Collation(2232, "UCA1400_VIETNAMESE_AI_CI", "utf8", 3);
    charsets[2233] = new Collation(2233, "UCA1400_VIETNAMESE_AI_CS", "utf8", 3);
    charsets[2234] = new Collation(2234, "UCA1400_VIETNAMESE_AS_CI", "utf8", 3);
    charsets[2235] = new Collation(2235, "UCA1400_VIETNAMESE_AS_CS", "utf8", 3);
    charsets[2236] = new Collation(2236, "UCA1400_VIETNAMESE_NOPAD_AI_CI", "utf8", 3);
    charsets[2237] = new Collation(2237, "UCA1400_VIETNAMESE_NOPAD_AI_CS", "utf8", 3);
    charsets[2238] = new Collation(2238, "UCA1400_VIETNAMESE_NOPAD_AS_CI", "utf8", 3);
    charsets[2239] = new Collation(2239, "UCA1400_VIETNAMESE_NOPAD_AS_CS", "utf8", 3);
    charsets[2240] = new Collation(2240, "UCA1400_CROATIAN_AI_CI", "utf8", 3);
    charsets[2241] = new Collation(2241, "UCA1400_CROATIAN_AI_CS", "utf8", 3);
    charsets[2242] = new Collation(2242, "UCA1400_CROATIAN_AS_CI", "utf8", 3);
    charsets[2243] = new Collation(2243, "UCA1400_CROATIAN_AS_CS", "utf8", 3);
    charsets[2244] = new Collation(2244, "UCA1400_CROATIAN_NOPAD_AI_CI", "utf8", 3);
    charsets[2245] = new Collation(2245, "UCA1400_CROATIAN_NOPAD_AI_CS", "utf8", 3);
    charsets[2246] = new Collation(2246, "UCA1400_CROATIAN_NOPAD_AS_CI", "utf8", 3);
    charsets[2247] = new Collation(2247, "UCA1400_CROATIAN_NOPAD_AS_CS", "utf8", 3);
    charsets[2304] = new Collation(2304, "UCA1400_AI_CI", "utf8", 4);
    charsets[2305] = new Collation(2305, "UCA1400_AI_CS", "utf8", 4);
    charsets[2306] = new Collation(2306, "UCA1400_AS_CI", "utf8", 4);
    charsets[2307] = new Collation(2307, "UCA1400_AS_CS", "utf8", 4);
    charsets[2308] = new Collation(2308, "UCA1400_NOPAD_AI_CI", "utf8", 4);
    charsets[2309] = new Collation(2309, "UCA1400_NOPAD_AI_CS", "utf8", 4);
    charsets[2310] = new Collation(2310, "UCA1400_NOPAD_AS_CI", "utf8", 4);
    charsets[2311] = new Collation(2311, "UCA1400_NOPAD_AS_CS", "utf8", 4);
    charsets[2312] = new Collation(2312, "UCA1400_ICELANDIC_AI_CI", "utf8", 4);
    charsets[2313] = new Collation(2313, "UCA1400_ICELANDIC_AI_CS", "utf8", 4);
    charsets[2314] = new Collation(2314, "UCA1400_ICELANDIC_AS_CI", "utf8", 4);
    charsets[2315] = new Collation(2315, "UCA1400_ICELANDIC_AS_CS", "utf8", 4);
    charsets[2316] = new Collation(2316, "UCA1400_ICELANDIC_NOPAD_AI_CI", "utf8", 4);
    charsets[2317] = new Collation(2317, "UCA1400_ICELANDIC_NOPAD_AI_CS", "utf8", 4);
    charsets[2318] = new Collation(2318, "UCA1400_ICELANDIC_NOPAD_AS_CI", "utf8", 4);
    charsets[2319] = new Collation(2319, "UCA1400_ICELANDIC_NOPAD_AS_CS", "utf8", 4);
    charsets[2320] = new Collation(2320, "UCA1400_LATVIAN_AI_CI", "utf8", 4);
    charsets[2321] = new Collation(2321, "UCA1400_LATVIAN_AI_CS", "utf8", 4);
    charsets[2322] = new Collation(2322, "UCA1400_LATVIAN_AS_CI", "utf8", 4);
    charsets[2323] = new Collation(2323, "UCA1400_LATVIAN_AS_CS", "utf8", 4);
    charsets[2324] = new Collation(2324, "UCA1400_LATVIAN_NOPAD_AI_CI", "utf8", 4);
    charsets[2325] = new Collation(2325, "UCA1400_LATVIAN_NOPAD_AI_CS", "utf8", 4);
    charsets[2326] = new Collation(2326, "UCA1400_LATVIAN_NOPAD_AS_CI", "utf8", 4);
    charsets[2327] = new Collation(2327, "UCA1400_LATVIAN_NOPAD_AS_CS", "utf8", 4);
    charsets[2328] = new Collation(2328, "UCA1400_ROMANIAN_AI_CI", "utf8", 4);
    charsets[2329] = new Collation(2329, "UCA1400_ROMANIAN_AI_CS", "utf8", 4);
    charsets[2330] = new Collation(2330, "UCA1400_ROMANIAN_AS_CI", "utf8", 4);
    charsets[2331] = new Collation(2331, "UCA1400_ROMANIAN_AS_CS", "utf8", 4);
    charsets[2332] = new Collation(2332, "UCA1400_ROMANIAN_NOPAD_AI_CI", "utf8", 4);
    charsets[2333] = new Collation(2333, "UCA1400_ROMANIAN_NOPAD_AI_CS", "utf8", 4);
    charsets[2334] = new Collation(2334, "UCA1400_ROMANIAN_NOPAD_AS_CI", "utf8", 4);
    charsets[2335] = new Collation(2335, "UCA1400_ROMANIAN_NOPAD_AS_CS", "utf8", 4);
    charsets[2336] = new Collation(2336, "UCA1400_SLOVENIAN_AI_CI", "utf8", 4);
    charsets[2337] = new Collation(2337, "UCA1400_SLOVENIAN_AI_CS", "utf8", 4);
    charsets[2338] = new Collation(2338, "UCA1400_SLOVENIAN_AS_CI", "utf8", 4);
    charsets[2339] = new Collation(2339, "UCA1400_SLOVENIAN_AS_CS", "utf8", 4);
    charsets[2340] = new Collation(2340, "UCA1400_SLOVENIAN_NOPAD_AI_CI", "utf8", 4);
    charsets[2341] = new Collation(2341, "UCA1400_SLOVENIAN_NOPAD_AI_CS", "utf8", 4);
    charsets[2342] = new Collation(2342, "UCA1400_SLOVENIAN_NOPAD_AS_CI", "utf8", 4);
    charsets[2343] = new Collation(2343, "UCA1400_SLOVENIAN_NOPAD_AS_CS", "utf8", 4);
    charsets[2344] = new Collation(2344, "UCA1400_POLISH_AI_CI", "utf8", 4);
    charsets[2345] = new Collation(2345, "UCA1400_POLISH_AI_CS", "utf8", 4);
    charsets[2346] = new Collation(2346, "UCA1400_POLISH_AS_CI", "utf8", 4);
    charsets[2347] = new Collation(2347, "UCA1400_POLISH_AS_CS", "utf8", 4);
    charsets[2348] = new Collation(2348, "UCA1400_POLISH_NOPAD_AI_CI", "utf8", 4);
    charsets[2349] = new Collation(2349, "UCA1400_POLISH_NOPAD_AI_CS", "utf8", 4);
    charsets[2350] = new Collation(2350, "UCA1400_POLISH_NOPAD_AS_CI", "utf8", 4);
    charsets[2351] = new Collation(2351, "UCA1400_POLISH_NOPAD_AS_CS", "utf8", 4);
    charsets[2352] = new Collation(2352, "UCA1400_ESTONIAN_AI_CI", "utf8", 4);
    charsets[2353] = new Collation(2353, "UCA1400_ESTONIAN_AI_CS", "utf8", 4);
    charsets[2354] = new Collation(2354, "UCA1400_ESTONIAN_AS_CI", "utf8", 4);
    charsets[2355] = new Collation(2355, "UCA1400_ESTONIAN_AS_CS", "utf8", 4);
    charsets[2356] = new Collation(2356, "UCA1400_ESTONIAN_NOPAD_AI_CI", "utf8", 4);
    charsets[2357] = new Collation(2357, "UCA1400_ESTONIAN_NOPAD_AI_CS", "utf8", 4);
    charsets[2358] = new Collation(2358, "UCA1400_ESTONIAN_NOPAD_AS_CI", "utf8", 4);
    charsets[2359] = new Collation(2359, "UCA1400_ESTONIAN_NOPAD_AS_CS", "utf8", 4);
    charsets[2360] = new Collation(2360, "UCA1400_SPANISH_AI_CI", "utf8", 4);
    charsets[2361] = new Collation(2361, "UCA1400_SPANISH_AI_CS", "utf8", 4);
    charsets[2362] = new Collation(2362, "UCA1400_SPANISH_AS_CI", "utf8", 4);
    charsets[2363] = new Collation(2363, "UCA1400_SPANISH_AS_CS", "utf8", 4);
    charsets[2364] = new Collation(2364, "UCA1400_SPANISH_NOPAD_AI_CI", "utf8", 4);
    charsets[2365] = new Collation(2365, "UCA1400_SPANISH_NOPAD_AI_CS", "utf8", 4);
    charsets[2366] = new Collation(2366, "UCA1400_SPANISH_NOPAD_AS_CI", "utf8", 4);
    charsets[2367] = new Collation(2367, "UCA1400_SPANISH_NOPAD_AS_CS", "utf8", 4);
    charsets[2368] = new Collation(2368, "UCA1400_SWEDISH_AI_CI", "utf8", 4);
    charsets[2369] = new Collation(2369, "UCA1400_SWEDISH_AI_CS", "utf8", 4);
    charsets[2370] = new Collation(2370, "UCA1400_SWEDISH_AS_CI", "utf8", 4);
    charsets[2371] = new Collation(2371, "UCA1400_SWEDISH_AS_CS", "utf8", 4);
    charsets[2372] = new Collation(2372, "UCA1400_SWEDISH_NOPAD_AI_CI", "utf8", 4);
    charsets[2373] = new Collation(2373, "UCA1400_SWEDISH_NOPAD_AI_CS", "utf8", 4);
    charsets[2374] = new Collation(2374, "UCA1400_SWEDISH_NOPAD_AS_CI", "utf8", 4);
    charsets[2375] = new Collation(2375, "UCA1400_SWEDISH_NOPAD_AS_CS", "utf8", 4);
    charsets[2376] = new Collation(2376, "UCA1400_TURKISH_AI_CI", "utf8", 4);
    charsets[2377] = new Collation(2377, "UCA1400_TURKISH_AI_CS", "utf8", 4);
    charsets[2378] = new Collation(2378, "UCA1400_TURKISH_AS_CI", "utf8", 4);
    charsets[2379] = new Collation(2379, "UCA1400_TURKISH_AS_CS", "utf8", 4);
    charsets[2380] = new Collation(2380, "UCA1400_TURKISH_NOPAD_AI_CI", "utf8", 4);
    charsets[2381] = new Collation(2381, "UCA1400_TURKISH_NOPAD_AI_CS", "utf8", 4);
    charsets[2382] = new Collation(2382, "UCA1400_TURKISH_NOPAD_AS_CI", "utf8", 4);
    charsets[2383] = new Collation(2383, "UCA1400_TURKISH_NOPAD_AS_CS", "utf8", 4);
    charsets[2384] = new Collation(2384, "UCA1400_CZECH_AI_CI", "utf8", 4);
    charsets[2385] = new Collation(2385, "UCA1400_CZECH_AI_CS", "utf8", 4);
    charsets[2386] = new Collation(2386, "UCA1400_CZECH_AS_CI", "utf8", 4);
    charsets[2387] = new Collation(2387, "UCA1400_CZECH_AS_CS", "utf8", 4);
    charsets[2388] = new Collation(2388, "UCA1400_CZECH_NOPAD_AI_CI", "utf8", 4);
    charsets[2389] = new Collation(2389, "UCA1400_CZECH_NOPAD_AI_CS", "utf8", 4);
    charsets[2390] = new Collation(2390, "UCA1400_CZECH_NOPAD_AS_CI", "utf8", 4);
    charsets[2391] = new Collation(2391, "UCA1400_CZECH_NOPAD_AS_CS", "utf8", 4);
    charsets[2392] = new Collation(2392, "UCA1400_DANISH_AI_CI", "utf8", 4);
    charsets[2393] = new Collation(2393, "UCA1400_DANISH_AI_CS", "utf8", 4);
    charsets[2394] = new Collation(2394, "UCA1400_DANISH_AS_CI", "utf8", 4);
    charsets[2395] = new Collation(2395, "UCA1400_DANISH_AS_CS", "utf8", 4);
    charsets[2396] = new Collation(2396, "UCA1400_DANISH_NOPAD_AI_CI", "utf8", 4);
    charsets[2397] = new Collation(2397, "UCA1400_DANISH_NOPAD_AI_CS", "utf8", 4);
    charsets[2398] = new Collation(2398, "UCA1400_DANISH_NOPAD_AS_CI", "utf8", 4);
    charsets[2399] = new Collation(2399, "UCA1400_DANISH_NOPAD_AS_CS", "utf8", 4);
    charsets[2400] = new Collation(2400, "UCA1400_LITHUANIAN_AI_CI", "utf8", 4);
    charsets[2401] = new Collation(2401, "UCA1400_LITHUANIAN_AI_CS", "utf8", 4);
    charsets[2402] = new Collation(2402, "UCA1400_LITHUANIAN_AS_CI", "utf8", 4);
    charsets[2403] = new Collation(2403, "UCA1400_LITHUANIAN_AS_CS", "utf8", 4);
    charsets[2404] = new Collation(2404, "UCA1400_LITHUANIAN_NOPAD_AI_CI", "utf8", 4);
    charsets[2405] = new Collation(2405, "UCA1400_LITHUANIAN_NOPAD_AI_CS", "utf8", 4);
    charsets[2406] = new Collation(2406, "UCA1400_LITHUANIAN_NOPAD_AS_CI", "utf8", 4);
    charsets[2407] = new Collation(2407, "UCA1400_LITHUANIAN_NOPAD_AS_CS", "utf8", 4);
    charsets[2408] = new Collation(2408, "UCA1400_SLOVAK_AI_CI", "utf8", 4);
    charsets[2409] = new Collation(2409, "UCA1400_SLOVAK_AI_CS", "utf8", 4);
    charsets[2410] = new Collation(2410, "UCA1400_SLOVAK_AS_CI", "utf8", 4);
    charsets[2411] = new Collation(2411, "UCA1400_SLOVAK_AS_CS", "utf8", 4);
    charsets[2412] = new Collation(2412, "UCA1400_SLOVAK_NOPAD_AI_CI", "utf8", 4);
    charsets[2413] = new Collation(2413, "UCA1400_SLOVAK_NOPAD_AI_CS", "utf8", 4);
    charsets[2414] = new Collation(2414, "UCA1400_SLOVAK_NOPAD_AS_CI", "utf8", 4);
    charsets[2415] = new Collation(2415, "UCA1400_SLOVAK_NOPAD_AS_CS", "utf8", 4);
    charsets[2416] = new Collation(2416, "UCA1400_SPANISH2_AI_CI", "utf8", 4);
    charsets[2417] = new Collation(2417, "UCA1400_SPANISH2_AI_CS", "utf8", 4);
    charsets[2418] = new Collation(2418, "UCA1400_SPANISH2_AS_CI", "utf8", 4);
    charsets[2419] = new Collation(2419, "UCA1400_SPANISH2_AS_CS", "utf8", 4);
    charsets[2420] = new Collation(2420, "UCA1400_SPANISH2_NOPAD_AI_CI", "utf8", 4);
    charsets[2421] = new Collation(2421, "UCA1400_SPANISH2_NOPAD_AI_CS", "utf8", 4);
    charsets[2422] = new Collation(2422, "UCA1400_SPANISH2_NOPAD_AS_CI", "utf8", 4);
    charsets[2423] = new Collation(2423, "UCA1400_SPANISH2_NOPAD_AS_CS", "utf8", 4);
    charsets[2424] = new Collation(2424, "UCA1400_ROMAN_AI_CI", "utf8", 4);
    charsets[2425] = new Collation(2425, "UCA1400_ROMAN_AI_CS", "utf8", 4);
    charsets[2426] = new Collation(2426, "UCA1400_ROMAN_AS_CI", "utf8", 4);
    charsets[2427] = new Collation(2427, "UCA1400_ROMAN_AS_CS", "utf8", 4);
    charsets[2428] = new Collation(2428, "UCA1400_ROMAN_NOPAD_AI_CI", "utf8", 4);
    charsets[2429] = new Collation(2429, "UCA1400_ROMAN_NOPAD_AI_CS", "utf8", 4);
    charsets[2430] = new Collation(2430, "UCA1400_ROMAN_NOPAD_AS_CI", "utf8", 4);
    charsets[2431] = new Collation(2431, "UCA1400_ROMAN_NOPAD_AS_CS", "utf8", 4);
    charsets[2432] = new Collation(2432, "UCA1400_PERSIAN_AI_CI", "utf8", 4);
    charsets[2433] = new Collation(2433, "UCA1400_PERSIAN_AI_CS", "utf8", 4);
    charsets[2434] = new Collation(2434, "UCA1400_PERSIAN_AS_CI", "utf8", 4);
    charsets[2435] = new Collation(2435, "UCA1400_PERSIAN_AS_CS", "utf8", 4);
    charsets[2436] = new Collation(2436, "UCA1400_PERSIAN_NOPAD_AI_CI", "utf8", 4);
    charsets[2437] = new Collation(2437, "UCA1400_PERSIAN_NOPAD_AI_CS", "utf8", 4);
    charsets[2438] = new Collation(2438, "UCA1400_PERSIAN_NOPAD_AS_CI", "utf8", 4);
    charsets[2439] = new Collation(2439, "UCA1400_PERSIAN_NOPAD_AS_CS", "utf8", 4);
    charsets[2440] = new Collation(2440, "UCA1400_ESPERANTO_AI_CI", "utf8", 4);
    charsets[2441] = new Collation(2441, "UCA1400_ESPERANTO_AI_CS", "utf8", 4);
    charsets[2442] = new Collation(2442, "UCA1400_ESPERANTO_AS_CI", "utf8", 4);
    charsets[2443] = new Collation(2443, "UCA1400_ESPERANTO_AS_CS", "utf8", 4);
    charsets[2444] = new Collation(2444, "UCA1400_ESPERANTO_NOPAD_AI_CI", "utf8", 4);
    charsets[2445] = new Collation(2445, "UCA1400_ESPERANTO_NOPAD_AI_CS", "utf8", 4);
    charsets[2446] = new Collation(2446, "UCA1400_ESPERANTO_NOPAD_AS_CI", "utf8", 4);
    charsets[2447] = new Collation(2447, "UCA1400_ESPERANTO_NOPAD_AS_CS", "utf8", 4);
    charsets[2448] = new Collation(2448, "UCA1400_HUNGARIAN_AI_CI", "utf8", 4);
    charsets[2449] = new Collation(2449, "UCA1400_HUNGARIAN_AI_CS", "utf8", 4);
    charsets[2450] = new Collation(2450, "UCA1400_HUNGARIAN_AS_CI", "utf8", 4);
    charsets[2451] = new Collation(2451, "UCA1400_HUNGARIAN_AS_CS", "utf8", 4);
    charsets[2452] = new Collation(2452, "UCA1400_HUNGARIAN_NOPAD_AI_CI", "utf8", 4);
    charsets[2453] = new Collation(2453, "UCA1400_HUNGARIAN_NOPAD_AI_CS", "utf8", 4);
    charsets[2454] = new Collation(2454, "UCA1400_HUNGARIAN_NOPAD_AS_CI", "utf8", 4);
    charsets[2455] = new Collation(2455, "UCA1400_HUNGARIAN_NOPAD_AS_CS", "utf8", 4);
    charsets[2456] = new Collation(2456, "UCA1400_SINHALA_AI_CI", "utf8", 4);
    charsets[2457] = new Collation(2457, "UCA1400_SINHALA_AI_CS", "utf8", 4);
    charsets[2458] = new Collation(2458, "UCA1400_SINHALA_AS_CI", "utf8", 4);
    charsets[2459] = new Collation(2459, "UCA1400_SINHALA_AS_CS", "utf8", 4);
    charsets[2460] = new Collation(2460, "UCA1400_SINHALA_NOPAD_AI_CI", "utf8", 4);
    charsets[2461] = new Collation(2461, "UCA1400_SINHALA_NOPAD_AI_CS", "utf8", 4);
    charsets[2462] = new Collation(2462, "UCA1400_SINHALA_NOPAD_AS_CI", "utf8", 4);
    charsets[2463] = new Collation(2463, "UCA1400_SINHALA_NOPAD_AS_CS", "utf8", 4);
    charsets[2464] = new Collation(2464, "UCA1400_GERMAN2_AI_CI", "utf8", 4);
    charsets[2465] = new Collation(2465, "UCA1400_GERMAN2_AI_CS", "utf8", 4);
    charsets[2466] = new Collation(2466, "UCA1400_GERMAN2_AS_CI", "utf8", 4);
    charsets[2467] = new Collation(2467, "UCA1400_GERMAN2_AS_CS", "utf8", 4);
    charsets[2468] = new Collation(2468, "UCA1400_GERMAN2_NOPAD_AI_CI", "utf8", 4);
    charsets[2469] = new Collation(2469, "UCA1400_GERMAN2_NOPAD_AI_CS", "utf8", 4);
    charsets[2470] = new Collation(2470, "UCA1400_GERMAN2_NOPAD_AS_CI", "utf8", 4);
    charsets[2471] = new Collation(2471, "UCA1400_GERMAN2_NOPAD_AS_CS", "utf8", 4);
    charsets[2488] = new Collation(2488, "UCA1400_VIETNAMESE_AI_CI", "utf8", 4);
    charsets[2489] = new Collation(2489, "UCA1400_VIETNAMESE_AI_CS", "utf8", 4);
    charsets[2490] = new Collation(2490, "UCA1400_VIETNAMESE_AS_CI", "utf8", 4);
    charsets[2491] = new Collation(2491, "UCA1400_VIETNAMESE_AS_CS", "utf8", 4);
    charsets[2492] = new Collation(2492, "UCA1400_VIETNAMESE_NOPAD_AI_CI", "utf8", 4);
    charsets[2493] = new Collation(2493, "UCA1400_VIETNAMESE_NOPAD_AI_CS", "utf8", 4);
    charsets[2494] = new Collation(2494, "UCA1400_VIETNAMESE_NOPAD_AS_CI", "utf8", 4);
    charsets[2495] = new Collation(2495, "UCA1400_VIETNAMESE_NOPAD_AS_CS", "utf8", 4);
    charsets[2496] = new Collation(2496, "UCA1400_CROATIAN_AI_CI", "utf8", 4);
    charsets[2497] = new Collation(2497, "UCA1400_CROATIAN_AI_CS", "utf8", 4);
    charsets[2498] = new Collation(2498, "UCA1400_CROATIAN_AS_CI", "utf8", 4);
    charsets[2499] = new Collation(2499, "UCA1400_CROATIAN_AS_CS", "utf8", 4);
    charsets[2500] = new Collation(2500, "UCA1400_CROATIAN_NOPAD_AI_CI", "utf8", 4);
    charsets[2501] = new Collation(2501, "UCA1400_CROATIAN_NOPAD_AI_CS", "utf8", 4);
    charsets[2502] = new Collation(2502, "UCA1400_CROATIAN_NOPAD_AS_CI", "utf8", 4);
    charsets[2503] = new Collation(2503, "UCA1400_CROATIAN_NOPAD_AS_CS", "utf8", 4);
    charsets[2560] = new Collation(2560, "UCA1400_AI_CI", "ucs2", 2);
    charsets[2561] = new Collation(2561, "UCA1400_AI_CS", "ucs2", 2);
    charsets[2562] = new Collation(2562, "UCA1400_AS_CI", "ucs2", 2);
    charsets[2563] = new Collation(2563, "UCA1400_AS_CS", "ucs2", 2);
    charsets[2564] = new Collation(2564, "UCA1400_NOPAD_AI_CI", "ucs2", 2);
    charsets[2565] = new Collation(2565, "UCA1400_NOPAD_AI_CS", "ucs2", 2);
    charsets[2566] = new Collation(2566, "UCA1400_NOPAD_AS_CI", "ucs2", 2);
    charsets[2567] = new Collation(2567, "UCA1400_NOPAD_AS_CS", "ucs2", 2);
    charsets[2568] = new Collation(2568, "UCA1400_ICELANDIC_AI_CI", "ucs2", 2);
    charsets[2569] = new Collation(2569, "UCA1400_ICELANDIC_AI_CS", "ucs2", 2);
    charsets[2570] = new Collation(2570, "UCA1400_ICELANDIC_AS_CI", "ucs2", 2);
    charsets[2571] = new Collation(2571, "UCA1400_ICELANDIC_AS_CS", "ucs2", 2);
    charsets[2572] = new Collation(2572, "UCA1400_ICELANDIC_NOPAD_AI_CI", "ucs2", 2);
    charsets[2573] = new Collation(2573, "UCA1400_ICELANDIC_NOPAD_AI_CS", "ucs2", 2);
    charsets[2574] = new Collation(2574, "UCA1400_ICELANDIC_NOPAD_AS_CI", "ucs2", 2);
    charsets[2575] = new Collation(2575, "UCA1400_ICELANDIC_NOPAD_AS_CS", "ucs2", 2);
    charsets[2576] = new Collation(2576, "UCA1400_LATVIAN_AI_CI", "ucs2", 2);
    charsets[2577] = new Collation(2577, "UCA1400_LATVIAN_AI_CS", "ucs2", 2);
    charsets[2578] = new Collation(2578, "UCA1400_LATVIAN_AS_CI", "ucs2", 2);
    charsets[2579] = new Collation(2579, "UCA1400_LATVIAN_AS_CS", "ucs2", 2);
    charsets[2580] = new Collation(2580, "UCA1400_LATVIAN_NOPAD_AI_CI", "ucs2", 2);
    charsets[2581] = new Collation(2581, "UCA1400_LATVIAN_NOPAD_AI_CS", "ucs2", 2);
    charsets[2582] = new Collation(2582, "UCA1400_LATVIAN_NOPAD_AS_CI", "ucs2", 2);
    charsets[2583] = new Collation(2583, "UCA1400_LATVIAN_NOPAD_AS_CS", "ucs2", 2);
    charsets[2584] = new Collation(2584, "UCA1400_ROMANIAN_AI_CI", "ucs2", 2);
    charsets[2585] = new Collation(2585, "UCA1400_ROMANIAN_AI_CS", "ucs2", 2);
    charsets[2586] = new Collation(2586, "UCA1400_ROMANIAN_AS_CI", "ucs2", 2);
    charsets[2587] = new Collation(2587, "UCA1400_ROMANIAN_AS_CS", "ucs2", 2);
    charsets[2588] = new Collation(2588, "UCA1400_ROMANIAN_NOPAD_AI_CI", "ucs2", 2);
    charsets[2589] = new Collation(2589, "UCA1400_ROMANIAN_NOPAD_AI_CS", "ucs2", 2);
    charsets[2590] = new Collation(2590, "UCA1400_ROMANIAN_NOPAD_AS_CI", "ucs2", 2);
    charsets[2591] = new Collation(2591, "UCA1400_ROMANIAN_NOPAD_AS_CS", "ucs2", 2);
    charsets[2592] = new Collation(2592, "UCA1400_SLOVENIAN_AI_CI", "ucs2", 2);
    charsets[2593] = new Collation(2593, "UCA1400_SLOVENIAN_AI_CS", "ucs2", 2);
    charsets[2594] = new Collation(2594, "UCA1400_SLOVENIAN_AS_CI", "ucs2", 2);
    charsets[2595] = new Collation(2595, "UCA1400_SLOVENIAN_AS_CS", "ucs2", 2);
    charsets[2596] = new Collation(2596, "UCA1400_SLOVENIAN_NOPAD_AI_CI", "ucs2", 2);
    charsets[2597] = new Collation(2597, "UCA1400_SLOVENIAN_NOPAD_AI_CS", "ucs2", 2);
    charsets[2598] = new Collation(2598, "UCA1400_SLOVENIAN_NOPAD_AS_CI", "ucs2", 2);
    charsets[2599] = new Collation(2599, "UCA1400_SLOVENIAN_NOPAD_AS_CS", "ucs2", 2);
    charsets[2600] = new Collation(2600, "UCA1400_POLISH_AI_CI", "ucs2", 2);
    charsets[2601] = new Collation(2601, "UCA1400_POLISH_AI_CS", "ucs2", 2);
    charsets[2602] = new Collation(2602, "UCA1400_POLISH_AS_CI", "ucs2", 2);
    charsets[2603] = new Collation(2603, "UCA1400_POLISH_AS_CS", "ucs2", 2);
    charsets[2604] = new Collation(2604, "UCA1400_POLISH_NOPAD_AI_CI", "ucs2", 2);
    charsets[2605] = new Collation(2605, "UCA1400_POLISH_NOPAD_AI_CS", "ucs2", 2);
    charsets[2606] = new Collation(2606, "UCA1400_POLISH_NOPAD_AS_CI", "ucs2", 2);
    charsets[2607] = new Collation(2607, "UCA1400_POLISH_NOPAD_AS_CS", "ucs2", 2);
    charsets[2608] = new Collation(2608, "UCA1400_ESTONIAN_AI_CI", "ucs2", 2);
    charsets[2609] = new Collation(2609, "UCA1400_ESTONIAN_AI_CS", "ucs2", 2);
    charsets[2610] = new Collation(2610, "UCA1400_ESTONIAN_AS_CI", "ucs2", 2);
    charsets[2611] = new Collation(2611, "UCA1400_ESTONIAN_AS_CS", "ucs2", 2);
    charsets[2612] = new Collation(2612, "UCA1400_ESTONIAN_NOPAD_AI_CI", "ucs2", 2);
    charsets[2613] = new Collation(2613, "UCA1400_ESTONIAN_NOPAD_AI_CS", "ucs2", 2);
    charsets[2614] = new Collation(2614, "UCA1400_ESTONIAN_NOPAD_AS_CI", "ucs2", 2);
    charsets[2615] = new Collation(2615, "UCA1400_ESTONIAN_NOPAD_AS_CS", "ucs2", 2);
    charsets[2616] = new Collation(2616, "UCA1400_SPANISH_AI_CI", "ucs2", 2);
    charsets[2617] = new Collation(2617, "UCA1400_SPANISH_AI_CS", "ucs2", 2);
    charsets[2618] = new Collation(2618, "UCA1400_SPANISH_AS_CI", "ucs2", 2);
    charsets[2619] = new Collation(2619, "UCA1400_SPANISH_AS_CS", "ucs2", 2);
    charsets[2620] = new Collation(2620, "UCA1400_SPANISH_NOPAD_AI_CI", "ucs2", 2);
    charsets[2621] = new Collation(2621, "UCA1400_SPANISH_NOPAD_AI_CS", "ucs2", 2);
    charsets[2622] = new Collation(2622, "UCA1400_SPANISH_NOPAD_AS_CI", "ucs2", 2);
    charsets[2623] = new Collation(2623, "UCA1400_SPANISH_NOPAD_AS_CS", "ucs2", 2);
    charsets[2624] = new Collation(2624, "UCA1400_SWEDISH_AI_CI", "ucs2", 2);
    charsets[2625] = new Collation(2625, "UCA1400_SWEDISH_AI_CS", "ucs2", 2);
    charsets[2626] = new Collation(2626, "UCA1400_SWEDISH_AS_CI", "ucs2", 2);
    charsets[2627] = new Collation(2627, "UCA1400_SWEDISH_AS_CS", "ucs2", 2);
    charsets[2628] = new Collation(2628, "UCA1400_SWEDISH_NOPAD_AI_CI", "ucs2", 2);
    charsets[2629] = new Collation(2629, "UCA1400_SWEDISH_NOPAD_AI_CS", "ucs2", 2);
    charsets[2630] = new Collation(2630, "UCA1400_SWEDISH_NOPAD_AS_CI", "ucs2", 2);
    charsets[2631] = new Collation(2631, "UCA1400_SWEDISH_NOPAD_AS_CS", "ucs2", 2);
    charsets[2632] = new Collation(2632, "UCA1400_TURKISH_AI_CI", "ucs2", 2);
    charsets[2633] = new Collation(2633, "UCA1400_TURKISH_AI_CS", "ucs2", 2);
    charsets[2634] = new Collation(2634, "UCA1400_TURKISH_AS_CI", "ucs2", 2);
    charsets[2635] = new Collation(2635, "UCA1400_TURKISH_AS_CS", "ucs2", 2);
    charsets[2636] = new Collation(2636, "UCA1400_TURKISH_NOPAD_AI_CI", "ucs2", 2);
    charsets[2637] = new Collation(2637, "UCA1400_TURKISH_NOPAD_AI_CS", "ucs2", 2);
    charsets[2638] = new Collation(2638, "UCA1400_TURKISH_NOPAD_AS_CI", "ucs2", 2);
    charsets[2639] = new Collation(2639, "UCA1400_TURKISH_NOPAD_AS_CS", "ucs2", 2);
    charsets[2640] = new Collation(2640, "UCA1400_CZECH_AI_CI", "ucs2", 2);
    charsets[2641] = new Collation(2641, "UCA1400_CZECH_AI_CS", "ucs2", 2);
    charsets[2642] = new Collation(2642, "UCA1400_CZECH_AS_CI", "ucs2", 2);
    charsets[2643] = new Collation(2643, "UCA1400_CZECH_AS_CS", "ucs2", 2);
    charsets[2644] = new Collation(2644, "UCA1400_CZECH_NOPAD_AI_CI", "ucs2", 2);
    charsets[2645] = new Collation(2645, "UCA1400_CZECH_NOPAD_AI_CS", "ucs2", 2);
    charsets[2646] = new Collation(2646, "UCA1400_CZECH_NOPAD_AS_CI", "ucs2", 2);
    charsets[2647] = new Collation(2647, "UCA1400_CZECH_NOPAD_AS_CS", "ucs2", 2);
    charsets[2648] = new Collation(2648, "UCA1400_DANISH_AI_CI", "ucs2", 2);
    charsets[2649] = new Collation(2649, "UCA1400_DANISH_AI_CS", "ucs2", 2);
    charsets[2650] = new Collation(2650, "UCA1400_DANISH_AS_CI", "ucs2", 2);
    charsets[2651] = new Collation(2651, "UCA1400_DANISH_AS_CS", "ucs2", 2);
    charsets[2652] = new Collation(2652, "UCA1400_DANISH_NOPAD_AI_CI", "ucs2", 2);
    charsets[2653] = new Collation(2653, "UCA1400_DANISH_NOPAD_AI_CS", "ucs2", 2);
    charsets[2654] = new Collation(2654, "UCA1400_DANISH_NOPAD_AS_CI", "ucs2", 2);
    charsets[2655] = new Collation(2655, "UCA1400_DANISH_NOPAD_AS_CS", "ucs2", 2);
    charsets[2656] = new Collation(2656, "UCA1400_LITHUANIAN_AI_CI", "ucs2", 2);
    charsets[2657] = new Collation(2657, "UCA1400_LITHUANIAN_AI_CS", "ucs2", 2);
    charsets[2658] = new Collation(2658, "UCA1400_LITHUANIAN_AS_CI", "ucs2", 2);
    charsets[2659] = new Collation(2659, "UCA1400_LITHUANIAN_AS_CS", "ucs2", 2);
    charsets[2660] = new Collation(2660, "UCA1400_LITHUANIAN_NOPAD_AI_CI", "ucs2", 2);
    charsets[2661] = new Collation(2661, "UCA1400_LITHUANIAN_NOPAD_AI_CS", "ucs2", 2);
    charsets[2662] = new Collation(2662, "UCA1400_LITHUANIAN_NOPAD_AS_CI", "ucs2", 2);
    charsets[2663] = new Collation(2663, "UCA1400_LITHUANIAN_NOPAD_AS_CS", "ucs2", 2);
    charsets[2664] = new Collation(2664, "UCA1400_SLOVAK_AI_CI", "ucs2", 2);
    charsets[2665] = new Collation(2665, "UCA1400_SLOVAK_AI_CS", "ucs2", 2);
    charsets[2666] = new Collation(2666, "UCA1400_SLOVAK_AS_CI", "ucs2", 2);
    charsets[2667] = new Collation(2667, "UCA1400_SLOVAK_AS_CS", "ucs2", 2);
    charsets[2668] = new Collation(2668, "UCA1400_SLOVAK_NOPAD_AI_CI", "ucs2", 2);
    charsets[2669] = new Collation(2669, "UCA1400_SLOVAK_NOPAD_AI_CS", "ucs2", 2);
    charsets[2670] = new Collation(2670, "UCA1400_SLOVAK_NOPAD_AS_CI", "ucs2", 2);
    charsets[2671] = new Collation(2671, "UCA1400_SLOVAK_NOPAD_AS_CS", "ucs2", 2);
    charsets[2672] = new Collation(2672, "UCA1400_SPANISH2_AI_CI", "ucs2", 2);
    charsets[2673] = new Collation(2673, "UCA1400_SPANISH2_AI_CS", "ucs2", 2);
    charsets[2674] = new Collation(2674, "UCA1400_SPANISH2_AS_CI", "ucs2", 2);
    charsets[2675] = new Collation(2675, "UCA1400_SPANISH2_AS_CS", "ucs2", 2);
    charsets[2676] = new Collation(2676, "UCA1400_SPANISH2_NOPAD_AI_CI", "ucs2", 2);
    charsets[2677] = new Collation(2677, "UCA1400_SPANISH2_NOPAD_AI_CS", "ucs2", 2);
    charsets[2678] = new Collation(2678, "UCA1400_SPANISH2_NOPAD_AS_CI", "ucs2", 2);
    charsets[2679] = new Collation(2679, "UCA1400_SPANISH2_NOPAD_AS_CS", "ucs2", 2);
    charsets[2680] = new Collation(2680, "UCA1400_ROMAN_AI_CI", "ucs2", 2);
    charsets[2681] = new Collation(2681, "UCA1400_ROMAN_AI_CS", "ucs2", 2);
    charsets[2682] = new Collation(2682, "UCA1400_ROMAN_AS_CI", "ucs2", 2);
    charsets[2683] = new Collation(2683, "UCA1400_ROMAN_AS_CS", "ucs2", 2);
    charsets[2684] = new Collation(2684, "UCA1400_ROMAN_NOPAD_AI_CI", "ucs2", 2);
    charsets[2685] = new Collation(2685, "UCA1400_ROMAN_NOPAD_AI_CS", "ucs2", 2);
    charsets[2686] = new Collation(2686, "UCA1400_ROMAN_NOPAD_AS_CI", "ucs2", 2);
    charsets[2687] = new Collation(2687, "UCA1400_ROMAN_NOPAD_AS_CS", "ucs2", 2);
    charsets[2688] = new Collation(2688, "UCA1400_PERSIAN_AI_CI", "ucs2", 2);
    charsets[2689] = new Collation(2689, "UCA1400_PERSIAN_AI_CS", "ucs2", 2);
    charsets[2690] = new Collation(2690, "UCA1400_PERSIAN_AS_CI", "ucs2", 2);
    charsets[2691] = new Collation(2691, "UCA1400_PERSIAN_AS_CS", "ucs2", 2);
    charsets[2692] = new Collation(2692, "UCA1400_PERSIAN_NOPAD_AI_CI", "ucs2", 2);
    charsets[2693] = new Collation(2693, "UCA1400_PERSIAN_NOPAD_AI_CS", "ucs2", 2);
    charsets[2694] = new Collation(2694, "UCA1400_PERSIAN_NOPAD_AS_CI", "ucs2", 2);
    charsets[2695] = new Collation(2695, "UCA1400_PERSIAN_NOPAD_AS_CS", "ucs2", 2);
    charsets[2696] = new Collation(2696, "UCA1400_ESPERANTO_AI_CI", "ucs2", 2);
    charsets[2697] = new Collation(2697, "UCA1400_ESPERANTO_AI_CS", "ucs2", 2);
    charsets[2698] = new Collation(2698, "UCA1400_ESPERANTO_AS_CI", "ucs2", 2);
    charsets[2699] = new Collation(2699, "UCA1400_ESPERANTO_AS_CS", "ucs2", 2);
    charsets[2700] = new Collation(2700, "UCA1400_ESPERANTO_NOPAD_AI_CI", "ucs2", 2);
    charsets[2701] = new Collation(2701, "UCA1400_ESPERANTO_NOPAD_AI_CS", "ucs2", 2);
    charsets[2702] = new Collation(2702, "UCA1400_ESPERANTO_NOPAD_AS_CI", "ucs2", 2);
    charsets[2703] = new Collation(2703, "UCA1400_ESPERANTO_NOPAD_AS_CS", "ucs2", 2);
    charsets[2704] = new Collation(2704, "UCA1400_HUNGARIAN_AI_CI", "ucs2", 2);
    charsets[2705] = new Collation(2705, "UCA1400_HUNGARIAN_AI_CS", "ucs2", 2);
    charsets[2706] = new Collation(2706, "UCA1400_HUNGARIAN_AS_CI", "ucs2", 2);
    charsets[2707] = new Collation(2707, "UCA1400_HUNGARIAN_AS_CS", "ucs2", 2);
    charsets[2708] = new Collation(2708, "UCA1400_HUNGARIAN_NOPAD_AI_CI", "ucs2", 2);
    charsets[2709] = new Collation(2709, "UCA1400_HUNGARIAN_NOPAD_AI_CS", "ucs2", 2);
    charsets[2710] = new Collation(2710, "UCA1400_HUNGARIAN_NOPAD_AS_CI", "ucs2", 2);
    charsets[2711] = new Collation(2711, "UCA1400_HUNGARIAN_NOPAD_AS_CS", "ucs2", 2);
    charsets[2712] = new Collation(2712, "UCA1400_SINHALA_AI_CI", "ucs2", 2);
    charsets[2713] = new Collation(2713, "UCA1400_SINHALA_AI_CS", "ucs2", 2);
    charsets[2714] = new Collation(2714, "UCA1400_SINHALA_AS_CI", "ucs2", 2);
    charsets[2715] = new Collation(2715, "UCA1400_SINHALA_AS_CS", "ucs2", 2);
    charsets[2716] = new Collation(2716, "UCA1400_SINHALA_NOPAD_AI_CI", "ucs2", 2);
    charsets[2717] = new Collation(2717, "UCA1400_SINHALA_NOPAD_AI_CS", "ucs2", 2);
    charsets[2718] = new Collation(2718, "UCA1400_SINHALA_NOPAD_AS_CI", "ucs2", 2);
    charsets[2719] = new Collation(2719, "UCA1400_SINHALA_NOPAD_AS_CS", "ucs2", 2);
    charsets[2720] = new Collation(2720, "UCA1400_GERMAN2_AI_CI", "ucs2", 2);
    charsets[2721] = new Collation(2721, "UCA1400_GERMAN2_AI_CS", "ucs2", 2);
    charsets[2722] = new Collation(2722, "UCA1400_GERMAN2_AS_CI", "ucs2", 2);
    charsets[2723] = new Collation(2723, "UCA1400_GERMAN2_AS_CS", "ucs2", 2);
    charsets[2724] = new Collation(2724, "UCA1400_GERMAN2_NOPAD_AI_CI", "ucs2", 2);
    charsets[2725] = new Collation(2725, "UCA1400_GERMAN2_NOPAD_AI_CS", "ucs2", 2);
    charsets[2726] = new Collation(2726, "UCA1400_GERMAN2_NOPAD_AS_CI", "ucs2", 2);
    charsets[2727] = new Collation(2727, "UCA1400_GERMAN2_NOPAD_AS_CS", "ucs2", 2);
    charsets[2744] = new Collation(2744, "UCA1400_VIETNAMESE_AI_CI", "ucs2", 2);
    charsets[2745] = new Collation(2745, "UCA1400_VIETNAMESE_AI_CS", "ucs2", 2);
    charsets[2746] = new Collation(2746, "UCA1400_VIETNAMESE_AS_CI", "ucs2", 2);
    charsets[2747] = new Collation(2747, "UCA1400_VIETNAMESE_AS_CS", "ucs2", 2);
    charsets[2748] = new Collation(2748, "UCA1400_VIETNAMESE_NOPAD_AI_CI", "ucs2", 2);
    charsets[2749] = new Collation(2749, "UCA1400_VIETNAMESE_NOPAD_AI_CS", "ucs2", 2);
    charsets[2750] = new Collation(2750, "UCA1400_VIETNAMESE_NOPAD_AS_CI", "ucs2", 2);
    charsets[2751] = new Collation(2751, "UCA1400_VIETNAMESE_NOPAD_AS_CS", "ucs2", 2);
    charsets[2752] = new Collation(2752, "UCA1400_CROATIAN_AI_CI", "ucs2", 2);
    charsets[2753] = new Collation(2753, "UCA1400_CROATIAN_AI_CS", "ucs2", 2);
    charsets[2754] = new Collation(2754, "UCA1400_CROATIAN_AS_CI", "ucs2", 2);
    charsets[2755] = new Collation(2755, "UCA1400_CROATIAN_AS_CS", "ucs2", 2);
    charsets[2756] = new Collation(2756, "UCA1400_CROATIAN_NOPAD_AI_CI", "ucs2", 2);
    charsets[2757] = new Collation(2757, "UCA1400_CROATIAN_NOPAD_AI_CS", "ucs2", 2);
    charsets[2758] = new Collation(2758, "UCA1400_CROATIAN_NOPAD_AS_CI", "ucs2", 2);
    charsets[2759] = new Collation(2759, "UCA1400_CROATIAN_NOPAD_AS_CS", "ucs2", 2);
    charsets[2816] = new Collation(2816, "UCA1400_AI_CI", "utf16", 4);
    charsets[2817] = new Collation(2817, "UCA1400_AI_CS", "utf16", 4);
    charsets[2818] = new Collation(2818, "UCA1400_AS_CI", "utf16", 4);
    charsets[2819] = new Collation(2819, "UCA1400_AS_CS", "utf16", 4);
    charsets[2820] = new Collation(2820, "UCA1400_NOPAD_AI_CI", "utf16", 4);
    charsets[2821] = new Collation(2821, "UCA1400_NOPAD_AI_CS", "utf16", 4);
    charsets[2822] = new Collation(2822, "UCA1400_NOPAD_AS_CI", "utf16", 4);
    charsets[2823] = new Collation(2823, "UCA1400_NOPAD_AS_CS", "utf16", 4);
    charsets[2824] = new Collation(2824, "UCA1400_ICELANDIC_AI_CI", "utf16", 4);
    charsets[2825] = new Collation(2825, "UCA1400_ICELANDIC_AI_CS", "utf16", 4);
    charsets[2826] = new Collation(2826, "UCA1400_ICELANDIC_AS_CI", "utf16", 4);
    charsets[2827] = new Collation(2827, "UCA1400_ICELANDIC_AS_CS", "utf16", 4);
    charsets[2828] = new Collation(2828, "UCA1400_ICELANDIC_NOPAD_AI_CI", "utf16", 4);
    charsets[2829] = new Collation(2829, "UCA1400_ICELANDIC_NOPAD_AI_CS", "utf16", 4);
    charsets[2830] = new Collation(2830, "UCA1400_ICELANDIC_NOPAD_AS_CI", "utf16", 4);
    charsets[2831] = new Collation(2831, "UCA1400_ICELANDIC_NOPAD_AS_CS", "utf16", 4);
    charsets[2832] = new Collation(2832, "UCA1400_LATVIAN_AI_CI", "utf16", 4);
    charsets[2833] = new Collation(2833, "UCA1400_LATVIAN_AI_CS", "utf16", 4);
    charsets[2834] = new Collation(2834, "UCA1400_LATVIAN_AS_CI", "utf16", 4);
    charsets[2835] = new Collation(2835, "UCA1400_LATVIAN_AS_CS", "utf16", 4);
    charsets[2836] = new Collation(2836, "UCA1400_LATVIAN_NOPAD_AI_CI", "utf16", 4);
    charsets[2837] = new Collation(2837, "UCA1400_LATVIAN_NOPAD_AI_CS", "utf16", 4);
    charsets[2838] = new Collation(2838, "UCA1400_LATVIAN_NOPAD_AS_CI", "utf16", 4);
    charsets[2839] = new Collation(2839, "UCA1400_LATVIAN_NOPAD_AS_CS", "utf16", 4);
    charsets[2840] = new Collation(2840, "UCA1400_ROMANIAN_AI_CI", "utf16", 4);
    charsets[2841] = new Collation(2841, "UCA1400_ROMANIAN_AI_CS", "utf16", 4);
    charsets[2842] = new Collation(2842, "UCA1400_ROMANIAN_AS_CI", "utf16", 4);
    charsets[2843] = new Collation(2843, "UCA1400_ROMANIAN_AS_CS", "utf16", 4);
    charsets[2844] = new Collation(2844, "UCA1400_ROMANIAN_NOPAD_AI_CI", "utf16", 4);
    charsets[2845] = new Collation(2845, "UCA1400_ROMANIAN_NOPAD_AI_CS", "utf16", 4);
    charsets[2846] = new Collation(2846, "UCA1400_ROMANIAN_NOPAD_AS_CI", "utf16", 4);
    charsets[2847] = new Collation(2847, "UCA1400_ROMANIAN_NOPAD_AS_CS", "utf16", 4);
    charsets[2848] = new Collation(2848, "UCA1400_SLOVENIAN_AI_CI", "utf16", 4);
    charsets[2849] = new Collation(2849, "UCA1400_SLOVENIAN_AI_CS", "utf16", 4);
    charsets[2850] = new Collation(2850, "UCA1400_SLOVENIAN_AS_CI", "utf16", 4);
    charsets[2851] = new Collation(2851, "UCA1400_SLOVENIAN_AS_CS", "utf16", 4);
    charsets[2852] = new Collation(2852, "UCA1400_SLOVENIAN_NOPAD_AI_CI", "utf16", 4);
    charsets[2853] = new Collation(2853, "UCA1400_SLOVENIAN_NOPAD_AI_CS", "utf16", 4);
    charsets[2854] = new Collation(2854, "UCA1400_SLOVENIAN_NOPAD_AS_CI", "utf16", 4);
    charsets[2855] = new Collation(2855, "UCA1400_SLOVENIAN_NOPAD_AS_CS", "utf16", 4);
    charsets[2856] = new Collation(2856, "UCA1400_POLISH_AI_CI", "utf16", 4);
    charsets[2857] = new Collation(2857, "UCA1400_POLISH_AI_CS", "utf16", 4);
    charsets[2858] = new Collation(2858, "UCA1400_POLISH_AS_CI", "utf16", 4);
    charsets[2859] = new Collation(2859, "UCA1400_POLISH_AS_CS", "utf16", 4);
    charsets[2860] = new Collation(2860, "UCA1400_POLISH_NOPAD_AI_CI", "utf16", 4);
    charsets[2861] = new Collation(2861, "UCA1400_POLISH_NOPAD_AI_CS", "utf16", 4);
    charsets[2862] = new Collation(2862, "UCA1400_POLISH_NOPAD_AS_CI", "utf16", 4);
    charsets[2863] = new Collation(2863, "UCA1400_POLISH_NOPAD_AS_CS", "utf16", 4);
    charsets[2864] = new Collation(2864, "UCA1400_ESTONIAN_AI_CI", "utf16", 4);
    charsets[2865] = new Collation(2865, "UCA1400_ESTONIAN_AI_CS", "utf16", 4);
    charsets[2866] = new Collation(2866, "UCA1400_ESTONIAN_AS_CI", "utf16", 4);
    charsets[2867] = new Collation(2867, "UCA1400_ESTONIAN_AS_CS", "utf16", 4);
    charsets[2868] = new Collation(2868, "UCA1400_ESTONIAN_NOPAD_AI_CI", "utf16", 4);
    charsets[2869] = new Collation(2869, "UCA1400_ESTONIAN_NOPAD_AI_CS", "utf16", 4);
    charsets[2870] = new Collation(2870, "UCA1400_ESTONIAN_NOPAD_AS_CI", "utf16", 4);
    charsets[2871] = new Collation(2871, "UCA1400_ESTONIAN_NOPAD_AS_CS", "utf16", 4);
    charsets[2872] = new Collation(2872, "UCA1400_SPANISH_AI_CI", "utf16", 4);
    charsets[2873] = new Collation(2873, "UCA1400_SPANISH_AI_CS", "utf16", 4);
    charsets[2874] = new Collation(2874, "UCA1400_SPANISH_AS_CI", "utf16", 4);
    charsets[2875] = new Collation(2875, "UCA1400_SPANISH_AS_CS", "utf16", 4);
    charsets[2876] = new Collation(2876, "UCA1400_SPANISH_NOPAD_AI_CI", "utf16", 4);
    charsets[2877] = new Collation(2877, "UCA1400_SPANISH_NOPAD_AI_CS", "utf16", 4);
    charsets[2878] = new Collation(2878, "UCA1400_SPANISH_NOPAD_AS_CI", "utf16", 4);
    charsets[2879] = new Collation(2879, "UCA1400_SPANISH_NOPAD_AS_CS", "utf16", 4);
    charsets[2880] = new Collation(2880, "UCA1400_SWEDISH_AI_CI", "utf16", 4);
    charsets[2881] = new Collation(2881, "UCA1400_SWEDISH_AI_CS", "utf16", 4);
    charsets[2882] = new Collation(2882, "UCA1400_SWEDISH_AS_CI", "utf16", 4);
    charsets[2883] = new Collation(2883, "UCA1400_SWEDISH_AS_CS", "utf16", 4);
    charsets[2884] = new Collation(2884, "UCA1400_SWEDISH_NOPAD_AI_CI", "utf16", 4);
    charsets[2885] = new Collation(2885, "UCA1400_SWEDISH_NOPAD_AI_CS", "utf16", 4);
    charsets[2886] = new Collation(2886, "UCA1400_SWEDISH_NOPAD_AS_CI", "utf16", 4);
    charsets[2887] = new Collation(2887, "UCA1400_SWEDISH_NOPAD_AS_CS", "utf16", 4);
    charsets[2888] = new Collation(2888, "UCA1400_TURKISH_AI_CI", "utf16", 4);
    charsets[2889] = new Collation(2889, "UCA1400_TURKISH_AI_CS", "utf16", 4);
    charsets[2890] = new Collation(2890, "UCA1400_TURKISH_AS_CI", "utf16", 4);
    charsets[2891] = new Collation(2891, "UCA1400_TURKISH_AS_CS", "utf16", 4);
    charsets[2892] = new Collation(2892, "UCA1400_TURKISH_NOPAD_AI_CI", "utf16", 4);
    charsets[2893] = new Collation(2893, "UCA1400_TURKISH_NOPAD_AI_CS", "utf16", 4);
    charsets[2894] = new Collation(2894, "UCA1400_TURKISH_NOPAD_AS_CI", "utf16", 4);
    charsets[2895] = new Collation(2895, "UCA1400_TURKISH_NOPAD_AS_CS", "utf16", 4);
    charsets[2896] = new Collation(2896, "UCA1400_CZECH_AI_CI", "utf16", 4);
    charsets[2897] = new Collation(2897, "UCA1400_CZECH_AI_CS", "utf16", 4);
    charsets[2898] = new Collation(2898, "UCA1400_CZECH_AS_CI", "utf16", 4);
    charsets[2899] = new Collation(2899, "UCA1400_CZECH_AS_CS", "utf16", 4);
    charsets[2900] = new Collation(2900, "UCA1400_CZECH_NOPAD_AI_CI", "utf16", 4);
    charsets[2901] = new Collation(2901, "UCA1400_CZECH_NOPAD_AI_CS", "utf16", 4);
    charsets[2902] = new Collation(2902, "UCA1400_CZECH_NOPAD_AS_CI", "utf16", 4);
    charsets[2903] = new Collation(2903, "UCA1400_CZECH_NOPAD_AS_CS", "utf16", 4);
    charsets[2904] = new Collation(2904, "UCA1400_DANISH_AI_CI", "utf16", 4);
    charsets[2905] = new Collation(2905, "UCA1400_DANISH_AI_CS", "utf16", 4);
    charsets[2906] = new Collation(2906, "UCA1400_DANISH_AS_CI", "utf16", 4);
    charsets[2907] = new Collation(2907, "UCA1400_DANISH_AS_CS", "utf16", 4);
    charsets[2908] = new Collation(2908, "UCA1400_DANISH_NOPAD_AI_CI", "utf16", 4);
    charsets[2909] = new Collation(2909, "UCA1400_DANISH_NOPAD_AI_CS", "utf16", 4);
    charsets[2910] = new Collation(2910, "UCA1400_DANISH_NOPAD_AS_CI", "utf16", 4);
    charsets[2911] = new Collation(2911, "UCA1400_DANISH_NOPAD_AS_CS", "utf16", 4);
    charsets[2912] = new Collation(2912, "UCA1400_LITHUANIAN_AI_CI", "utf16", 4);
    charsets[2913] = new Collation(2913, "UCA1400_LITHUANIAN_AI_CS", "utf16", 4);
    charsets[2914] = new Collation(2914, "UCA1400_LITHUANIAN_AS_CI", "utf16", 4);
    charsets[2915] = new Collation(2915, "UCA1400_LITHUANIAN_AS_CS", "utf16", 4);
    charsets[2916] = new Collation(2916, "UCA1400_LITHUANIAN_NOPAD_AI_CI", "utf16", 4);
    charsets[2917] = new Collation(2917, "UCA1400_LITHUANIAN_NOPAD_AI_CS", "utf16", 4);
    charsets[2918] = new Collation(2918, "UCA1400_LITHUANIAN_NOPAD_AS_CI", "utf16", 4);
    charsets[2919] = new Collation(2919, "UCA1400_LITHUANIAN_NOPAD_AS_CS", "utf16", 4);
    charsets[2920] = new Collation(2920, "UCA1400_SLOVAK_AI_CI", "utf16", 4);
    charsets[2921] = new Collation(2921, "UCA1400_SLOVAK_AI_CS", "utf16", 4);
    charsets[2922] = new Collation(2922, "UCA1400_SLOVAK_AS_CI", "utf16", 4);
    charsets[2923] = new Collation(2923, "UCA1400_SLOVAK_AS_CS", "utf16", 4);
    charsets[2924] = new Collation(2924, "UCA1400_SLOVAK_NOPAD_AI_CI", "utf16", 4);
    charsets[2925] = new Collation(2925, "UCA1400_SLOVAK_NOPAD_AI_CS", "utf16", 4);
    charsets[2926] = new Collation(2926, "UCA1400_SLOVAK_NOPAD_AS_CI", "utf16", 4);
    charsets[2927] = new Collation(2927, "UCA1400_SLOVAK_NOPAD_AS_CS", "utf16", 4);
    charsets[2928] = new Collation(2928, "UCA1400_SPANISH2_AI_CI", "utf16", 4);
    charsets[2929] = new Collation(2929, "UCA1400_SPANISH2_AI_CS", "utf16", 4);
    charsets[2930] = new Collation(2930, "UCA1400_SPANISH2_AS_CI", "utf16", 4);
    charsets[2931] = new Collation(2931, "UCA1400_SPANISH2_AS_CS", "utf16", 4);
    charsets[2932] = new Collation(2932, "UCA1400_SPANISH2_NOPAD_AI_CI", "utf16", 4);
    charsets[2933] = new Collation(2933, "UCA1400_SPANISH2_NOPAD_AI_CS", "utf16", 4);
    charsets[2934] = new Collation(2934, "UCA1400_SPANISH2_NOPAD_AS_CI", "utf16", 4);
    charsets[2935] = new Collation(2935, "UCA1400_SPANISH2_NOPAD_AS_CS", "utf16", 4);
    charsets[2936] = new Collation(2936, "UCA1400_ROMAN_AI_CI", "utf16", 4);
    charsets[2937] = new Collation(2937, "UCA1400_ROMAN_AI_CS", "utf16", 4);
    charsets[2938] = new Collation(2938, "UCA1400_ROMAN_AS_CI", "utf16", 4);
    charsets[2939] = new Collation(2939, "UCA1400_ROMAN_AS_CS", "utf16", 4);
    charsets[2940] = new Collation(2940, "UCA1400_ROMAN_NOPAD_AI_CI", "utf16", 4);
    charsets[2941] = new Collation(2941, "UCA1400_ROMAN_NOPAD_AI_CS", "utf16", 4);
    charsets[2942] = new Collation(2942, "UCA1400_ROMAN_NOPAD_AS_CI", "utf16", 4);
    charsets[2943] = new Collation(2943, "UCA1400_ROMAN_NOPAD_AS_CS", "utf16", 4);
    charsets[2944] = new Collation(2944, "UCA1400_PERSIAN_AI_CI", "utf16", 4);
    charsets[2945] = new Collation(2945, "UCA1400_PERSIAN_AI_CS", "utf16", 4);
    charsets[2946] = new Collation(2946, "UCA1400_PERSIAN_AS_CI", "utf16", 4);
    charsets[2947] = new Collation(2947, "UCA1400_PERSIAN_AS_CS", "utf16", 4);
    charsets[2948] = new Collation(2948, "UCA1400_PERSIAN_NOPAD_AI_CI", "utf16", 4);
    charsets[2949] = new Collation(2949, "UCA1400_PERSIAN_NOPAD_AI_CS", "utf16", 4);
    charsets[2950] = new Collation(2950, "UCA1400_PERSIAN_NOPAD_AS_CI", "utf16", 4);
    charsets[2951] = new Collation(2951, "UCA1400_PERSIAN_NOPAD_AS_CS", "utf16", 4);
    charsets[2952] = new Collation(2952, "UCA1400_ESPERANTO_AI_CI", "utf16", 4);
    charsets[2953] = new Collation(2953, "UCA1400_ESPERANTO_AI_CS", "utf16", 4);
    charsets[2954] = new Collation(2954, "UCA1400_ESPERANTO_AS_CI", "utf16", 4);
    charsets[2955] = new Collation(2955, "UCA1400_ESPERANTO_AS_CS", "utf16", 4);
    charsets[2956] = new Collation(2956, "UCA1400_ESPERANTO_NOPAD_AI_CI", "utf16", 4);
    charsets[2957] = new Collation(2957, "UCA1400_ESPERANTO_NOPAD_AI_CS", "utf16", 4);
    charsets[2958] = new Collation(2958, "UCA1400_ESPERANTO_NOPAD_AS_CI", "utf16", 4);
    charsets[2959] = new Collation(2959, "UCA1400_ESPERANTO_NOPAD_AS_CS", "utf16", 4);
    charsets[2960] = new Collation(2960, "UCA1400_HUNGARIAN_AI_CI", "utf16", 4);
    charsets[2961] = new Collation(2961, "UCA1400_HUNGARIAN_AI_CS", "utf16", 4);
    charsets[2962] = new Collation(2962, "UCA1400_HUNGARIAN_AS_CI", "utf16", 4);
    charsets[2963] = new Collation(2963, "UCA1400_HUNGARIAN_AS_CS", "utf16", 4);
    charsets[2964] = new Collation(2964, "UCA1400_HUNGARIAN_NOPAD_AI_CI", "utf16", 4);
    charsets[2965] = new Collation(2965, "UCA1400_HUNGARIAN_NOPAD_AI_CS", "utf16", 4);
    charsets[2966] = new Collation(2966, "UCA1400_HUNGARIAN_NOPAD_AS_CI", "utf16", 4);
    charsets[2967] = new Collation(2967, "UCA1400_HUNGARIAN_NOPAD_AS_CS", "utf16", 4);
    charsets[2968] = new Collation(2968, "UCA1400_SINHALA_AI_CI", "utf16", 4);
    charsets[2969] = new Collation(2969, "UCA1400_SINHALA_AI_CS", "utf16", 4);
    charsets[2970] = new Collation(2970, "UCA1400_SINHALA_AS_CI", "utf16", 4);
    charsets[2971] = new Collation(2971, "UCA1400_SINHALA_AS_CS", "utf16", 4);
    charsets[2972] = new Collation(2972, "UCA1400_SINHALA_NOPAD_AI_CI", "utf16", 4);
    charsets[2973] = new Collation(2973, "UCA1400_SINHALA_NOPAD_AI_CS", "utf16", 4);
    charsets[2974] = new Collation(2974, "UCA1400_SINHALA_NOPAD_AS_CI", "utf16", 4);
    charsets[2975] = new Collation(2975, "UCA1400_SINHALA_NOPAD_AS_CS", "utf16", 4);
    charsets[2976] = new Collation(2976, "UCA1400_GERMAN2_AI_CI", "utf16", 4);
    charsets[2977] = new Collation(2977, "UCA1400_GERMAN2_AI_CS", "utf16", 4);
    charsets[2978] = new Collation(2978, "UCA1400_GERMAN2_AS_CI", "utf16", 4);
    charsets[2979] = new Collation(2979, "UCA1400_GERMAN2_AS_CS", "utf16", 4);
    charsets[2980] = new Collation(2980, "UCA1400_GERMAN2_NOPAD_AI_CI", "utf16", 4);
    charsets[2981] = new Collation(2981, "UCA1400_GERMAN2_NOPAD_AI_CS", "utf16", 4);
    charsets[2982] = new Collation(2982, "UCA1400_GERMAN2_NOPAD_AS_CI", "utf16", 4);
    charsets[2983] = new Collation(2983, "UCA1400_GERMAN2_NOPAD_AS_CS", "utf16", 4);
    charsets[3e3] = new Collation(3e3, "UCA1400_VIETNAMESE_AI_CI", "utf16", 4);
    charsets[3001] = new Collation(3001, "UCA1400_VIETNAMESE_AI_CS", "utf16", 4);
    charsets[3002] = new Collation(3002, "UCA1400_VIETNAMESE_AS_CI", "utf16", 4);
    charsets[3003] = new Collation(3003, "UCA1400_VIETNAMESE_AS_CS", "utf16", 4);
    charsets[3004] = new Collation(3004, "UCA1400_VIETNAMESE_NOPAD_AI_CI", "utf16", 4);
    charsets[3005] = new Collation(3005, "UCA1400_VIETNAMESE_NOPAD_AI_CS", "utf16", 4);
    charsets[3006] = new Collation(3006, "UCA1400_VIETNAMESE_NOPAD_AS_CI", "utf16", 4);
    charsets[3007] = new Collation(3007, "UCA1400_VIETNAMESE_NOPAD_AS_CS", "utf16", 4);
    charsets[3008] = new Collation(3008, "UCA1400_CROATIAN_AI_CI", "utf16", 4);
    charsets[3009] = new Collation(3009, "UCA1400_CROATIAN_AI_CS", "utf16", 4);
    charsets[3010] = new Collation(3010, "UCA1400_CROATIAN_AS_CI", "utf16", 4);
    charsets[3011] = new Collation(3011, "UCA1400_CROATIAN_AS_CS", "utf16", 4);
    charsets[3012] = new Collation(3012, "UCA1400_CROATIAN_NOPAD_AI_CI", "utf16", 4);
    charsets[3013] = new Collation(3013, "UCA1400_CROATIAN_NOPAD_AI_CS", "utf16", 4);
    charsets[3014] = new Collation(3014, "UCA1400_CROATIAN_NOPAD_AS_CI", "utf16", 4);
    charsets[3015] = new Collation(3015, "UCA1400_CROATIAN_NOPAD_AS_CS", "utf16", 4);
    charsets[3072] = new Collation(3072, "UCA1400_AI_CI", "utf32", 4);
    charsets[3073] = new Collation(3073, "UCA1400_AI_CS", "utf32", 4);
    charsets[3074] = new Collation(3074, "UCA1400_AS_CI", "utf32", 4);
    charsets[3075] = new Collation(3075, "UCA1400_AS_CS", "utf32", 4);
    charsets[3076] = new Collation(3076, "UCA1400_NOPAD_AI_CI", "utf32", 4);
    charsets[3077] = new Collation(3077, "UCA1400_NOPAD_AI_CS", "utf32", 4);
    charsets[3078] = new Collation(3078, "UCA1400_NOPAD_AS_CI", "utf32", 4);
    charsets[3079] = new Collation(3079, "UCA1400_NOPAD_AS_CS", "utf32", 4);
    charsets[3080] = new Collation(3080, "UCA1400_ICELANDIC_AI_CI", "utf32", 4);
    charsets[3081] = new Collation(3081, "UCA1400_ICELANDIC_AI_CS", "utf32", 4);
    charsets[3082] = new Collation(3082, "UCA1400_ICELANDIC_AS_CI", "utf32", 4);
    charsets[3083] = new Collation(3083, "UCA1400_ICELANDIC_AS_CS", "utf32", 4);
    charsets[3084] = new Collation(3084, "UCA1400_ICELANDIC_NOPAD_AI_CI", "utf32", 4);
    charsets[3085] = new Collation(3085, "UCA1400_ICELANDIC_NOPAD_AI_CS", "utf32", 4);
    charsets[3086] = new Collation(3086, "UCA1400_ICELANDIC_NOPAD_AS_CI", "utf32", 4);
    charsets[3087] = new Collation(3087, "UCA1400_ICELANDIC_NOPAD_AS_CS", "utf32", 4);
    charsets[3088] = new Collation(3088, "UCA1400_LATVIAN_AI_CI", "utf32", 4);
    charsets[3089] = new Collation(3089, "UCA1400_LATVIAN_AI_CS", "utf32", 4);
    charsets[3090] = new Collation(3090, "UCA1400_LATVIAN_AS_CI", "utf32", 4);
    charsets[3091] = new Collation(3091, "UCA1400_LATVIAN_AS_CS", "utf32", 4);
    charsets[3092] = new Collation(3092, "UCA1400_LATVIAN_NOPAD_AI_CI", "utf32", 4);
    charsets[3093] = new Collation(3093, "UCA1400_LATVIAN_NOPAD_AI_CS", "utf32", 4);
    charsets[3094] = new Collation(3094, "UCA1400_LATVIAN_NOPAD_AS_CI", "utf32", 4);
    charsets[3095] = new Collation(3095, "UCA1400_LATVIAN_NOPAD_AS_CS", "utf32", 4);
    charsets[3096] = new Collation(3096, "UCA1400_ROMANIAN_AI_CI", "utf32", 4);
    charsets[3097] = new Collation(3097, "UCA1400_ROMANIAN_AI_CS", "utf32", 4);
    charsets[3098] = new Collation(3098, "UCA1400_ROMANIAN_AS_CI", "utf32", 4);
    charsets[3099] = new Collation(3099, "UCA1400_ROMANIAN_AS_CS", "utf32", 4);
    charsets[3100] = new Collation(3100, "UCA1400_ROMANIAN_NOPAD_AI_CI", "utf32", 4);
    charsets[3101] = new Collation(3101, "UCA1400_ROMANIAN_NOPAD_AI_CS", "utf32", 4);
    charsets[3102] = new Collation(3102, "UCA1400_ROMANIAN_NOPAD_AS_CI", "utf32", 4);
    charsets[3103] = new Collation(3103, "UCA1400_ROMANIAN_NOPAD_AS_CS", "utf32", 4);
    charsets[3104] = new Collation(3104, "UCA1400_SLOVENIAN_AI_CI", "utf32", 4);
    charsets[3105] = new Collation(3105, "UCA1400_SLOVENIAN_AI_CS", "utf32", 4);
    charsets[3106] = new Collation(3106, "UCA1400_SLOVENIAN_AS_CI", "utf32", 4);
    charsets[3107] = new Collation(3107, "UCA1400_SLOVENIAN_AS_CS", "utf32", 4);
    charsets[3108] = new Collation(3108, "UCA1400_SLOVENIAN_NOPAD_AI_CI", "utf32", 4);
    charsets[3109] = new Collation(3109, "UCA1400_SLOVENIAN_NOPAD_AI_CS", "utf32", 4);
    charsets[3110] = new Collation(3110, "UCA1400_SLOVENIAN_NOPAD_AS_CI", "utf32", 4);
    charsets[3111] = new Collation(3111, "UCA1400_SLOVENIAN_NOPAD_AS_CS", "utf32", 4);
    charsets[3112] = new Collation(3112, "UCA1400_POLISH_AI_CI", "utf32", 4);
    charsets[3113] = new Collation(3113, "UCA1400_POLISH_AI_CS", "utf32", 4);
    charsets[3114] = new Collation(3114, "UCA1400_POLISH_AS_CI", "utf32", 4);
    charsets[3115] = new Collation(3115, "UCA1400_POLISH_AS_CS", "utf32", 4);
    charsets[3116] = new Collation(3116, "UCA1400_POLISH_NOPAD_AI_CI", "utf32", 4);
    charsets[3117] = new Collation(3117, "UCA1400_POLISH_NOPAD_AI_CS", "utf32", 4);
    charsets[3118] = new Collation(3118, "UCA1400_POLISH_NOPAD_AS_CI", "utf32", 4);
    charsets[3119] = new Collation(3119, "UCA1400_POLISH_NOPAD_AS_CS", "utf32", 4);
    charsets[3120] = new Collation(3120, "UCA1400_ESTONIAN_AI_CI", "utf32", 4);
    charsets[3121] = new Collation(3121, "UCA1400_ESTONIAN_AI_CS", "utf32", 4);
    charsets[3122] = new Collation(3122, "UCA1400_ESTONIAN_AS_CI", "utf32", 4);
    charsets[3123] = new Collation(3123, "UCA1400_ESTONIAN_AS_CS", "utf32", 4);
    charsets[3124] = new Collation(3124, "UCA1400_ESTONIAN_NOPAD_AI_CI", "utf32", 4);
    charsets[3125] = new Collation(3125, "UCA1400_ESTONIAN_NOPAD_AI_CS", "utf32", 4);
    charsets[3126] = new Collation(3126, "UCA1400_ESTONIAN_NOPAD_AS_CI", "utf32", 4);
    charsets[3127] = new Collation(3127, "UCA1400_ESTONIAN_NOPAD_AS_CS", "utf32", 4);
    charsets[3128] = new Collation(3128, "UCA1400_SPANISH_AI_CI", "utf32", 4);
    charsets[3129] = new Collation(3129, "UCA1400_SPANISH_AI_CS", "utf32", 4);
    charsets[3130] = new Collation(3130, "UCA1400_SPANISH_AS_CI", "utf32", 4);
    charsets[3131] = new Collation(3131, "UCA1400_SPANISH_AS_CS", "utf32", 4);
    charsets[3132] = new Collation(3132, "UCA1400_SPANISH_NOPAD_AI_CI", "utf32", 4);
    charsets[3133] = new Collation(3133, "UCA1400_SPANISH_NOPAD_AI_CS", "utf32", 4);
    charsets[3134] = new Collation(3134, "UCA1400_SPANISH_NOPAD_AS_CI", "utf32", 4);
    charsets[3135] = new Collation(3135, "UCA1400_SPANISH_NOPAD_AS_CS", "utf32", 4);
    charsets[3136] = new Collation(3136, "UCA1400_SWEDISH_AI_CI", "utf32", 4);
    charsets[3137] = new Collation(3137, "UCA1400_SWEDISH_AI_CS", "utf32", 4);
    charsets[3138] = new Collation(3138, "UCA1400_SWEDISH_AS_CI", "utf32", 4);
    charsets[3139] = new Collation(3139, "UCA1400_SWEDISH_AS_CS", "utf32", 4);
    charsets[3140] = new Collation(3140, "UCA1400_SWEDISH_NOPAD_AI_CI", "utf32", 4);
    charsets[3141] = new Collation(3141, "UCA1400_SWEDISH_NOPAD_AI_CS", "utf32", 4);
    charsets[3142] = new Collation(3142, "UCA1400_SWEDISH_NOPAD_AS_CI", "utf32", 4);
    charsets[3143] = new Collation(3143, "UCA1400_SWEDISH_NOPAD_AS_CS", "utf32", 4);
    charsets[3144] = new Collation(3144, "UCA1400_TURKISH_AI_CI", "utf32", 4);
    charsets[3145] = new Collation(3145, "UCA1400_TURKISH_AI_CS", "utf32", 4);
    charsets[3146] = new Collation(3146, "UCA1400_TURKISH_AS_CI", "utf32", 4);
    charsets[3147] = new Collation(3147, "UCA1400_TURKISH_AS_CS", "utf32", 4);
    charsets[3148] = new Collation(3148, "UCA1400_TURKISH_NOPAD_AI_CI", "utf32", 4);
    charsets[3149] = new Collation(3149, "UCA1400_TURKISH_NOPAD_AI_CS", "utf32", 4);
    charsets[3150] = new Collation(3150, "UCA1400_TURKISH_NOPAD_AS_CI", "utf32", 4);
    charsets[3151] = new Collation(3151, "UCA1400_TURKISH_NOPAD_AS_CS", "utf32", 4);
    charsets[3152] = new Collation(3152, "UCA1400_CZECH_AI_CI", "utf32", 4);
    charsets[3153] = new Collation(3153, "UCA1400_CZECH_AI_CS", "utf32", 4);
    charsets[3154] = new Collation(3154, "UCA1400_CZECH_AS_CI", "utf32", 4);
    charsets[3155] = new Collation(3155, "UCA1400_CZECH_AS_CS", "utf32", 4);
    charsets[3156] = new Collation(3156, "UCA1400_CZECH_NOPAD_AI_CI", "utf32", 4);
    charsets[3157] = new Collation(3157, "UCA1400_CZECH_NOPAD_AI_CS", "utf32", 4);
    charsets[3158] = new Collation(3158, "UCA1400_CZECH_NOPAD_AS_CI", "utf32", 4);
    charsets[3159] = new Collation(3159, "UCA1400_CZECH_NOPAD_AS_CS", "utf32", 4);
    charsets[3160] = new Collation(3160, "UCA1400_DANISH_AI_CI", "utf32", 4);
    charsets[3161] = new Collation(3161, "UCA1400_DANISH_AI_CS", "utf32", 4);
    charsets[3162] = new Collation(3162, "UCA1400_DANISH_AS_CI", "utf32", 4);
    charsets[3163] = new Collation(3163, "UCA1400_DANISH_AS_CS", "utf32", 4);
    charsets[3164] = new Collation(3164, "UCA1400_DANISH_NOPAD_AI_CI", "utf32", 4);
    charsets[3165] = new Collation(3165, "UCA1400_DANISH_NOPAD_AI_CS", "utf32", 4);
    charsets[3166] = new Collation(3166, "UCA1400_DANISH_NOPAD_AS_CI", "utf32", 4);
    charsets[3167] = new Collation(3167, "UCA1400_DANISH_NOPAD_AS_CS", "utf32", 4);
    charsets[3168] = new Collation(3168, "UCA1400_LITHUANIAN_AI_CI", "utf32", 4);
    charsets[3169] = new Collation(3169, "UCA1400_LITHUANIAN_AI_CS", "utf32", 4);
    charsets[3170] = new Collation(3170, "UCA1400_LITHUANIAN_AS_CI", "utf32", 4);
    charsets[3171] = new Collation(3171, "UCA1400_LITHUANIAN_AS_CS", "utf32", 4);
    charsets[3172] = new Collation(3172, "UCA1400_LITHUANIAN_NOPAD_AI_CI", "utf32", 4);
    charsets[3173] = new Collation(3173, "UCA1400_LITHUANIAN_NOPAD_AI_CS", "utf32", 4);
    charsets[3174] = new Collation(3174, "UCA1400_LITHUANIAN_NOPAD_AS_CI", "utf32", 4);
    charsets[3175] = new Collation(3175, "UCA1400_LITHUANIAN_NOPAD_AS_CS", "utf32", 4);
    charsets[3176] = new Collation(3176, "UCA1400_SLOVAK_AI_CI", "utf32", 4);
    charsets[3177] = new Collation(3177, "UCA1400_SLOVAK_AI_CS", "utf32", 4);
    charsets[3178] = new Collation(3178, "UCA1400_SLOVAK_AS_CI", "utf32", 4);
    charsets[3179] = new Collation(3179, "UCA1400_SLOVAK_AS_CS", "utf32", 4);
    charsets[3180] = new Collation(3180, "UCA1400_SLOVAK_NOPAD_AI_CI", "utf32", 4);
    charsets[3181] = new Collation(3181, "UCA1400_SLOVAK_NOPAD_AI_CS", "utf32", 4);
    charsets[3182] = new Collation(3182, "UCA1400_SLOVAK_NOPAD_AS_CI", "utf32", 4);
    charsets[3183] = new Collation(3183, "UCA1400_SLOVAK_NOPAD_AS_CS", "utf32", 4);
    charsets[3184] = new Collation(3184, "UCA1400_SPANISH2_AI_CI", "utf32", 4);
    charsets[3185] = new Collation(3185, "UCA1400_SPANISH2_AI_CS", "utf32", 4);
    charsets[3186] = new Collation(3186, "UCA1400_SPANISH2_AS_CI", "utf32", 4);
    charsets[3187] = new Collation(3187, "UCA1400_SPANISH2_AS_CS", "utf32", 4);
    charsets[3188] = new Collation(3188, "UCA1400_SPANISH2_NOPAD_AI_CI", "utf32", 4);
    charsets[3189] = new Collation(3189, "UCA1400_SPANISH2_NOPAD_AI_CS", "utf32", 4);
    charsets[3190] = new Collation(3190, "UCA1400_SPANISH2_NOPAD_AS_CI", "utf32", 4);
    charsets[3191] = new Collation(3191, "UCA1400_SPANISH2_NOPAD_AS_CS", "utf32", 4);
    charsets[3192] = new Collation(3192, "UCA1400_ROMAN_AI_CI", "utf32", 4);
    charsets[3193] = new Collation(3193, "UCA1400_ROMAN_AI_CS", "utf32", 4);
    charsets[3194] = new Collation(3194, "UCA1400_ROMAN_AS_CI", "utf32", 4);
    charsets[3195] = new Collation(3195, "UCA1400_ROMAN_AS_CS", "utf32", 4);
    charsets[3196] = new Collation(3196, "UCA1400_ROMAN_NOPAD_AI_CI", "utf32", 4);
    charsets[3197] = new Collation(3197, "UCA1400_ROMAN_NOPAD_AI_CS", "utf32", 4);
    charsets[3198] = new Collation(3198, "UCA1400_ROMAN_NOPAD_AS_CI", "utf32", 4);
    charsets[3199] = new Collation(3199, "UCA1400_ROMAN_NOPAD_AS_CS", "utf32", 4);
    charsets[3200] = new Collation(3200, "UCA1400_PERSIAN_AI_CI", "utf32", 4);
    charsets[3201] = new Collation(3201, "UCA1400_PERSIAN_AI_CS", "utf32", 4);
    charsets[3202] = new Collation(3202, "UCA1400_PERSIAN_AS_CI", "utf32", 4);
    charsets[3203] = new Collation(3203, "UCA1400_PERSIAN_AS_CS", "utf32", 4);
    charsets[3204] = new Collation(3204, "UCA1400_PERSIAN_NOPAD_AI_CI", "utf32", 4);
    charsets[3205] = new Collation(3205, "UCA1400_PERSIAN_NOPAD_AI_CS", "utf32", 4);
    charsets[3206] = new Collation(3206, "UCA1400_PERSIAN_NOPAD_AS_CI", "utf32", 4);
    charsets[3207] = new Collation(3207, "UCA1400_PERSIAN_NOPAD_AS_CS", "utf32", 4);
    charsets[3208] = new Collation(3208, "UCA1400_ESPERANTO_AI_CI", "utf32", 4);
    charsets[3209] = new Collation(3209, "UCA1400_ESPERANTO_AI_CS", "utf32", 4);
    charsets[3210] = new Collation(3210, "UCA1400_ESPERANTO_AS_CI", "utf32", 4);
    charsets[3211] = new Collation(3211, "UCA1400_ESPERANTO_AS_CS", "utf32", 4);
    charsets[3212] = new Collation(3212, "UCA1400_ESPERANTO_NOPAD_AI_CI", "utf32", 4);
    charsets[3213] = new Collation(3213, "UCA1400_ESPERANTO_NOPAD_AI_CS", "utf32", 4);
    charsets[3214] = new Collation(3214, "UCA1400_ESPERANTO_NOPAD_AS_CI", "utf32", 4);
    charsets[3215] = new Collation(3215, "UCA1400_ESPERANTO_NOPAD_AS_CS", "utf32", 4);
    charsets[3216] = new Collation(3216, "UCA1400_HUNGARIAN_AI_CI", "utf32", 4);
    charsets[3217] = new Collation(3217, "UCA1400_HUNGARIAN_AI_CS", "utf32", 4);
    charsets[3218] = new Collation(3218, "UCA1400_HUNGARIAN_AS_CI", "utf32", 4);
    charsets[3219] = new Collation(3219, "UCA1400_HUNGARIAN_AS_CS", "utf32", 4);
    charsets[3220] = new Collation(3220, "UCA1400_HUNGARIAN_NOPAD_AI_CI", "utf32", 4);
    charsets[3221] = new Collation(3221, "UCA1400_HUNGARIAN_NOPAD_AI_CS", "utf32", 4);
    charsets[3222] = new Collation(3222, "UCA1400_HUNGARIAN_NOPAD_AS_CI", "utf32", 4);
    charsets[3223] = new Collation(3223, "UCA1400_HUNGARIAN_NOPAD_AS_CS", "utf32", 4);
    charsets[3224] = new Collation(3224, "UCA1400_SINHALA_AI_CI", "utf32", 4);
    charsets[3225] = new Collation(3225, "UCA1400_SINHALA_AI_CS", "utf32", 4);
    charsets[3226] = new Collation(3226, "UCA1400_SINHALA_AS_CI", "utf32", 4);
    charsets[3227] = new Collation(3227, "UCA1400_SINHALA_AS_CS", "utf32", 4);
    charsets[3228] = new Collation(3228, "UCA1400_SINHALA_NOPAD_AI_CI", "utf32", 4);
    charsets[3229] = new Collation(3229, "UCA1400_SINHALA_NOPAD_AI_CS", "utf32", 4);
    charsets[3230] = new Collation(3230, "UCA1400_SINHALA_NOPAD_AS_CI", "utf32", 4);
    charsets[3231] = new Collation(3231, "UCA1400_SINHALA_NOPAD_AS_CS", "utf32", 4);
    charsets[3232] = new Collation(3232, "UCA1400_GERMAN2_AI_CI", "utf32", 4);
    charsets[3233] = new Collation(3233, "UCA1400_GERMAN2_AI_CS", "utf32", 4);
    charsets[3234] = new Collation(3234, "UCA1400_GERMAN2_AS_CI", "utf32", 4);
    charsets[3235] = new Collation(3235, "UCA1400_GERMAN2_AS_CS", "utf32", 4);
    charsets[3236] = new Collation(3236, "UCA1400_GERMAN2_NOPAD_AI_CI", "utf32", 4);
    charsets[3237] = new Collation(3237, "UCA1400_GERMAN2_NOPAD_AI_CS", "utf32", 4);
    charsets[3238] = new Collation(3238, "UCA1400_GERMAN2_NOPAD_AS_CI", "utf32", 4);
    charsets[3239] = new Collation(3239, "UCA1400_GERMAN2_NOPAD_AS_CS", "utf32", 4);
    charsets[3256] = new Collation(3256, "UCA1400_VIETNAMESE_AI_CI", "utf32", 4);
    charsets[3257] = new Collation(3257, "UCA1400_VIETNAMESE_AI_CS", "utf32", 4);
    charsets[3258] = new Collation(3258, "UCA1400_VIETNAMESE_AS_CI", "utf32", 4);
    charsets[3259] = new Collation(3259, "UCA1400_VIETNAMESE_AS_CS", "utf32", 4);
    charsets[3260] = new Collation(3260, "UCA1400_VIETNAMESE_NOPAD_AI_CI", "utf32", 4);
    charsets[3261] = new Collation(3261, "UCA1400_VIETNAMESE_NOPAD_AI_CS", "utf32", 4);
    charsets[3262] = new Collation(3262, "UCA1400_VIETNAMESE_NOPAD_AS_CI", "utf32", 4);
    charsets[3263] = new Collation(3263, "UCA1400_VIETNAMESE_NOPAD_AS_CS", "utf32", 4);
    charsets[3264] = new Collation(3264, "UCA1400_CROATIAN_AI_CI", "utf32", 4);
    charsets[3265] = new Collation(3265, "UCA1400_CROATIAN_AI_CS", "utf32", 4);
    charsets[3266] = new Collation(3266, "UCA1400_CROATIAN_AS_CI", "utf32", 4);
    charsets[3267] = new Collation(3267, "UCA1400_CROATIAN_AS_CS", "utf32", 4);
    charsets[3268] = new Collation(3268, "UCA1400_CROATIAN_NOPAD_AI_CI", "utf32", 4);
    charsets[3269] = new Collation(3269, "UCA1400_CROATIAN_NOPAD_AI_CS", "utf32", 4);
    charsets[3270] = new Collation(3270, "UCA1400_CROATIAN_NOPAD_AS_CI", "utf32", 4);
    charsets[3271] = new Collation(3271, "UCA1400_CROATIAN_NOPAD_AS_CS", "utf32", 4);
    for (let i = 0; i < charsets.length; i++) {
      let collation = charsets[i];
      if (collation) {
        Collation.prototype[collation.name] = collation;
      }
    }
    defaultCharsets["big5"] = charsets[1];
    defaultCharsets["dec8"] = charsets[3];
    defaultCharsets["cp850"] = charsets[4];
    defaultCharsets["hp8"] = charsets[6];
    defaultCharsets["koi8r"] = charsets[7];
    defaultCharsets["latin1"] = charsets[8];
    defaultCharsets["latin2"] = charsets[9];
    defaultCharsets["swe7"] = charsets[10];
    defaultCharsets["ascii"] = charsets[11];
    defaultCharsets["ujis"] = charsets[12];
    defaultCharsets["sjis"] = charsets[13];
    defaultCharsets["hebrew"] = charsets[16];
    defaultCharsets["tis620"] = charsets[18];
    defaultCharsets["euckr"] = charsets[19];
    defaultCharsets["koi8u"] = charsets[22];
    defaultCharsets["gb2312"] = charsets[24];
    defaultCharsets["greek"] = charsets[25];
    defaultCharsets["cp1250"] = charsets[26];
    defaultCharsets["gbk"] = charsets[28];
    defaultCharsets["latin5"] = charsets[30];
    defaultCharsets["armscii8"] = charsets[32];
    defaultCharsets["utf8"] = charsets[33];
    defaultCharsets["ucs2"] = charsets[35];
    defaultCharsets["cp866"] = charsets[36];
    defaultCharsets["keybcs2"] = charsets[37];
    defaultCharsets["macce"] = charsets[38];
    defaultCharsets["macroman"] = charsets[39];
    defaultCharsets["cp852"] = charsets[40];
    defaultCharsets["latin7"] = charsets[41];
    defaultCharsets["utf8mb4"] = charsets[45];
    defaultCharsets["cp1251"] = charsets[51];
    defaultCharsets["utf16"] = charsets[54];
    defaultCharsets["utf16le"] = charsets[56];
    defaultCharsets["cp1256"] = charsets[57];
    defaultCharsets["cp1257"] = charsets[59];
    defaultCharsets["utf32"] = charsets[60];
    defaultCharsets["binary"] = charsets[63];
    defaultCharsets["geostd8"] = charsets[92];
    defaultCharsets["cp932"] = charsets[95];
    defaultCharsets["eucjpms"] = charsets[97];
    defaultCharsets["gb18030"] = charsets[248];
    module.exports = Collation;
  }
});

// node_modules/mariadb/lib/cmd/encoder/text-encoder.js
var require_text_encoder = __commonJS({
  "node_modules/mariadb/lib/cmd/encoder/text-encoder.js"(exports, module) {
    "use strict";
    var QUOTE = 39;
    var GEO_TYPES = /* @__PURE__ */ new Set([
      "Point",
      "LineString",
      "Polygon",
      "MultiPoint",
      "MultiLineString",
      "MultiPolygon",
      "GeometryCollection"
    ]);
    var formatDigit = function(val, significantDigit) {
      const str = `${val}`;
      return str.length < significantDigit ? "0".repeat(significantDigit - str.length) + str : str;
    };
    var TextEncoder = class _TextEncoder {
      /**
       * Write (and escape) current parameter value to output writer
       *
       * @param out     output writer
       * @param value   current parameter. Expected to be non-null
       * @param opts    connection options
       * @param info    connection information
       */
      static writeParam(out, value, opts, info) {
        switch (typeof value) {
          case "boolean":
            out.writeStringAscii(value ? "true" : "false");
            break;
          case "bigint":
          case "number":
            out.writeStringAscii(`${value}`);
            break;
          case "string":
            out.writeStringEscapeQuote(value);
            break;
          case "object":
            if (Object.prototype.toString.call(value) === "[object Date]") {
              out.writeStringAscii(_TextEncoder.getLocalDate(value));
            } else if (Buffer.isBuffer(value)) {
              out.writeStringAscii("_BINARY '");
              out.writeBufferEscape(value);
              out.writeInt8(QUOTE);
            } else if (typeof value.toSqlString === "function") {
              out.writeStringEscapeQuote(String(value.toSqlString()));
            } else if (Array.isArray(value)) {
              if (opts.arrayParenthesis) {
                out.writeStringAscii("(");
              }
              for (let i = 0; i < value.length; i++) {
                if (i !== 0) out.writeStringAscii(",");
                if (value[i] == null) {
                  out.writeStringAscii("NULL");
                } else _TextEncoder.writeParam(out, value[i], opts, info);
              }
              if (opts.arrayParenthesis) {
                out.writeStringAscii(")");
              }
            } else {
              if (value.type != null && GEO_TYPES.has(value.type)) {
                const isMariaDb = info.isMariaDB();
                const prefix = isMariaDb && info.hasMinVersion(10, 1, 4) || !isMariaDb && info.hasMinVersion(5, 7, 6) ? "ST_" : "";
                switch (value.type) {
                  case "Point":
                    out.writeStringAscii(
                      prefix + "PointFromText('POINT(" + _TextEncoder.geoPointToString(value.coordinates) + ")')"
                    );
                    break;
                  case "LineString":
                    out.writeStringAscii(
                      prefix + "LineFromText('LINESTRING(" + _TextEncoder.geoArrayPointToString(value.coordinates) + ")')"
                    );
                    break;
                  case "Polygon":
                    out.writeStringAscii(
                      prefix + "PolygonFromText('POLYGON(" + _TextEncoder.geoMultiArrayPointToString(value.coordinates) + ")')"
                    );
                    break;
                  case "MultiPoint":
                    out.writeStringAscii(
                      prefix + "MULTIPOINTFROMTEXT('MULTIPOINT(" + _TextEncoder.geoArrayPointToString(value.coordinates) + ")')"
                    );
                    break;
                  case "MultiLineString":
                    out.writeStringAscii(
                      prefix + "MLineFromText('MULTILINESTRING(" + _TextEncoder.geoMultiArrayPointToString(value.coordinates) + ")')"
                    );
                    break;
                  case "MultiPolygon":
                    out.writeStringAscii(
                      prefix + "MPolyFromText('MULTIPOLYGON(" + _TextEncoder.geoMultiPolygonToString(value.coordinates) + ")')"
                    );
                    break;
                  case "GeometryCollection":
                    out.writeStringAscii(
                      prefix + "GeomCollFromText('GEOMETRYCOLLECTION(" + _TextEncoder.geometricCollectionToString(value.geometries) + ")')"
                    );
                    break;
                }
              } else if (String === value.constructor) {
                out.writeStringEscapeQuote(value);
                break;
              } else {
                if (opts.permitSetMultiParamEntries) {
                  let first = true;
                  for (const key in value) {
                    const val = value[key];
                    if (typeof val === "function") continue;
                    if (first) {
                      first = false;
                    } else {
                      out.writeStringAscii(",");
                    }
                    out.writeString("`" + key + "`");
                    if (val == null) {
                      out.writeStringAscii("=NULL");
                    } else {
                      out.writeStringAscii("=");
                      _TextEncoder.writeParam(out, val, opts, info);
                    }
                  }
                  if (first) out.writeStringEscapeQuote(JSON.stringify(value));
                } else {
                  out.writeStringEscapeQuote(JSON.stringify(value));
                }
              }
            }
            break;
        }
      }
      static geometricCollectionToString(geo) {
        if (!geo) return "";
        const len = geo.length;
        let st = "";
        for (let i = 0; i < len; i++) {
          const item = geo[i];
          if (i !== 0) st += ",";
          switch (item.type) {
            case "Point":
              st += `POINT(${_TextEncoder.geoPointToString(item.coordinates)})`;
              break;
            case "LineString":
              st += `LINESTRING(${_TextEncoder.geoArrayPointToString(item.coordinates)})`;
              break;
            case "Polygon":
              st += `POLYGON(${_TextEncoder.geoMultiArrayPointToString(item.coordinates)})`;
              break;
            case "MultiPoint":
              st += `MULTIPOINT(${_TextEncoder.geoArrayPointToString(item.coordinates)})`;
              break;
            case "MultiLineString":
              st += `MULTILINESTRING(${_TextEncoder.geoMultiArrayPointToString(item.coordinates)})`;
              break;
            case "MultiPolygon":
              st += `MULTIPOLYGON(${_TextEncoder.geoMultiPolygonToString(item.coordinates)})`;
              break;
          }
        }
        return st;
      }
      static geoMultiPolygonToString(coords) {
        if (!coords) return "";
        const len = coords.length;
        if (len === 0) return "";
        let st = "(";
        for (let i = 0; i < len; i++) {
          if (i !== 0) st += ",(";
          st += _TextEncoder.geoMultiArrayPointToString(coords[i]) + ")";
        }
        return st;
      }
      static geoMultiArrayPointToString(coords) {
        if (!coords) return "";
        const len = coords.length;
        if (len === 0) return "";
        let st = "(";
        for (let i = 0; i < len; i++) {
          if (i !== 0) st += ",(";
          st += _TextEncoder.geoArrayPointToString(coords[i]) + ")";
        }
        return st;
      }
      static geoArrayPointToString(coords) {
        if (!coords) return "";
        const len = coords.length;
        if (len === 0) return "";
        let st = "";
        for (let i = 0; i < len; i++) {
          if (i !== 0) st += ",";
          st += _TextEncoder.geoPointToString(coords[i]);
        }
        return st;
      }
      static geoPointToString(coords) {
        if (!coords) return "";
        const x = isNaN(coords[0]) ? "" : coords[0];
        const y = isNaN(coords[1]) ? "" : coords[1];
        return x + " " + y;
      }
      static getLocalDate(date) {
        const year = date.getFullYear();
        const month = date.getMonth() + 1;
        const day = date.getDate();
        const hours = date.getHours();
        const minutes = date.getMinutes();
        const seconds = date.getSeconds();
        const ms = date.getMilliseconds();
        const d = "'" + year + "-" + month + "-" + day + " " + hours + ":" + minutes + ":" + seconds;
        if (ms === 0) return d + "'";
        return d + "." + (ms < 10 ? "00" : ms < 100 ? "0" : "") + ms + "'";
      }
      static getFixedFormatDate(date) {
        const year = date.getFullYear();
        const mon = date.getMonth() + 1;
        const day = date.getDate();
        const hour = date.getHours();
        const min = date.getMinutes();
        const sec = date.getSeconds();
        const ms = date.getMilliseconds();
        let result = "'" + formatDigit(year, 4) + "-" + formatDigit(mon, 2) + "-" + formatDigit(day, 2) + " " + formatDigit(hour, 2) + ":" + formatDigit(min, 2) + ":" + formatDigit(sec, 2);
        if (ms > 0) {
          result += "." + formatDigit(ms, 3);
        }
        return result + "'";
      }
    };
    module.exports = TextEncoder;
  }
});

// node_modules/mariadb/lib/misc/utils.js
var require_utils = __commonJS({
  "node_modules/mariadb/lib/misc/utils.js"(exports, module) {
    "use strict";
    var hexArray = "0123456789ABCDEF".split("");
    var Errors = require_errors();
    var Iconv = require_lib();
    var TextEncoder = require_text_encoder();
    module.exports.log = function(opts, buf, off, end, header) {
      let out = [];
      if (!buf) return "";
      if (off === void 0 || off === null) off = 0;
      if (end === void 0 || end === null) end = buf.length;
      let asciiValue = new Array(16);
      asciiValue[8] = " ";
      let useHeader = header !== void 0;
      let offset = off || 0;
      const maxLgh = Math.min(useHeader ? opts.debugLen - header.length : opts.debugLen, end - offset);
      const isLimited = end - offset > maxLgh;
      let byteValue;
      let posHexa = 0;
      let pos = 0;
      out.push(
        "+--------------------------------------------------+\n|  0  1  2  3  4  5  6  7   8  9  a  b  c  d  e  f |\n+--------------------------------------------------+------------------+\n"
      );
      if (useHeader) {
        while (pos < header.length) {
          if (posHexa === 0) out.push("| ");
          byteValue = header[pos++] & 255;
          out.push(hexArray[byteValue >>> 4], hexArray[byteValue & 15], " ");
          asciiValue[posHexa++] = byteValue > 31 && byteValue < 127 ? String.fromCharCode(byteValue) : ".";
          if (posHexa === 8) out.push(" ");
        }
      }
      pos = offset;
      while (pos < maxLgh + offset) {
        if (posHexa === 0) out.push("| ");
        byteValue = buf[pos] & 255;
        out.push(hexArray[byteValue >>> 4], hexArray[byteValue & 15], " ");
        asciiValue[posHexa++] = byteValue > 31 && byteValue < 127 ? String.fromCharCode(byteValue) : ".";
        if (posHexa === 8) out.push(" ");
        if (posHexa === 16) {
          out.push("| ", asciiValue.join(""), " |\n");
          posHexa = 0;
        }
        pos++;
      }
      let remaining = posHexa;
      if (remaining > 0) {
        if (remaining < 8) {
          for (; remaining < 8; remaining++) {
            out.push("   ");
            asciiValue[posHexa++] = " ";
          }
          out.push(" ");
        }
        for (; remaining < 16; remaining++) {
          out.push("   ");
          asciiValue[posHexa++] = " ";
        }
        out.push("| ", asciiValue.join(""), isLimited ? " |...\n" : " |\n");
      } else if (isLimited) {
        out[out.length - 1] = " |...\n";
      }
      out.push("+--------------------------------------------------+------------------+\n");
      return out.join("");
    };
    module.exports.toHexString = (bytes) => {
      return Array.from(bytes, (byte) => {
        return ("0" + (byte & 255).toString(16)).slice(-2);
      }).join("");
    };
    module.exports.escapeId = (opts, info, value) => {
      if (!value || value === "") {
        throw Errors.createError("Cannot escape empty ID value", Errors.ER_NULL_ESCAPEID, info, "0A000");
      }
      if (value.includes("\0")) {
        throw Errors.createError(
          "Cannot escape ID with null character (u0000)",
          Errors.ER_NULL_CHAR_ESCAPEID,
          info,
          "0A000"
        );
      }
      return "`" + value.replace(/`/g, "``") + "`";
    };
    var escapeParameters = (opts, info, value) => {
      if (value == null) return "NULL";
      switch (typeof value) {
        case "boolean":
          return value ? "true" : "false";
        case "bigint":
        case "number":
          return `${value}`;
        case "object":
          if (Object.prototype.toString.call(value) === "[object Date]") {
            return TextEncoder.getFixedFormatDate(value);
          } else if (Buffer.isBuffer(value)) {
            let stValue;
            if (Buffer.isEncoding(info.collation.charset)) {
              stValue = value.toString(info.collation.charset, 0, value.length);
            } else {
              stValue = Iconv.decode(value, info.collation.charset);
            }
            return "_binary'" + escapeString(stValue) + "'";
          } else if (typeof value.toSqlString === "function") {
            return "'" + escapeString(String(value.toSqlString())) + "'";
          } else if (Array.isArray(value)) {
            let out = opts.arrayParenthesis ? "(" : "";
            for (let i = 0; i < value.length; i++) {
              if (i !== 0) out += ",";
              out += escapeParameters(opts, info, value[i]);
            }
            if (opts.arrayParenthesis) out += ")";
            return out;
          } else {
            if (value.type != null && [
              "Point",
              "LineString",
              "Polygon",
              "MultiPoint",
              "MultiLineString",
              "MultiPolygon",
              "GeometryCollection"
            ].includes(value.type)) {
              let prefix = info && (info.isMariaDB() && info.hasMinVersion(10, 1, 4) || !info.isMariaDB() && info.hasMinVersion(5, 7, 6)) ? "ST_" : "";
              switch (value.type) {
                case "Point":
                  return prefix + "PointFromText('POINT(" + TextEncoder.geoPointToString(value.coordinates) + ")')";
                case "LineString":
                  return prefix + "LineFromText('LINESTRING(" + TextEncoder.geoArrayPointToString(value.coordinates) + ")')";
                case "Polygon":
                  return prefix + "PolygonFromText('POLYGON(" + TextEncoder.geoMultiArrayPointToString(value.coordinates) + ")')";
                case "MultiPoint":
                  return prefix + "MULTIPOINTFROMTEXT('MULTIPOINT(" + TextEncoder.geoArrayPointToString(value.coordinates) + ")')";
                case "MultiLineString":
                  return prefix + "MLineFromText('MULTILINESTRING(" + TextEncoder.geoMultiArrayPointToString(value.coordinates) + ")')";
                case "MultiPolygon":
                  return prefix + "MPolyFromText('MULTIPOLYGON(" + TextEncoder.geoMultiPolygonToString(value.coordinates) + ")')";
                case "GeometryCollection":
                  return prefix + "GeomCollFromText('GEOMETRYCOLLECTION(" + TextEncoder.geometricCollectionToString(value.geometries) + ")')";
              }
            } else {
              if (opts.permitSetMultiParamEntries) {
                let out = "";
                let first = true;
                for (let key in value) {
                  const val = value[key];
                  if (typeof val === "function") continue;
                  if (first) {
                    first = false;
                  } else {
                    out += ",";
                  }
                  out += "`" + key + "`=";
                  out += exports.escape(opts, info, val);
                }
                if (out === "") return "'" + escapeString(JSON.stringify(value)) + "'";
                return out;
              } else {
                return "'" + escapeString(JSON.stringify(value)) + "'";
              }
            }
          }
        default:
          return "'" + escapeString(value) + "'";
      }
    };
    var LITTERAL_ESCAPE = {
      "\0": "\\0",
      "'": "\\'",
      '"': '\\"',
      "\b": "\\b",
      "\n": "\\n",
      "\r": "\\r",
      "	": "\\t",
      "": "\\Z",
      "\\": "\\\\"
    };
    var CHARS_GLOBAL_REGEXP = /[\000\032"'\\\b\n\r\t]/g;
    var escapeString = (val) => {
      let offset = 0;
      let escaped = "";
      let match;
      while (match = CHARS_GLOBAL_REGEXP.exec(val)) {
        escaped += val.substring(offset, match.index);
        escaped += LITTERAL_ESCAPE[match[0]];
        offset = CHARS_GLOBAL_REGEXP.lastIndex;
      }
      if (offset === 0) {
        return val;
      }
      if (offset < val.length) {
        escaped += val.substring(offset);
      }
      return escaped;
    };
    module.exports.escape = escapeParameters;
  }
});

// node_modules/mariadb/lib/io/packet-input-stream.js
var require_packet_input_stream = __commonJS({
  "node_modules/mariadb/lib/io/packet-input-stream.js"(exports, module) {
    "use strict";
    var PacketNodeEncoded = require_packet_node_encoded();
    var PacketIconvEncoded = require_packet_node_iconv();
    var Collations = require_collations();
    var Utils = require_utils();
    var PacketInputStream = class {
      constructor(unexpectedPacket, receiveQueue, out, opts, info) {
        this.unexpectedPacket = unexpectedPacket;
        this.opts = opts;
        this.receiveQueue = receiveQueue;
        this.info = info;
        this.out = out;
        this.header = Buffer.allocUnsafe(4);
        this.headerLen = 0;
        this.packetLen = null;
        this.remainingLen = null;
        this.parts = null;
        this.partsTotalLen = 0;
        this.changeEncoding(this.opts.collation ? this.opts.collation : Collations.fromIndex(224));
        this.changeDebug(this.opts.debug);
        this.opts.on("collation", this.changeEncoding.bind(this));
        this.opts.on("debug", this.changeDebug.bind(this));
      }
      changeEncoding(collation) {
        this.encoding = collation.charset;
        this.packet = Buffer.isEncoding(this.encoding) ? new PacketNodeEncoded(this.encoding) : new PacketIconvEncoded(this.encoding);
      }
      changeDebug(debug) {
        this.receivePacket = debug ? this.receivePacketDebug : this.receivePacketBasic;
      }
      receivePacketDebug(packet) {
        let cmd = this.currentCmd();
        this.header[0] = this.packetLen;
        this.header[1] = this.packetLen >> 8;
        this.header[2] = this.packetLen >> 16;
        this.header[3] = this.sequenceNo;
        if (packet) {
          this.opts.logger.network(
            `<== conn:${this.info.threadId ? this.info.threadId : -1} ${cmd ? cmd.onPacketReceive ? cmd.constructor.name + "." + cmd.onPacketReceive.name : cmd.constructor.name : "no command"} (${packet.pos},${packet.end})
${Utils.log(this.opts, packet.buf, packet.pos, packet.end, this.header)}`
          );
        }
        if (!cmd) {
          this.unexpectedPacket(packet);
          return;
        }
        cmd.sequenceNo = this.sequenceNo;
        cmd.onPacketReceive(packet, this.out, this.opts, this.info);
        if (!cmd.onPacketReceive) {
          this.receiveQueue.shift();
        }
      }
      receivePacketBasic(packet) {
        let cmd = this.currentCmd();
        if (!cmd) {
          this.unexpectedPacket(packet);
          return;
        }
        cmd.sequenceNo = this.sequenceNo;
        cmd.onPacketReceive(packet, this.out, this.opts, this.info);
        if (!cmd.onPacketReceive) this.receiveQueue.shift();
      }
      resetHeader() {
        this.remainingLen = null;
        this.headerLen = 0;
      }
      currentCmd() {
        let cmd;
        while (cmd = this.receiveQueue.peek()) {
          if (cmd.onPacketReceive) return cmd;
          this.receiveQueue.shift();
        }
        return null;
      }
      onData(chunk) {
        let pos = 0;
        let length;
        const chunkLen = chunk.length;
        do {
          if (this.remainingLen) {
            length = this.remainingLen;
          } else if (this.headerLen === 0 && chunkLen - pos >= 4) {
            this.packetLen = chunk[pos] + (chunk[pos + 1] << 8) + (chunk[pos + 2] << 16);
            this.sequenceNo = chunk[pos + 3];
            pos += 4;
            length = this.packetLen;
          } else {
            length = null;
            while (chunkLen - pos > 0) {
              this.header[this.headerLen++] = chunk[pos++];
              if (this.headerLen === 4) {
                this.packetLen = this.header[0] + (this.header[1] << 8) + (this.header[2] << 16);
                this.sequenceNo = this.header[3];
                length = this.packetLen;
                break;
              }
            }
          }
          if (length) {
            if (chunkLen - pos >= length) {
              pos += length;
              if (!this.parts) {
                if (this.packetLen < 16777215) {
                  this.receivePacket(this.packet.update(chunk, pos - length, pos));
                  while (pos + 4 < chunkLen) {
                    this.packetLen = chunk[pos] + (chunk[pos + 1] << 8) + (chunk[pos + 2] << 16);
                    this.sequenceNo = chunk[pos + 3];
                    pos += 4;
                    if (chunkLen - pos >= this.packetLen) {
                      pos += this.packetLen;
                      if (this.packetLen < 16777215) {
                        this.receivePacket(this.packet.update(chunk, pos - this.packetLen, pos));
                      } else {
                        this.parts = [chunk.subarray(pos - this.packetLen, pos)];
                        this.partsTotalLen = this.packetLen;
                        break;
                      }
                    } else {
                      const buf = chunk.subarray(pos, chunkLen);
                      if (!this.parts) {
                        this.parts = [buf];
                        this.partsTotalLen = chunkLen - pos;
                      } else {
                        this.parts.push(buf);
                        this.partsTotalLen += chunkLen - pos;
                      }
                      this.remainingLen = this.packetLen - (chunkLen - pos);
                      return;
                    }
                  }
                } else {
                  this.parts = [chunk.subarray(pos - length, pos)];
                  this.partsTotalLen = length;
                }
              } else {
                this.parts.push(chunk.subarray(pos - length, pos));
                this.partsTotalLen += length;
                if (this.packetLen < 16777215) {
                  let buf = Buffer.concat(this.parts, this.partsTotalLen);
                  this.parts = null;
                  this.receivePacket(this.packet.update(buf, 0, this.partsTotalLen));
                }
              }
              this.resetHeader();
            } else {
              const buf = chunk.subarray(pos, chunkLen);
              if (!this.parts) {
                this.parts = [buf];
                this.partsTotalLen = chunkLen - pos;
              } else {
                this.parts.push(buf);
                this.partsTotalLen += chunkLen - pos;
              }
              this.remainingLen = length - (chunkLen - pos);
              return;
            }
          } else if (length === 0 && this.parts) {
            this.parts.push(chunk.subarray(pos - length, pos));
            this.partsTotalLen += length;
            let buf = Buffer.concat(this.parts, this.partsTotalLen);
            this.parts = null;
            this.receivePacket(this.packet.update(buf, 0, this.partsTotalLen));
            this.resetHeader();
          }
        } while (pos < chunkLen);
      }
    };
    module.exports = PacketInputStream;
  }
});

// node_modules/mariadb/lib/io/packet-output-stream.js
var require_packet_output_stream = __commonJS({
  "node_modules/mariadb/lib/io/packet-output-stream.js"(exports, module) {
    "use strict";
    var Iconv = require_lib();
    var Utils = require_utils();
    var Errors = require_errors();
    var Collations = require_collations();
    var QUOTE = 39;
    var DBL_QUOTE = 34;
    var ZERO_BYTE = 0;
    var SLASH = 92;
    var SMALL_BUFFER_SIZE = 256;
    var MEDIUM_BUFFER_SIZE = 16384;
    var LARGE_BUFFER_SIZE = 131072;
    var BIG_BUFFER_SIZE = 1048576;
    var MAX_BUFFER_SIZE = 16777219;
    var CHARS_GLOBAL_REGEXP = /[\000\032"'\\\n\r\t]/g;
    var PacketOutputStream = class {
      constructor(opts, info) {
        this.opts = opts;
        this.info = info;
        this.pos = 4;
        this.markPos = -1;
        this.bufContainDataAfterMark = false;
        this.cmdLength = 0;
        this.buf = Buffer.allocUnsafe(SMALL_BUFFER_SIZE);
        this.maxAllowedPacket = opts.maxAllowedPacket || 16777216;
        this.maxPacketLength = Math.min(MAX_BUFFER_SIZE, this.maxAllowedPacket + 4);
        this.changeEncoding(this.opts.collation ? this.opts.collation : Collations.fromIndex(224));
        this.changeDebug(this.opts.debug);
        this.opts.on("collation", this.changeEncoding.bind(this));
        this.opts.on("debug", this.changeDebug.bind(this));
      }
      changeEncoding(collation) {
        this.encoding = collation.charset;
        if (this.encoding === "utf8") {
          this.writeString = this.writeDefaultBufferString;
          this.encodeString = this.encodeNodeString;
          this.writeLengthEncodedString = this.writeDefaultBufferLengthEncodedString;
          this.writeStringEscapeQuote = this.writeUtf8StringEscapeQuote;
        } else if (Buffer.isEncoding(this.encoding)) {
          this.writeString = this.writeDefaultBufferString;
          this.encodeString = this.encodeNodeString;
          this.writeLengthEncodedString = this.writeDefaultBufferLengthEncodedString;
          this.writeStringEscapeQuote = this.writeDefaultStringEscapeQuote;
        } else {
          this.writeString = this.writeDefaultIconvString;
          this.encodeString = this.encodeIconvString;
          this.writeLengthEncodedString = this.writeDefaultIconvLengthEncodedString;
          this.writeStringEscapeQuote = this.writeDefaultStringEscapeQuote;
        }
      }
      changeDebug(debug) {
        this.debug = debug;
        this.flushBuffer = debug ? this.flushBufferDebug : this.flushBufferBasic;
        this.fastFlush = debug ? this.fastFlushDebug : this.fastFlushBasic;
      }
      setStream(stream) {
        this.stream = stream;
      }
      growBuffer(len) {
        let newCapacity;
        if (len + this.pos < MEDIUM_BUFFER_SIZE) {
          newCapacity = MEDIUM_BUFFER_SIZE;
        } else if (len + this.pos < LARGE_BUFFER_SIZE) {
          newCapacity = LARGE_BUFFER_SIZE;
        } else if (len + this.pos < BIG_BUFFER_SIZE) {
          newCapacity = BIG_BUFFER_SIZE;
        } else if (this.bufContainDataAfterMark) {
          newCapacity = len + this.pos;
        } else {
          newCapacity = MAX_BUFFER_SIZE;
        }
        if (len + this.pos > newCapacity) {
          if (this.markPos !== -1) {
            this.flushBufferStopAtMark();
            if (len + this.pos <= this.buf.length) {
              return;
            }
            return this.growBuffer(len);
          }
        }
        let newBuf = Buffer.allocUnsafe(newCapacity);
        this.buf.copy(newBuf, 0, 0, this.pos);
        this.buf = newBuf;
      }
      mark() {
        this.markPos = this.pos;
      }
      isMarked() {
        return this.markPos !== -1;
      }
      hasFlushed() {
        return this.cmd.sequenceNo !== -1;
      }
      hasDataAfterMark() {
        return this.bufContainDataAfterMark;
      }
      bufIsAfterMaxPacketLength() {
        return this.pos > this.maxPacketLength;
      }
      /**
       * Reset mark flag and send bytes after mark flag.
       *
       * @return buffer after mark flag
       */
      resetMark() {
        this.pos = this.markPos;
        this.markPos = -1;
        if (this.bufContainDataAfterMark) {
          const data = Buffer.allocUnsafe(this.pos - 4);
          this.buf.copy(data, 0, 4, this.pos);
          this.cmd.sequenceNo = -1;
          this.cmd.compressSequenceNo = -1;
          this.bufContainDataAfterMark = false;
          return data;
        }
        return null;
      }
      /**
       * Send packet to socket.
       *
       * @throws IOException if socket error occur.
       */
      flush() {
        this.flushBuffer(true, 0);
        this.buf = Buffer.allocUnsafe(SMALL_BUFFER_SIZE);
        this.cmd.sequenceNo = -1;
        this.cmd.compressSequenceNo = -1;
        this.cmdLength = 0;
        this.markPos = -1;
      }
      flushPacket() {
        this.flushBuffer(false, 0);
        this.buf = Buffer.allocUnsafe(SMALL_BUFFER_SIZE);
        this.cmdLength = 0;
        this.markPos = -1;
      }
      startPacket(cmd) {
        this.cmd = cmd;
        this.pos = 4;
      }
      writeInt8(value) {
        if (this.pos + 1 >= this.buf.length) {
          let b = Buffer.allocUnsafe(1);
          b[0] = value;
          this.writeBuffer(b, 0, 1);
          return;
        }
        this.buf[this.pos++] = value;
      }
      writeInt16(value) {
        if (this.pos + 2 >= this.buf.length) {
          let b = Buffer.allocUnsafe(2);
          b[0] = value;
          b[1] = value >>> 8;
          this.writeBuffer(b, 0, 2);
          return;
        }
        this.buf[this.pos] = value;
        this.buf[this.pos + 1] = value >> 8;
        this.pos += 2;
      }
      writeInt16AtPos(initPos) {
        this.buf[initPos] = this.pos - initPos - 2;
        this.buf[initPos + 1] = this.pos - initPos - 2 >> 8;
      }
      writeInt24(value) {
        if (this.pos + 3 >= this.buf.length) {
          let arr = Buffer.allocUnsafe(3);
          arr[0] = value;
          arr[1] = value >> 8;
          arr[2] = value >> 16;
          this.writeBuffer(arr, 0, 3);
          return;
        }
        this.buf[this.pos] = value;
        this.buf[this.pos + 1] = value >> 8;
        this.buf[this.pos + 2] = value >> 16;
        this.pos += 3;
      }
      writeInt32(value) {
        if (this.pos + 4 >= this.buf.length) {
          let arr = Buffer.allocUnsafe(4);
          arr.writeInt32LE(value, 0);
          this.writeBuffer(arr, 0, 4);
          return;
        }
        this.buf[this.pos] = value;
        this.buf[this.pos + 1] = value >> 8;
        this.buf[this.pos + 2] = value >> 16;
        this.buf[this.pos + 3] = value >> 24;
        this.pos += 4;
      }
      writeBigInt(value) {
        if (this.pos + 8 >= this.buf.length) {
          let arr = Buffer.allocUnsafe(8);
          arr.writeBigInt64LE(value, 0);
          this.writeBuffer(arr, 0, 8);
          return;
        }
        this.buf.writeBigInt64LE(value, this.pos);
        this.pos += 8;
      }
      writeDouble(value) {
        if (this.pos + 8 >= this.buf.length) {
          let arr = Buffer.allocUnsafe(8);
          arr.writeDoubleLE(value, 0);
          this.writeBuffer(arr, 0, 8);
          return;
        }
        this.buf.writeDoubleLE(value, this.pos);
        this.pos += 8;
      }
      writeLengthCoded(len) {
        if (len < 251) {
          this.writeInt8(len);
          return;
        }
        if (len < 65536) {
          this.writeInt8(252);
          this.writeInt16(len);
        } else if (len < 16777216) {
          this.writeInt8(253);
          this.writeInt24(len);
        } else {
          this.writeInt8(254);
          this.writeBigInt(BigInt(len));
        }
      }
      writeBuffer(arr, off, len) {
        if (len > this.buf.length - this.pos) {
          if (this.buf.length !== MAX_BUFFER_SIZE) {
            this.growBuffer(len);
          }
          if (len > this.buf.length - this.pos) {
            if (this.markPos !== -1) {
              this.growBuffer(len);
              if (this.markPos !== -1) {
                this.flushBufferStopAtMark();
              }
            }
            if (len > this.buf.length - this.pos) {
              let remainingLen = len;
              while (true) {
                let lenToFillBuffer = Math.min(MAX_BUFFER_SIZE - this.pos, remainingLen);
                arr.copy(this.buf, this.pos, off, off + lenToFillBuffer);
                remainingLen -= lenToFillBuffer;
                off += lenToFillBuffer;
                this.pos += lenToFillBuffer;
                if (remainingLen === 0) return;
                this.flushBuffer(false, remainingLen);
              }
            }
          }
        }
        if (len > 50) {
          arr.copy(this.buf, this.pos, off, off + len);
          this.pos += len;
        } else {
          for (let i = 0; i < len; ) {
            this.buf[this.pos++] = arr[off + i++];
          }
        }
      }
      /**
       * Write ascii string to socket (no escaping)
       *
       * @param str                string
       */
      writeStringAscii(str) {
        let len = str.length;
        if (len >= this.buf.length - this.pos) {
          let strBuf = Buffer.from(str, "ascii");
          this.writeBuffer(strBuf, 0, strBuf.length);
          return;
        }
        for (let off = 0; off < len; ) {
          this.buf[this.pos++] = str.charCodeAt(off++);
        }
      }
      writeLengthEncodedBuffer(buffer) {
        const len = buffer.length;
        this.writeLengthCoded(len);
        this.writeBuffer(buffer, 0, len);
      }
      writeUtf8StringEscapeQuote(str) {
        const charsLength = str.length;
        if (charsLength * 3 + 2 >= this.buf.length - this.pos) {
          const arr = Buffer.from(str, "utf8");
          this.writeInt8(QUOTE);
          this.writeBufferEscape(arr);
          this.writeInt8(QUOTE);
          return;
        }
        let charsOffset = 0;
        let currChar;
        this.buf[this.pos++] = QUOTE;
        for (; charsOffset < charsLength && (currChar = str.charCodeAt(charsOffset)) < 128; charsOffset++) {
          if (currChar === SLASH || currChar === QUOTE || currChar === ZERO_BYTE || currChar === DBL_QUOTE) {
            this.buf[this.pos++] = SLASH;
          }
          this.buf[this.pos++] = currChar;
        }
        while (charsOffset < charsLength) {
          currChar = str.charCodeAt(charsOffset++);
          if (currChar < 128) {
            if (currChar === SLASH || currChar === QUOTE || currChar === ZERO_BYTE || currChar === DBL_QUOTE) {
              this.buf[this.pos++] = SLASH;
            }
            this.buf[this.pos++] = currChar;
          } else if (currChar < 2048) {
            this.buf[this.pos++] = 192 | currChar >> 6;
            this.buf[this.pos++] = 128 | currChar & 63;
          } else if (currChar >= 55296 && currChar < 57344) {
            if (currChar < 56320) {
              if (charsOffset + 1 > charsLength) {
                this.buf[this.pos++] = 63;
              } else {
                const nextChar = str.charCodeAt(charsOffset);
                if (nextChar >= 56320 && nextChar < 57344) {
                  const surrogatePairs = (currChar << 10) + nextChar + (65536 - (55296 << 10) - 56320);
                  this.buf[this.pos++] = 240 | surrogatePairs >> 18;
                  this.buf[this.pos++] = 128 | surrogatePairs >> 12 & 63;
                  this.buf[this.pos++] = 128 | surrogatePairs >> 6 & 63;
                  this.buf[this.pos++] = 128 | surrogatePairs & 63;
                  charsOffset++;
                } else {
                  this.buf[this.pos++] = 63;
                }
              }
            } else {
              this.buf[this.pos++] = 63;
            }
          } else {
            this.buf[this.pos++] = 224 | currChar >> 12;
            this.buf[this.pos++] = 128 | currChar >> 6 & 63;
            this.buf[this.pos++] = 128 | currChar & 63;
          }
        }
        this.buf[this.pos++] = QUOTE;
      }
      encodeIconvString(str) {
        return Iconv.encode(str, this.encoding);
      }
      encodeNodeString(str) {
        return Buffer.from(str, this.encoding);
      }
      writeDefaultBufferString(str) {
        if (str.length * 3 < this.buf.length - this.pos) {
          this.pos += this.buf.write(str, this.pos, this.encoding);
          return;
        }
        let byteLength = Buffer.byteLength(str, this.encoding);
        if (byteLength > this.buf.length - this.pos) {
          if (this.buf.length < MAX_BUFFER_SIZE) {
            this.growBuffer(byteLength);
          }
          if (byteLength > this.buf.length - this.pos) {
            let strBuf = Buffer.from(str, this.encoding);
            this.writeBuffer(strBuf, 0, strBuf.length);
            return;
          }
        }
        this.pos += this.buf.write(str, this.pos, this.encoding);
      }
      writeDefaultBufferLengthEncodedString(str) {
        let byteLength = Buffer.byteLength(str, this.encoding);
        this.writeLengthCoded(byteLength);
        if (byteLength > this.buf.length - this.pos) {
          if (this.buf.length < MAX_BUFFER_SIZE) {
            this.growBuffer(byteLength);
          }
          if (byteLength > this.buf.length - this.pos) {
            let strBuf = Buffer.from(str, this.encoding);
            this.writeBuffer(strBuf, 0, strBuf.length);
            return;
          }
        }
        this.pos += this.buf.write(str, this.pos, this.encoding);
      }
      writeDefaultIconvString(str) {
        let buf = Iconv.encode(str, this.encoding);
        this.writeBuffer(buf, 0, buf.length);
      }
      writeDefaultIconvLengthEncodedString(str) {
        let buf = Iconv.encode(str, this.encoding);
        this.writeLengthCoded(buf.length);
        this.writeBuffer(buf, 0, buf.length);
      }
      /**
       * Parameters need to be properly escaped :
       * following characters are to be escaped by "\" :
       * - \0
       * - \\
       * - \'
       * - \"
       * - \032
       * regex split part of string writing part, and escaping special char.
       * Those chars are <= 7f meaning that this will work even with multibyte encoding
       *
       * @param str string to escape.
       */
      writeDefaultStringEscapeQuote(str) {
        this.writeInt8(QUOTE);
        let match;
        let lastIndex = 0;
        while ((match = CHARS_GLOBAL_REGEXP.exec(str)) !== null) {
          this.writeString(str.slice(lastIndex, match.index));
          this.writeInt8(SLASH);
          this.writeInt8(match[0].charCodeAt(0));
          lastIndex = CHARS_GLOBAL_REGEXP.lastIndex;
        }
        if (lastIndex === 0) {
          this.writeString(str);
          this.writeInt8(QUOTE);
          return;
        }
        if (lastIndex < str.length) {
          this.writeString(str.slice(lastIndex));
        }
        this.writeInt8(QUOTE);
      }
      writeBinaryDate(date) {
        const year = date.getFullYear();
        const mon = date.getMonth() + 1;
        const day = date.getDate();
        const hour = date.getHours();
        const min = date.getMinutes();
        const sec = date.getSeconds();
        const ms = date.getMilliseconds();
        let len = ms === 0 ? 7 : 11;
        if (len + 1 > this.buf.length - this.pos) {
          let tmpBuf = Buffer.allocUnsafe(len + 1);
          tmpBuf[0] = len;
          tmpBuf[1] = year;
          tmpBuf[2] = year >>> 8;
          tmpBuf[3] = mon;
          tmpBuf[4] = day;
          tmpBuf[5] = hour;
          tmpBuf[6] = min;
          tmpBuf[7] = sec;
          if (ms !== 0) {
            const micro = ms * 1e3;
            tmpBuf[8] = micro;
            tmpBuf[9] = micro >>> 8;
            tmpBuf[10] = micro >>> 16;
            tmpBuf[11] = micro >>> 24;
          }
          this.writeBuffer(tmpBuf, 0, len + 1);
          return;
        }
        this.buf[this.pos] = len;
        this.buf[this.pos + 1] = year;
        this.buf[this.pos + 2] = year >>> 8;
        this.buf[this.pos + 3] = mon;
        this.buf[this.pos + 4] = day;
        this.buf[this.pos + 5] = hour;
        this.buf[this.pos + 6] = min;
        this.buf[this.pos + 7] = sec;
        if (ms !== 0) {
          const micro = ms * 1e3;
          this.buf[this.pos + 8] = micro;
          this.buf[this.pos + 9] = micro >>> 8;
          this.buf[this.pos + 10] = micro >>> 16;
          this.buf[this.pos + 11] = micro >>> 24;
        }
        this.pos += len + 1;
      }
      writeBufferEscape(val) {
        let valLen = val.length;
        if (valLen * 2 > this.buf.length - this.pos) {
          if (this.buf.length !== MAX_BUFFER_SIZE) this.growBuffer(valLen * 2);
          if (valLen * 2 > this.buf.length - this.pos) {
            for (let i = 0; i < valLen; i++) {
              switch (val[i]) {
                case QUOTE:
                case SLASH:
                case DBL_QUOTE:
                case ZERO_BYTE:
                  if (this.pos >= this.buf.length) this.flushBuffer(false, (valLen - i) * 2);
                  this.buf[this.pos++] = SLASH;
              }
              if (this.pos >= this.buf.length) this.flushBuffer(false, (valLen - i) * 2);
              this.buf[this.pos++] = val[i];
            }
            return;
          }
        }
        for (let i = 0; i < valLen; i++) {
          switch (val[i]) {
            case QUOTE:
            case SLASH:
            case DBL_QUOTE:
            case ZERO_BYTE:
              this.buf[this.pos++] = SLASH;
          }
          this.buf[this.pos++] = val[i];
        }
      }
      /**
       * Count query size. If query size is greater than max_allowed_packet and nothing has been already
       * send, throw an exception to avoid having the connection closed.
       *
       * @param length additional length to query size
       * @param info current connection information
       * @throws Error if query has not to be sent.
       */
      checkMaxAllowedLength(length, info) {
        if (this.opts.maxAllowedPacket && this.cmdLength + length >= this.maxAllowedPacket) {
          return Errors.createError(
            `query size (${this.cmdLength + length}) is >= to max_allowed_packet (${this.maxAllowedPacket})`,
            Errors.ER_MAX_ALLOWED_PACKET,
            info
          );
        }
        return null;
      }
      /**
       * Indicate if buffer contain any data.
       * @returns {boolean}
       */
      isEmpty() {
        return this.pos <= 4;
      }
      /**
       * Flush the internal buffer.
       */
      flushBufferDebug(commandEnd, remainingLen) {
        if (this.pos > 4) {
          this.buf[0] = this.pos - 4;
          this.buf[1] = this.pos - 4 >>> 8;
          this.buf[2] = this.pos - 4 >>> 16;
          this.buf[3] = ++this.cmd.sequenceNo;
          this.stream.writeBuf(this.buf.subarray(0, this.pos), this.cmd);
          this.stream.flush(true, this.cmd);
          this.cmdLength += this.pos - 4;
          this.opts.logger.network(
            `==> conn:${this.info.threadId ? this.info.threadId : -1} ${this.cmd.constructor.name + "(0," + this.pos + ")"}
${Utils.log(this.opts, this.buf, 0, this.pos)}`
          );
          if (commandEnd && this.pos === MAX_BUFFER_SIZE) {
            this.writeEmptyPacket();
          }
          this.buf = this.createBufferWithMinSize(remainingLen);
          this.pos = 4;
        }
      }
      /**
       * Flush to last mark.
       */
      flushBufferStopAtMark() {
        const end = this.pos;
        this.pos = this.markPos;
        const tmpBuf = Buffer.allocUnsafe(Math.max(SMALL_BUFFER_SIZE, end + 4 - this.pos));
        this.buf.copy(tmpBuf, 4, this.markPos, end);
        this.flushBuffer(true, end - this.pos);
        this.cmdLength = 0;
        this.buf = tmpBuf;
        this.pos = 4 + end - this.markPos;
        this.markPos = -1;
        this.bufContainDataAfterMark = true;
      }
      flushBufferBasic(commandEnd, remainingLen) {
        this.buf[0] = this.pos - 4;
        this.buf[1] = this.pos - 4 >>> 8;
        this.buf[2] = this.pos - 4 >>> 16;
        this.buf[3] = ++this.cmd.sequenceNo;
        this.stream.writeBuf(this.buf.subarray(0, this.pos), this.cmd);
        this.stream.flush(true, this.cmd);
        this.cmdLength += this.pos - 4;
        if (commandEnd && this.pos === MAX_BUFFER_SIZE) {
          this.writeEmptyPacket();
        }
        this.buf = this.createBufferWithMinSize(remainingLen);
        this.pos = 4;
      }
      createBufferWithMinSize(remainingLen) {
        let newCapacity;
        if (remainingLen + 4 < SMALL_BUFFER_SIZE) {
          newCapacity = SMALL_BUFFER_SIZE;
        } else if (remainingLen + 4 < MEDIUM_BUFFER_SIZE) {
          newCapacity = MEDIUM_BUFFER_SIZE;
        } else if (remainingLen + 4 < LARGE_BUFFER_SIZE) {
          newCapacity = LARGE_BUFFER_SIZE;
        } else if (remainingLen + 4 < BIG_BUFFER_SIZE) {
          newCapacity = BIG_BUFFER_SIZE;
        } else {
          newCapacity = MAX_BUFFER_SIZE;
        }
        return Buffer.allocUnsafe(newCapacity);
      }
      fastFlushDebug(cmd, packet) {
        this.stream.writeBuf(packet, cmd);
        this.stream.flush(true, cmd);
        this.cmdLength += packet.length;
        this.opts.logger.network(
          `==> conn:${this.info.threadId ? this.info.threadId : -1} ${cmd.constructor.name + "(0," + packet.length + ")"}
${Utils.log(this.opts, packet, 0, packet.length)}`
        );
        this.cmdLength = 0;
        this.markPos = -1;
      }
      fastFlushBasic(cmd, packet) {
        this.stream.writeBuf(packet, cmd);
        this.stream.flush(true, cmd);
        this.cmdLength = 0;
        this.markPos = -1;
      }
      writeEmptyPacket() {
        const emptyBuf = Buffer.from([0, 0, 0, ++this.cmd.sequenceNo]);
        if (this.debug) {
          this.opts.logger.network(
            `==> conn:${this.info.threadId ? this.info.threadId : -1} ${this.cmd.constructor.name}(0,4)
${Utils.log(
              this.opts,
              emptyBuf,
              0,
              4
            )}`
          );
        }
        this.stream.writeBuf(emptyBuf, this.cmd);
        this.stream.flush(true, this.cmd);
        this.cmdLength = 0;
      }
    };
    module.exports = PacketOutputStream;
  }
});

// browser-external:zlib
var require_zlib = __commonJS({
  "browser-external:zlib"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "zlib" has been externalized for browser compatibility. Cannot access "zlib.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/mariadb/lib/io/compression-input-stream.js
var require_compression_input_stream = __commonJS({
  "node_modules/mariadb/lib/io/compression-input-stream.js"(exports, module) {
    "use strict";
    var ZLib = require_zlib();
    var Utils = require_utils();
    var CompressionInputStream = class {
      constructor(reader, receiveQueue, opts, info) {
        this.reader = reader;
        this.receiveQueue = receiveQueue;
        this.info = info;
        this.opts = opts;
        this.header = Buffer.allocUnsafe(7);
        this.headerLen = 0;
        this.compressPacketLen = null;
        this.packetLen = null;
        this.remainingLen = null;
        this.parts = null;
        this.partsTotalLen = 0;
      }
      receivePacket(chunk) {
        let cmd = this.currentCmd();
        if (this.opts.debugCompress) {
          this.opts.logger.network(
            `<== conn:${this.info.threadId ? this.info.threadId : -1} ${cmd ? cmd.onPacketReceive ? cmd.constructor.name + "." + cmd.onPacketReceive.name : cmd.constructor.name : "no command"} (compress)
${Utils.log(this.opts, chunk, 0, chunk.length, this.header)}`
          );
        }
        if (cmd) cmd.compressSequenceNo = this.header[3];
        const unCompressLen = this.header[4] | this.header[5] << 8 | this.header[6] << 16;
        if (unCompressLen === 0) {
          this.reader.onData(chunk);
        } else {
          const unCompressChunk = ZLib.inflateSync(chunk);
          this.reader.onData(unCompressChunk);
        }
      }
      currentCmd() {
        let cmd;
        while (cmd = this.receiveQueue.peek()) {
          if (cmd.onPacketReceive) return cmd;
          this.receiveQueue.shift();
        }
        return null;
      }
      resetHeader() {
        this.remainingLen = null;
        this.headerLen = 0;
      }
      onData(chunk) {
        let pos = 0;
        let length;
        const chunkLen = chunk.length;
        do {
          if (this.remainingLen) {
            length = this.remainingLen;
          } else if (this.headerLen === 0 && chunkLen - pos >= 7) {
            this.header[0] = chunk[pos];
            this.header[1] = chunk[pos + 1];
            this.header[2] = chunk[pos + 2];
            this.header[3] = chunk[pos + 3];
            this.header[4] = chunk[pos + 4];
            this.header[5] = chunk[pos + 5];
            this.header[6] = chunk[pos + 6];
            this.headerLen = 7;
            pos += 7;
            this.compressPacketLen = this.header[0] + (this.header[1] << 8) + (this.header[2] << 16);
            this.packetLen = this.header[4] | this.header[5] << 8 | this.header[6] << 16;
            if (this.packetLen === 0) this.packetLen = this.compressPacketLen;
            length = this.compressPacketLen;
          } else {
            length = null;
            while (chunkLen - pos > 0) {
              this.header[this.headerLen++] = chunk[pos++];
              if (this.headerLen === 7) {
                this.compressPacketLen = this.header[0] + (this.header[1] << 8) + (this.header[2] << 16);
                this.packetLen = this.header[4] | this.header[5] << 8 | this.header[6] << 16;
                if (this.packetLen === 0) this.packetLen = this.compressPacketLen;
                length = this.compressPacketLen;
                break;
              }
            }
          }
          if (length) {
            if (chunkLen - pos >= length) {
              const buf = chunk.subarray(pos, pos + length);
              pos += length;
              if (this.parts) {
                this.parts.push(buf);
                this.partsTotalLen += length;
                if (this.compressPacketLen < 16777215) {
                  let buf2 = Buffer.concat(this.parts, this.partsTotalLen);
                  this.parts = null;
                  this.receivePacket(buf2);
                }
              } else {
                if (this.compressPacketLen < 16777215) {
                  this.receivePacket(buf);
                } else {
                  this.parts = [buf];
                  this.partsTotalLen = length;
                }
              }
              this.resetHeader();
            } else {
              const buf = chunk.subarray(pos, chunkLen);
              if (!this.parts) {
                this.parts = [buf];
                this.partsTotalLen = chunkLen - pos;
              } else {
                this.parts.push(buf);
                this.partsTotalLen += chunkLen - pos;
              }
              this.remainingLen = length - (chunkLen - pos);
              return;
            }
          }
        } while (pos < chunkLen);
      }
    };
    module.exports = CompressionInputStream;
  }
});

// node_modules/mariadb/lib/io/compression-output-stream.js
var require_compression_output_stream = __commonJS({
  "node_modules/mariadb/lib/io/compression-output-stream.js"(exports, module) {
    "use strict";
    var Utils = require_utils();
    var ZLib = require_zlib();
    var SMALL_BUFFER_SIZE = 2048;
    var MEDIUM_BUFFER_SIZE = 131072;
    var LARGE_BUFFER_SIZE = 1048576;
    var MAX_BUFFER_SIZE = 16777222;
    var CompressionOutputStream = class _CompressionOutputStream {
      /**
       * Constructor
       *
       * @param socket    current socket
       * @param opts      current connection options
       * @param info      current connection information
       * @constructor
       */
      constructor(socket, opts, info) {
        this.info = info;
        this.opts = opts;
        this.pos = 7;
        this.header = Buffer.allocUnsafe(7);
        this.buf = Buffer.allocUnsafe(SMALL_BUFFER_SIZE);
        this.writer = (buffer) => {
          socket.write(buffer);
        };
      }
      growBuffer(len) {
        let newCapacity;
        if (len + this.pos < MEDIUM_BUFFER_SIZE) {
          newCapacity = MEDIUM_BUFFER_SIZE;
        } else if (len + this.pos < LARGE_BUFFER_SIZE) {
          newCapacity = LARGE_BUFFER_SIZE;
        } else newCapacity = MAX_BUFFER_SIZE;
        let newBuf = Buffer.allocUnsafe(newCapacity);
        this.buf.copy(newBuf, 0, 0, this.pos);
        this.buf = newBuf;
      }
      writeBuf(arr, cmd) {
        let off = 0, len = arr.length;
        if (arr instanceof Uint8Array) {
          arr = Buffer.from(arr);
        }
        if (len > this.buf.length - this.pos) {
          if (this.buf.length !== MAX_BUFFER_SIZE) {
            this.growBuffer(len);
          }
          if (len > this.buf.length - this.pos) {
            let remainingLen = len;
            while (true) {
              let lenToFillBuffer = Math.min(MAX_BUFFER_SIZE - this.pos, remainingLen);
              arr.copy(this.buf, this.pos, off, off + lenToFillBuffer);
              remainingLen -= lenToFillBuffer;
              off += lenToFillBuffer;
              this.pos += lenToFillBuffer;
              if (remainingLen === 0) return;
              this.flush(false, cmd, remainingLen);
            }
          }
        }
        arr.copy(this.buf, this.pos, off, off + len);
        this.pos += len;
      }
      /**
       * Flush the internal buffer.
       */
      flush(cmdEnd, cmd, remainingLen) {
        if (this.pos < 1536) {
          this.buf[0] = this.pos - 7;
          this.buf[1] = this.pos - 7 >>> 8;
          this.buf[2] = this.pos - 7 >>> 16;
          this.buf[3] = ++cmd.compressSequenceNo;
          this.buf[4] = 0;
          this.buf[5] = 0;
          this.buf[6] = 0;
          if (this.opts.debugCompress) {
            this.opts.logger.network(
              `==> conn:${this.info.threadId ? this.info.threadId : -1} ${cmd ? cmd.constructor.name + "(0," + this.pos + ")" : "unknown"} (compress)
${Utils.log(this.opts, this.buf, 0, this.pos)}`
            );
          }
          this.writer(this.buf.subarray(0, this.pos));
        } else {
          const compressChunk = ZLib.deflateSync(this.buf.subarray(7, this.pos));
          const compressChunkLen = compressChunk.length;
          this.header[0] = compressChunkLen;
          this.header[1] = compressChunkLen >>> 8;
          this.header[2] = compressChunkLen >>> 16;
          this.header[3] = ++cmd.compressSequenceNo;
          this.header[4] = this.pos - 7;
          this.header[5] = this.pos - 7 >>> 8;
          this.header[6] = this.pos - 7 >>> 16;
          if (this.opts.debugCompress) {
            this.opts.logger.network(
              `==> conn:${this.info.threadId ? this.info.threadId : -1} ${cmd ? cmd.constructor.name + "(0," + this.pos + "=>" + compressChunkLen + ")" : "unknown"} (compress)
${Utils.log(this.opts, compressChunk, 0, compressChunkLen, this.header)}`
            );
          }
          this.writer(this.header);
          this.writer(compressChunk);
          if (cmdEnd && compressChunkLen === MAX_BUFFER_SIZE) this.writeEmptyPacket(cmd);
          this.header = Buffer.allocUnsafe(7);
        }
        this.buf = remainingLen ? _CompressionOutputStream.allocateBuffer(remainingLen) : Buffer.allocUnsafe(SMALL_BUFFER_SIZE);
        this.pos = 7;
      }
      static allocateBuffer(len) {
        if (len + 4 < SMALL_BUFFER_SIZE) {
          return Buffer.allocUnsafe(SMALL_BUFFER_SIZE);
        } else if (len + 4 < MEDIUM_BUFFER_SIZE) {
          return Buffer.allocUnsafe(MEDIUM_BUFFER_SIZE);
        } else if (len + 4 < LARGE_BUFFER_SIZE) {
          return Buffer.allocUnsafe(LARGE_BUFFER_SIZE);
        }
        return Buffer.allocUnsafe(MAX_BUFFER_SIZE);
      }
      writeEmptyPacket(cmd) {
        const emptyBuf = Buffer.from([0, 0, 0, cmd.compressSequenceNo, 0, 0, 0]);
        if (this.opts.debugCompress) {
          this.opts.logger.network(
            `==> conn:${this.info.threadId ? this.info.threadId : -1} ${cmd ? cmd.constructor.name + "(0," + this.pos + ")" : "unknown"} (compress)
${Utils.log(this.opts, emptyBuf, 0, 7)}`
          );
        }
        this.writer(emptyBuf);
      }
    };
    module.exports = CompressionOutputStream;
  }
});

// node_modules/mariadb/lib/const/server-status.js
var require_server_status = __commonJS({
  "node_modules/mariadb/lib/const/server-status.js"(exports, module) {
    module.exports.STATUS_IN_TRANS = 1;
    module.exports.STATUS_AUTOCOMMIT = 2;
    module.exports.MORE_RESULTS_EXISTS = 8;
    module.exports.QUERY_NO_GOOD_INDEX_USED = 16;
    module.exports.QUERY_NO_INDEX_USED = 32;
    module.exports.STATUS_CURSOR_EXISTS = 64;
    module.exports.STATUS_LAST_ROW_SENT = 128;
    module.exports.STATUS_DB_DROPPED = 1 << 8;
    module.exports.STATUS_NO_BACKSLASH_ESCAPES = 1 << 9;
    module.exports.STATUS_METADATA_CHANGED = 1 << 10;
    module.exports.QUERY_WAS_SLOW = 1 << 11;
    module.exports.PS_OUT_PARAMS = 1 << 12;
    module.exports.STATUS_IN_TRANS_READONLY = 1 << 13;
    module.exports.SESSION_STATE_CHANGED = 1 << 14;
  }
});

// node_modules/mariadb/lib/misc/connection-information.js
var require_connection_information = __commonJS({
  "node_modules/mariadb/lib/misc/connection-information.js"(exports, module) {
    "use strict";
    var _redirectFct;
    var ConnectionInformation = class {
      constructor(opts, redirectFct) {
        __privateAdd(this, _redirectFct);
        this.threadId = -1;
        this.status = null;
        this.serverVersion = null;
        this.serverCapabilities = null;
        this.database = opts.database;
        this.port = opts.port;
        __privateSet(this, _redirectFct, redirectFct);
        this.redirectRequest = null;
      }
      hasMinVersion(major, minor, patch) {
        if (!this.serverVersion) throw new Error("cannot know if server version until connection is established");
        if (!major) throw new Error("a major version must be set");
        if (!minor) minor = 0;
        if (!patch) patch = 0;
        let ver = this.serverVersion;
        return ver.major > major || ver.major === major && ver.minor > minor || ver.major === major && ver.minor === minor && ver.patch >= patch;
      }
      redirect(value, resolve) {
        return __privateGet(this, _redirectFct).call(this, value, resolve);
      }
      isMariaDB() {
        if (!this.serverVersion) throw new Error("cannot know if server is MariaDB until connection is established");
        return this.serverVersion.mariaDb;
      }
      /**
       * Parse raw info to set server major/minor/patch values
       * @param info
       */
      static parseVersionString(info) {
        let car;
        let offset = 0;
        let type = 0;
        let val = 0;
        for (; offset < info.serverVersion.raw.length; offset++) {
          car = info.serverVersion.raw.charCodeAt(offset);
          if (car < 48 || car > 57) {
            switch (type) {
              case 0:
                info.serverVersion.major = val;
                break;
              case 1:
                info.serverVersion.minor = val;
                break;
              case 2:
                info.serverVersion.patch = val;
                return;
            }
            type++;
            val = 0;
          } else {
            val = val * 10 + car - 48;
          }
        }
        if (type === 2) info.serverVersion.patch = val;
      }
    };
    _redirectFct = new WeakMap();
    module.exports = ConnectionInformation;
  }
});

// browser-external:tls
var require_tls = __commonJS({
  "browser-external:tls"(exports, module) {
    module.exports = Object.create(new Proxy({}, {
      get(_, key) {
        if (key !== "__esModule" && key !== "__proto__" && key !== "constructor" && key !== "splice") {
          console.warn(`Module "tls" has been externalized for browser compatibility. Cannot access "tls.${key}" in client code. See https://vite.dev/guide/troubleshooting.html#module-externalized-for-browser-compatibility for more details.`);
        }
      }
    }));
  }
});

// node_modules/mariadb/lib/const/capabilities.js
var require_capabilities = __commonJS({
  "node_modules/mariadb/lib/const/capabilities.js"(exports, module) {
    module.exports.MYSQL = 1n;
    module.exports.FOUND_ROWS = 2n;
    module.exports.LONG_FLAG = 4n;
    module.exports.CONNECT_WITH_DB = 8n;
    module.exports.NO_SCHEMA = 1n << 4n;
    module.exports.COMPRESS = 1n << 5n;
    module.exports.ODBC = 1n << 6n;
    module.exports.LOCAL_FILES = 1n << 7n;
    module.exports.IGNORE_SPACE = 1n << 8n;
    module.exports.PROTOCOL_41 = 1n << 9n;
    module.exports.INTERACTIVE = 1n << 10n;
    module.exports.SSL = 1n << 11n;
    module.exports.IGNORE_SIGPIPE = 1n << 12n;
    module.exports.TRANSACTIONS = 1n << 13n;
    module.exports.RESERVED = 1n << 14n;
    module.exports.SECURE_CONNECTION = 1n << 15n;
    module.exports.MULTI_STATEMENTS = 1n << 16n;
    module.exports.MULTI_RESULTS = 1n << 17n;
    module.exports.PS_MULTI_RESULTS = 1n << 18n;
    module.exports.PLUGIN_AUTH = 1n << 19n;
    module.exports.CONNECT_ATTRS = 1n << 20n;
    module.exports.PLUGIN_AUTH_LENENC_CLIENT_DATA = 1n << 21n;
    module.exports.CAN_HANDLE_EXPIRED_PASSWORDS = 1n << 22n;
    module.exports.SESSION_TRACK = 1n << 23n;
    module.exports.DEPRECATE_EOF = 1n << 24n;
    module.exports.SSL_VERIFY_SERVER_CERT = 1n << 30n;
    module.exports.MARIADB_CLIENT_STMT_BULK_OPERATIONS = 1n << 34n;
    module.exports.MARIADB_CLIENT_EXTENDED_METADATA = 1n << 35n;
    module.exports.MARIADB_CLIENT_CACHE_METADATA = 1n << 36n;
    module.exports.BULK_UNIT_RESULTS = 1n << 37n;
  }
});

// node_modules/mariadb/lib/config/connection-options.js
var require_connection_options = __commonJS({
  "node_modules/mariadb/lib/config/connection-options.js"(exports, module) {
    "use strict";
    var Collations = require_collations();
    var urlFormat = /mariadb:\/\/(([^/@:]+)?(:([^/]+))?@)?(([^/:]+)(:([0-9]+))?)\/([^?]+)(\?(.*))?$/;
    var ConnectionOptions = class _ConnectionOptions {
      constructor(opts) {
        if (typeof opts === "string") {
          opts = _ConnectionOptions.parse(opts);
        }
        if (!opts) opts = {};
        this.host = opts.host || "localhost";
        this.port = opts.port ? Number(opts.port) : 3306;
        this.keepEof = Boolean(opts.keepEof) || false;
        this.user = opts.user || process.env.USERNAME;
        this.password = opts.password;
        this.database = opts.database;
        this.stream = opts.stream;
        this.fullResult = opts.fullResult;
        this.debug = Boolean(opts.debug) || false;
        this.debugCompress = Boolean(opts.debugCompress) || false;
        this.debugLen = opts.debugLen ? Number(opts.debugLen) : 256;
        this.logParam = opts.logParam === void 0 ? true : Boolean(opts.logParam);
        if (opts.logger) {
          if (typeof opts.logger === "function") {
            this.logger = {
              network: opts.logger,
              query: opts.logger,
              error: opts.logger,
              warning: opts.logger
            };
          } else {
            this.logger = {
              network: opts.logger.network,
              query: opts.logger.query,
              error: opts.logger.error,
              warning: opts.logger.warning || console.log
            };
            if (opts.logger.logParam !== void 0) this.logParam = Boolean(opts.logger.logParam);
          }
        } else {
          this.logger = {
            network: this.debug || this.debugCompress ? console.log : null,
            query: null,
            error: null,
            warning: console.log
          };
        }
        this.debug = !!this.logger.network;
        if (opts.charset && typeof opts.charset === "string") {
          this.collation = Collations.fromCharset(opts.charset.toLowerCase());
          if (this.collation === void 0) {
            this.collation = Collations.fromName(opts.charset.toUpperCase());
            if (this.collation !== void 0) {
              this.logger.warning(
                "warning: please use option 'collation' in replacement of 'charset' when using a collation name ('" + opts.charset + "')\n(collation looks like 'UTF8MB4_UNICODE_CI', charset like 'utf8')."
              );
            } else {
              this.charset = opts.charset;
            }
          }
        } else if (opts.collation && typeof opts.collation === "string") {
          this.collation = Collations.fromName(opts.collation.toUpperCase());
          if (this.collation === void 0) throw new RangeError("Unknown collation '" + opts.collation + "'");
        } else {
          this.collation = opts.charsetNumber ? Collations.fromIndex(Number(opts.charsetNumber)) : void 0;
        }
        this.initSql = opts.initSql;
        this.connectTimeout = opts.connectTimeout === void 0 ? 1e3 : Number(opts.connectTimeout);
        this.connectAttributes = opts.connectAttributes || false;
        this.compress = Boolean(opts.compress) || false;
        this.rsaPublicKey = opts.rsaPublicKey;
        this.cachingRsaPublicKey = opts.cachingRsaPublicKey;
        this.allowPublicKeyRetrieval = Boolean(opts.allowPublicKeyRetrieval) || false;
        this.forceVersionCheck = Boolean(opts.forceVersionCheck) || false;
        this.maxAllowedPacket = opts.maxAllowedPacket ? Number(opts.maxAllowedPacket) : void 0;
        this.permitConnectionWhenExpired = Boolean(opts.permitConnectionWhenExpired) || false;
        this.pipelining = opts.pipelining;
        this.timezone = opts.timezone || "local";
        this.socketPath = opts.socketPath;
        this.sessionVariables = opts.sessionVariables;
        this.infileStreamFactory = opts.infileStreamFactory;
        this.ssl = opts.ssl;
        if (opts.ssl) {
          if (typeof opts.ssl !== "boolean" && typeof opts.ssl !== "string") {
            this.ssl.rejectUnauthorized = opts.ssl.rejectUnauthorized !== false;
          }
        }
        this.permitRedirect = opts.permitRedirect === void 0 ? !!this.ssl && this.ssl.rejectUnauthorized !== false : Boolean(opts.permitRedirect);
        this.queryTimeout = isNaN(opts.queryTimeout) || Number(opts.queryTimeout) < 0 ? 0 : Number(opts.queryTimeout);
        this.socketTimeout = isNaN(opts.socketTimeout) || Number(opts.socketTimeout) < 0 ? 0 : Number(opts.socketTimeout);
        this.keepAliveDelay = opts.keepAliveDelay === void 0 ? 0 : Number(opts.keepAliveDelay);
        if (!opts.keepAliveDelay) {
          if (opts.enableKeepAlive === true && opts.keepAliveInitialDelay !== void 0) {
            this.keepAliveDelay = Number(opts.keepAliveInitialDelay);
          }
        }
        this.trace = Boolean(opts.trace) || false;
        this.checkDuplicate = opts.checkDuplicate === void 0 ? true : Boolean(opts.checkDuplicate);
        this.dateStrings = Boolean(opts.dateStrings) || false;
        this.foundRows = opts.foundRows === void 0 || Boolean(opts.foundRows);
        this.metaAsArray = Boolean(opts.metaAsArray) || false;
        this.metaEnumerable = Boolean(opts.metaEnumerable) || false;
        this.multipleStatements = Boolean(opts.multipleStatements) || false;
        this.namedPlaceholders = Boolean(opts.namedPlaceholders) || false;
        this.nestTables = opts.nestTables;
        this.autoJsonMap = opts.autoJsonMap === void 0 ? true : Boolean(opts.autoJsonMap);
        this.jsonStrings = Boolean(opts.jsonStrings) || false;
        if (opts.jsonStrings !== void 0) {
          this.autoJsonMap = !this.jsonStrings;
        }
        this.bitOneIsBoolean = opts.bitOneIsBoolean === void 0 ? true : Boolean(opts.bitOneIsBoolean);
        this.arrayParenthesis = Boolean(opts.arrayParenthesis) || false;
        this.permitSetMultiParamEntries = Boolean(opts.permitSetMultiParamEntries) || false;
        this.rowsAsArray = Boolean(opts.rowsAsArray) || false;
        this.typeCast = opts.typeCast;
        if (this.typeCast !== void 0 && typeof this.typeCast !== "function") {
          this.typeCast = void 0;
        }
        this.bulk = opts.bulk === void 0 || Boolean(opts.bulk);
        this.checkNumberRange = Boolean(opts.checkNumberRange) || false;
        if (opts.pipelining === void 0) {
          this.permitLocalInfile = Boolean(opts.permitLocalInfile) || false;
          this.pipelining = !this.permitLocalInfile;
        } else {
          this.pipelining = Boolean(opts.pipelining);
          if (opts.permitLocalInfile === true && this.pipelining) {
            throw new Error(
              "enabling options `permitLocalInfile` and `pipelining` is not possible, options are incompatible."
            );
          }
          this.permitLocalInfile = this.pipelining ? false : Boolean(opts.permitLocalInfile) || false;
        }
        this.prepareCacheLength = opts.prepareCacheLength === void 0 ? 256 : Number(opts.prepareCacheLength);
        this.restrictedAuth = opts.restrictedAuth;
        if (this.restrictedAuth != null) {
          if (!Array.isArray(this.restrictedAuth)) {
            this.restrictedAuth = this.restrictedAuth.split(",");
          }
        }
        this.bigIntAsNumber = Boolean(opts.bigIntAsNumber) || false;
        this.insertIdAsNumber = Boolean(opts.insertIdAsNumber) || false;
        this.decimalAsNumber = Boolean(opts.decimalAsNumber) || false;
        this.supportBigNumbers = Boolean(opts.supportBigNumbers) || false;
        this.bigNumberStrings = Boolean(opts.bigNumberStrings) || false;
        if (opts.maxAllowedPacket && isNaN(this.maxAllowedPacket)) {
          throw new RangeError(`maxAllowedPacket must be an integer. was '${opts.maxAllowedPacket}'`);
        }
      }
      /**
       * When parsing from String, correcting type.
       *
       * @param {object} opts - options
       * @return {object} options with corrected data types
       */
      static parseOptionDataType(opts) {
        const booleanOptions = [
          "bulk",
          "allowPublicKeyRetrieval",
          "insertIdAsNumber",
          "decimalAsNumber",
          "bigIntAsNumber",
          "permitRedirect",
          "logParam",
          "compress",
          "dateStrings",
          "debug",
          "autoJsonMap",
          "arrayParenthesis",
          "checkDuplicate",
          "debugCompress",
          "foundRows",
          "metaAsArray",
          "metaEnumerable",
          "multipleStatements",
          "namedPlaceholders",
          "nestTables",
          "permitSetMultiParamEntries",
          "pipelining",
          "forceVersionCheck",
          "rowsAsArray",
          "trace",
          "bitOneIsBoolean",
          "jsonStrings",
          "enableKeepAlive",
          "supportBigNumbers",
          "bigNumberStrings",
          "keepEof",
          "permitLocalInfile",
          "permitConnectionWhenExpired"
        ];
        booleanOptions.forEach((option) => {
          if (opts[option] !== void 0 && typeof opts[option] === "string") {
            opts[option] = opts[option] === "true";
          }
        });
        const numericOptions = [
          "charsetNumber",
          "connectTimeout",
          "keepAliveDelay",
          "socketTimeout",
          "debugLen",
          "prepareCacheLength",
          "queryTimeout",
          "maxAllowedPacket",
          "keepAliveInitialDelay",
          "port"
        ];
        numericOptions.forEach((option) => {
          if (opts[option] !== void 0 && typeof opts[option] === "string") {
            const parsedValue = parseInt(opts[option], 10);
            if (!isNaN(parsedValue)) {
              opts[option] = parsedValue;
            }
          }
        });
        if (opts.ssl !== void 0 && typeof opts.ssl === "string") {
          opts.ssl = opts.ssl === "true";
        }
        if (opts.connectAttributes !== void 0 && typeof opts.connectAttributes === "string") {
          try {
            opts.connectAttributes = JSON.parse(opts.connectAttributes);
          } catch (e) {
            throw new Error(`Failed to parse connectAttributes as JSON: ${e.message}`);
          }
        }
        if (opts.sessionVariables !== void 0 && typeof opts.sessionVariables === "string") {
          if (opts.sessionVariables.trim().startsWith("{")) {
            try {
              opts.sessionVariables = JSON.parse(opts.sessionVariables);
            } catch (e) {
            }
          }
        }
        return opts;
      }
      static parse(opts) {
        const matchResults = opts.match(urlFormat);
        if (!matchResults) {
          throw new Error(
            `error parsing connection string '${opts}'. format must be 'mariadb://[<user>[:<password>]@]<host>[:<port>]/[<db>[?<opt1>=<value1>[&<opt2>=<value2>]]]'`
          );
        }
        const options = {
          user: matchResults[2] ? decodeURIComponent(matchResults[2]) : void 0,
          password: matchResults[4] ? decodeURIComponent(matchResults[4]) : void 0,
          host: matchResults[6] ? decodeURIComponent(matchResults[6]) : matchResults[6],
          port: matchResults[8] ? parseInt(matchResults[8]) : void 0,
          database: matchResults[9] ? decodeURIComponent(matchResults[9]) : matchResults[9]
        };
        const variousOptsString = matchResults[11];
        if (variousOptsString) {
          const keyValues = variousOptsString.split("&");
          keyValues.forEach(function(keyVal) {
            const equalIdx = keyVal.indexOf("=");
            if (equalIdx !== 1) {
              let val = keyVal.substring(equalIdx + 1);
              val = val ? decodeURIComponent(val) : void 0;
              options[keyVal.substring(0, equalIdx)] = val;
            }
          });
        }
        return this.parseOptionDataType(options);
      }
    };
    module.exports = ConnectionOptions;
  }
});

// node_modules/mariadb/lib/cmd/command.js
var require_command = __commonJS({
  "node_modules/mariadb/lib/cmd/command.js"(exports, module) {
    "use strict";
    var EventEmitter = require_events();
    var Errors = require_errors();
    var Command = class extends EventEmitter {
      constructor(cmdParam, resolve, reject) {
        super();
        this.cmdParam = cmdParam;
        this.sequenceNo = -1;
        this.compressSequenceNo = -1;
        this.resolve = resolve;
        this.reject = reject;
        this.sending = false;
        this.unexpectedError = this.throwUnexpectedError.bind(this);
      }
      displaySql() {
        return null;
      }
      /**
       * Throw an unexpected error.
       * server exchange will still be read to keep connection in a good state, but promise will be rejected.
       *
       * @param msg message
       * @param fatal is error fatal for connection
       * @param info current server state information
       * @param sqlState error sqlState
       * @param errno error number
       */
      throwUnexpectedError(msg, fatal, info, sqlState, errno) {
        const err = Errors.createError(
          msg,
          errno,
          info,
          sqlState,
          this.opts && this.opts.logParam ? this.displaySql() : this.sql,
          fatal,
          this.cmdParam ? this.cmdParam.stack : null,
          false
        );
        if (this.reject) {
          process.nextTick(this.reject, err);
          this.resolve = null;
          this.reject = null;
        }
        return err;
      }
      /**
       * Create and throw new Error from error information
       * only first called throwing an error or successfully end will be executed.
       *
       * @param msg message
       * @param fatal is error fatal for connection
       * @param info current server state information
       * @param sqlState error sqlState
       * @param errno error number
       */
      throwNewError(msg, fatal, info, sqlState, errno) {
        this.onPacketReceive = null;
        const err = this.throwUnexpectedError(msg, fatal, info, sqlState, errno);
        this.emit("end");
        return err;
      }
      /**
       * When command cannot be sent due to error.
       * (this is only on start command)
       *
       * @param msg error message
       * @param errno error number
       * @param info connection information
       */
      sendCancelled(msg, errno, info) {
        const err = Errors.createError(msg, errno, info, "HY000", this.opts.logParam ? this.displaySql() : this.sql);
        this.emit("send_end");
        this.throwError(err, info);
      }
      /**
       * Throw Error
       *  only first called throwing an error or successfully end will be executed.
       *
       * @param err error to be thrown
       * @param info current server state information
       */
      throwError(err, info) {
        this.onPacketReceive = null;
        if (this.reject) {
          if (this.cmdParam && this.cmdParam.stack) {
            err = Errors.createError(
              err.text ? err.text : err.message,
              err.errno,
              info,
              err.sqlState,
              err.sql,
              err.fatal,
              this.cmdParam.stack,
              false
            );
          }
          this.resolve = null;
          process.nextTick(this.reject, err);
          this.reject = null;
        }
        this.emit("end", err);
      }
      /**
       * Successfully end command.
       * only first called throwing an error or successfully end will be executed.
       *
       * @param val return value.
       */
      successEnd(val) {
        this.onPacketReceive = null;
        if (this.resolve) {
          this.reject = null;
          process.nextTick(this.resolve, val);
          this.resolve = null;
        }
        this.emit("end");
      }
    };
    module.exports = Command;
  }
});

// node_modules/mariadb/lib/cmd/handshake/auth/plugin-auth.js
var require_plugin_auth = __commonJS({
  "node_modules/mariadb/lib/cmd/handshake/auth/plugin-auth.js"(exports, module) {
    "use strict";
    var Command = require_command();
    var PluginAuth = class extends Command {
      constructor(cmdParam, multiAuthResolver, reject) {
        super(cmdParam, multiAuthResolver, reject);
        this.onPacketReceive = multiAuthResolver;
      }
      permitHash() {
        return true;
      }
      hash(conf) {
        return null;
      }
    };
    module.exports = PluginAuth;
  }
});

// node_modules/mariadb/lib/cmd/handshake/auth/initial-handshake.js
var require_initial_handshake = __commonJS({
  "node_modules/mariadb/lib/cmd/handshake/auth/initial-handshake.js"(exports, module) {
    "use strict";
    var Capabilities = require_capabilities();
    var Collations = require_collations();
    var ConnectionInformation = require_connection_information();
    var InitialHandshake = class {
      constructor(packet, info) {
        packet.skip(1);
        info.serverVersion = {};
        info.serverVersion.raw = packet.readStringNullEnded();
        info.threadId = packet.readUInt32();
        let seed1 = packet.readBuffer(8);
        packet.skip(1);
        let serverCapabilities = BigInt(packet.readUInt16());
        info.collation = Collations.fromIndex(packet.readUInt8());
        info.status = packet.readUInt16();
        serverCapabilities += BigInt(packet.readUInt16()) << 16n;
        let saltLength = 0;
        if (serverCapabilities & Capabilities.PLUGIN_AUTH) {
          saltLength = Math.max(12, packet.readUInt8() - 9);
        } else {
          packet.skip(1);
        }
        if (serverCapabilities & Capabilities.MYSQL) {
          packet.skip(10);
        } else {
          packet.skip(6);
          serverCapabilities += BigInt(packet.readUInt32()) << 32n;
        }
        if (serverCapabilities & Capabilities.SECURE_CONNECTION) {
          let seed2 = packet.readBuffer(saltLength);
          info.seed = Buffer.concat([seed1, seed2]);
        } else {
          info.seed = seed1;
        }
        packet.skip(1);
        info.serverCapabilities = serverCapabilities;
        if (info.serverVersion.raw.startsWith("5.5.5-")) {
          info.serverVersion.mariaDb = true;
          info.serverVersion.raw = info.serverVersion.raw.substring("5.5.5-".length);
        } else {
          info.serverVersion.mariaDb = info.serverVersion.raw.includes("MariaDB") || (serverCapabilities & Capabilities.MYSQL) === 0n;
        }
        if (serverCapabilities & Capabilities.PLUGIN_AUTH) {
          this.pluginName = packet.readStringNullEnded();
        } else {
          this.pluginName = "";
        }
        ConnectionInformation.parseVersionString(info);
      }
    };
    module.exports = InitialHandshake;
  }
});

// node_modules/mariadb/lib/cmd/handshake/client-capabilities.js
var require_client_capabilities = __commonJS({
  "node_modules/mariadb/lib/cmd/handshake/client-capabilities.js"(exports, module) {
    "use strict";
    var Capabilities = require_capabilities();
    module.exports.init = function(opts, info) {
      let capabilities = Capabilities.IGNORE_SPACE | Capabilities.PROTOCOL_41 | Capabilities.TRANSACTIONS | Capabilities.SECURE_CONNECTION | Capabilities.MULTI_RESULTS | Capabilities.PS_MULTI_RESULTS | Capabilities.SESSION_TRACK | Capabilities.CONNECT_ATTRS | Capabilities.PLUGIN_AUTH_LENENC_CLIENT_DATA | Capabilities.MARIADB_CLIENT_EXTENDED_METADATA | Capabilities.PLUGIN_AUTH;
      if (opts.foundRows) {
        capabilities |= Capabilities.FOUND_ROWS;
      }
      if (opts.permitLocalInfile) {
        capabilities |= Capabilities.LOCAL_FILES;
      }
      if (opts.multipleStatements) {
        capabilities |= Capabilities.MULTI_STATEMENTS;
      }
      info.eofDeprecated = !opts.keepEof && (info.serverCapabilities & Capabilities.DEPRECATE_EOF) > 0;
      if (info.eofDeprecated) {
        capabilities |= Capabilities.DEPRECATE_EOF;
      }
      if (opts.database && info.serverCapabilities & Capabilities.CONNECT_WITH_DB) {
        capabilities |= Capabilities.CONNECT_WITH_DB;
      }
      info.serverPermitSkipMeta = (info.serverCapabilities & Capabilities.MARIADB_CLIENT_CACHE_METADATA) > 0;
      if (info.serverPermitSkipMeta) {
        capabilities |= Capabilities.MARIADB_CLIENT_CACHE_METADATA;
      }
      if (opts.compress) {
        if (info.serverCapabilities & Capabilities.COMPRESS) {
          capabilities |= Capabilities.COMPRESS;
        } else {
          opts.compress = false;
        }
      }
      if (opts.bulk && info.serverCapabilities & Capabilities.MARIADB_CLIENT_STMT_BULK_OPERATIONS) {
        capabilities |= Capabilities.MARIADB_CLIENT_STMT_BULK_OPERATIONS;
        capabilities |= Capabilities.BULK_UNIT_RESULTS;
      }
      if (opts.permitConnectionWhenExpired) {
        capabilities |= Capabilities.CAN_HANDLE_EXPIRED_PASSWORDS;
      }
      info.clientCapabilities = capabilities & info.serverCapabilities;
    };
  }
});

// node_modules/mariadb/lib/cmd/handshake/ssl-request.js
var require_ssl_request = __commonJS({
  "node_modules/mariadb/lib/cmd/handshake/ssl-request.js"(exports, module) {
    "use strict";
    var Capabilities = require_capabilities();
    module.exports.send = function sendSSLRequest(cmd, out, info, opts) {
      out.startPacket(cmd);
      out.writeInt32(Number(info.clientCapabilities & BigInt(4294967295)));
      out.writeInt32(1024 * 1024 * 1024);
      out.writeInt8(opts.collation && opts.collation.index <= 255 ? opts.collation.index : 224);
      for (let i = 0; i < 19; i++) {
        out.writeInt8(0);
      }
      if (info.serverCapabilities & Capabilities.MYSQL) {
        out.writeInt32(0);
      } else {
        out.writeInt32(Number(info.clientCapabilities >> 32n));
      }
      out.flushPacket();
    };
  }
});

// node_modules/mariadb/lib/cmd/handshake/auth/native-password-auth.js
var require_native_password_auth = __commonJS({
  "node_modules/mariadb/lib/cmd/handshake/auth/native-password-auth.js"(exports, module) {
    "use strict";
    var PluginAuth = require_plugin_auth();
    var Crypto = require_crypto();
    var NativePasswordAuth = class _NativePasswordAuth extends PluginAuth {
      constructor(packSeq, compressPackSeq, pluginData, cmdParam, reject, multiAuthResolver) {
        super(cmdParam, multiAuthResolver, reject);
        this.pluginData = pluginData;
        this.sequenceNo = packSeq;
        this.compressSequenceNo = compressPackSeq;
      }
      start(out, opts, info) {
        const data = this.pluginData.slice(0, 20);
        let authToken = _NativePasswordAuth.encryptSha1Password(opts.password, data);
        out.startPacket(this);
        if (authToken.length > 0) {
          out.writeBuffer(authToken, 0, authToken.length);
          out.flushPacket();
        } else {
          out.writeEmptyPacket(true);
        }
        this.emit("send_end");
      }
      static encryptSha1Password(password, seed2) {
        if (!password) return Buffer.alloc(0);
        let hash = Crypto.createHash("sha1");
        let stage1 = hash.update(password, "utf8").digest();
        hash = Crypto.createHash("sha1");
        let stage2 = hash.update(stage1).digest();
        hash = Crypto.createHash("sha1");
        hash.update(seed2);
        hash.update(stage2);
        let digest = hash.digest();
        let returnBytes = Buffer.allocUnsafe(digest.length);
        for (let i = 0; i < digest.length; i++) {
          returnBytes[i] = stage1[i] ^ digest[i];
        }
        return returnBytes;
      }
      permitHash() {
        return true;
      }
      hash(conf) {
        let hash = Crypto.createHash("sha1");
        let stage1 = hash.update(conf.password, "utf8").digest();
        hash = Crypto.createHash("sha1");
        return hash.update(stage1).digest();
      }
    };
    module.exports = NativePasswordAuth;
  }
});

// node_modules/mariadb/lib/cmd/handshake/auth/handshake.js
var require_handshake = __commonJS({
  "node_modules/mariadb/lib/cmd/handshake/auth/handshake.js"(exports, module) {
    var PluginAuth = require_plugin_auth();
    var InitialHandshake = require_initial_handshake();
    var ClientCapabilities = require_client_capabilities();
    var Capabilities = require_capabilities();
    var SslRequest = require_ssl_request();
    var Errors = require_errors();
    var NativePasswordAuth = require_native_password_auth();
    var os = require_os();
    var Iconv = require_lib();
    var Crypto = require_crypto();
    var driverVersion = require_package().version;
    var Handshake = class _Handshake extends PluginAuth {
      constructor(auth, getSocket, multiAuthResolver, reject) {
        super(null, multiAuthResolver, reject);
        this.sequenceNo = 0;
        this.compressSequenceNo = 0;
        this.auth = auth;
        this.getSocket = getSocket;
        this.counter = 0;
        this.onPacketReceive = this.parseHandshakeInit;
      }
      start(out, opts, info) {
      }
      parseHandshakeInit(packet, out, opts, info) {
        if (packet.peek() === 255) {
          const authErr = packet.readError(info);
          authErr.fatal = true;
          return this.throwError(authErr, info);
        }
        let handshake = new InitialHandshake(packet, info);
        ClientCapabilities.init(opts, info);
        this.pluginName = handshake.pluginName;
        if (opts.ssl) {
          if (info.serverCapabilities & Capabilities.SSL) {
            info.clientCapabilities |= Capabilities.SSL;
            SslRequest.send(this, out, info, opts);
            this.auth._createSecureContext(info, () => {
              const secureSocket = this.getSocket();
              info.selfSignedCertificate = !secureSocket.authorized;
              info.tlsAuthorizationError = secureSocket.authorizationError;
              const serverCert = secureSocket.getPeerCertificate(false);
              info.tlsCert = serverCert;
              info.tlsFingerprint = serverCert ? serverCert.fingerprint256.replace(/:/gi, "").toLowerCase() : null;
              _Handshake.send.call(this, this, out, opts, handshake.pluginName, info);
            });
          } else {
            return this.throwNewError(
              "Trying to connect with ssl, but ssl not enabled in the server",
              true,
              info,
              "08S01",
              Errors.ER_SERVER_SSL_DISABLED
            );
          }
        } else {
          _Handshake.send(this, out, opts, handshake.pluginName, info);
        }
        this.onPacketReceive = this.auth.handshakeResult.bind(this.auth);
      }
      permitHash() {
        return this.pluginName !== "mysql_clear_password";
      }
      hash(conf) {
        let hash = Crypto.createHash("sha1");
        let stage1 = hash.update(conf.password, "utf8").digest();
        hash = Crypto.createHash("sha1");
        return hash.update(stage1).digest();
      }
      /**
       * Send Handshake response packet
       * see https://mariadb.com/kb/en/library/1-connecting-connecting/#handshake-response-packet
       *
       * @param cmd         current handshake command
       * @param out         output writer
       * @param opts        connection options
       * @param pluginName  plugin name
       * @param info        connection information
       */
      static send(cmd, out, opts, pluginName, info) {
        out.startPacket(cmd);
        info.defaultPluginName = pluginName;
        const pwd = Array.isArray(opts.password) ? opts.password[0] : opts.password;
        let authToken;
        let authPlugin;
        switch (pluginName) {
          case "mysql_clear_password":
            authToken = Buffer.from(pwd);
            authPlugin = "mysql_clear_password";
            break;
          default:
            authToken = NativePasswordAuth.encryptSha1Password(pwd, info.seed);
            authPlugin = "mysql_native_password";
            break;
        }
        out.writeInt32(Number(info.clientCapabilities & BigInt(4294967295)));
        out.writeInt32(1024 * 1024 * 1024);
        out.writeInt8(opts.collation && opts.collation.index <= 255 ? opts.collation.index : 224);
        for (let i = 0; i < 19; i++) {
          out.writeInt8(0);
        }
        out.writeInt32(Number(info.clientCapabilities >> 32n));
        out.writeString(opts.user || "");
        out.writeInt8(0);
        if (info.serverCapabilities & Capabilities.PLUGIN_AUTH_LENENC_CLIENT_DATA) {
          out.writeLengthCoded(authToken.length);
          out.writeBuffer(authToken, 0, authToken.length);
        } else if (info.serverCapabilities & Capabilities.SECURE_CONNECTION) {
          out.writeInt8(authToken.length);
          out.writeBuffer(authToken, 0, authToken.length);
        } else {
          out.writeBuffer(authToken, 0, authToken.length);
          out.writeInt8(0);
        }
        if (info.clientCapabilities & Capabilities.CONNECT_WITH_DB) {
          out.writeString(opts.database);
          out.writeInt8(0);
          info.database = opts.database;
        }
        if (info.clientCapabilities & Capabilities.PLUGIN_AUTH) {
          out.writeString(authPlugin);
          out.writeInt8(0);
        }
        if (info.clientCapabilities & Capabilities.CONNECT_ATTRS) {
          out.writeInt8(252);
          let initPos = out.pos;
          out.writeInt16(0);
          const encoding = info.collation ? info.collation.charset : "utf8";
          _Handshake.writeAttribute(out, "_client_name", encoding);
          _Handshake.writeAttribute(out, "MariaDB connector/Node", encoding);
          _Handshake.writeAttribute(out, "_client_version", encoding);
          _Handshake.writeAttribute(out, driverVersion, encoding);
          const address = cmd.getSocket().address().address;
          if (address) {
            _Handshake.writeAttribute(out, "_server_host", encoding);
            _Handshake.writeAttribute(out, address, encoding);
          }
          _Handshake.writeAttribute(out, "_os", encoding);
          _Handshake.writeAttribute(out, process.platform, encoding);
          _Handshake.writeAttribute(out, "_client_host", encoding);
          _Handshake.writeAttribute(out, os.hostname(), encoding);
          _Handshake.writeAttribute(out, "_node_version", encoding);
          _Handshake.writeAttribute(out, process.versions.node, encoding);
          if (opts.connectAttributes !== true) {
            let attrNames = Object.keys(opts.connectAttributes);
            for (let k = 0; k < attrNames.length; ++k) {
              _Handshake.writeAttribute(out, attrNames[k], encoding);
              _Handshake.writeAttribute(out, opts.connectAttributes[attrNames[k]], encoding);
            }
          }
          out.writeInt16AtPos(initPos);
        }
        out.flushPacket();
      }
      static writeAttribute(out, val, encoding) {
        let param = Buffer.isEncoding(encoding) ? Buffer.from(val, encoding) : Iconv.encode(val, encoding);
        out.writeLengthCoded(param.length);
        out.writeBuffer(param, 0, param.length);
      }
    };
    module.exports = Handshake;
  }
});

// node_modules/mariadb/lib/const/state-change.js
var require_state_change = __commonJS({
  "node_modules/mariadb/lib/const/state-change.js"(exports, module) {
    module.exports.SESSION_TRACK_SYSTEM_VARIABLES = 0;
    module.exports.SESSION_TRACK_SCHEMA = 1;
    module.exports.SESSION_TRACK_STATE_CHANGE = 2;
    module.exports.SESSION_TRACK_GTIDS = 3;
    module.exports.SESSION_TRACK_TRANSACTION_CHARACTERISTICS = 4;
    module.exports.SESSION_TRACK_TRANSACTION_STATE = 5;
  }
});

// node_modules/mariadb/lib/cmd/handshake/auth/clear-password-auth.js
var require_clear_password_auth = __commonJS({
  "node_modules/mariadb/lib/cmd/handshake/auth/clear-password-auth.js"(exports, module) {
    var PluginAuth = require_plugin_auth();
    var ClearPasswordAuth = class extends PluginAuth {
      constructor(packSeq, compressPackSeq, pluginData, cmdParam, reject, multiAuthResolver) {
        super(cmdParam, multiAuthResolver, reject);
        this.sequenceNo = packSeq;
        this.compressSequenceNo = compressPackSeq;
        this.counter = 0;
        this.multiAuthResolver = multiAuthResolver;
      }
      start(out, opts, info) {
        out.startPacket(this);
        const pwd = opts.password;
        if (pwd) {
          if (Array.isArray(pwd)) {
            out.writeString(pwd[this.counter++]);
          } else {
            out.writeString(pwd);
          }
        }
        out.writeInt8(0);
        out.flushPacket();
        this.onPacketReceive = this.response;
      }
      response(packet, out, opts, info) {
        const marker = packet.peek();
        switch (marker) {
          //*********************************************************************************************************
          //* OK_Packet and Err_Packet ending packet
          //*********************************************************************************************************
          case 0:
          case 255:
            this.emit("send_end");
            return this.multiAuthResolver(packet, out, opts, info);
          default:
            packet.readBuffer();
            out.startPacket(this);
            out.writeString("password");
            out.writeInt8(0);
            out.flushPacket();
        }
      }
    };
    module.exports = ClearPasswordAuth;
  }
});

// node_modules/mariadb/lib/cmd/handshake/auth/ed25519-password-auth.js
var require_ed25519_password_auth = __commonJS({
  "node_modules/mariadb/lib/cmd/handshake/auth/ed25519-password-auth.js"(exports, module) {
    "use strict";
    var PluginAuth = require_plugin_auth();
    var Crypto = require_crypto();
    var Ed25519PasswordAuth = class _Ed25519PasswordAuth extends PluginAuth {
      constructor(packSeq, compressPackSeq, pluginData, cmdParam, reject, multiAuthResolver) {
        super(cmdParam, multiAuthResolver, reject);
        this.pluginData = pluginData;
        this.sequenceNo = packSeq;
        this.compressSequenceNo = compressPackSeq;
      }
      start(out, opts, info) {
        const data = this.pluginData;
        const sign = _Ed25519PasswordAuth.encryptPassword(opts.password, data);
        out.startPacket(this);
        out.writeBuffer(sign, 0, sign.length);
        out.flushPacket();
        this.emit("send_end");
      }
      static encryptPassword(password, seed2) {
        if (!password) return Buffer.alloc(0);
        let i, j;
        let p = [gf(), gf(), gf(), gf()];
        const signedMsg = Buffer.alloc(96);
        const bytePwd = Buffer.from(password);
        let hash = Crypto.createHash("sha512");
        const d = hash.update(bytePwd).digest();
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        for (i = 0; i < 32; i++) signedMsg[64 + i] = seed2[i];
        for (i = 0; i < 32; i++) signedMsg[32 + i] = d[32 + i];
        hash = Crypto.createHash("sha512");
        const r = hash.update(signedMsg.subarray(32, 96)).digest();
        reduce(r);
        scalarbase(p, r);
        pack(signedMsg, p);
        p = [gf(), gf(), gf(), gf()];
        scalarbase(p, d);
        const tt = Buffer.alloc(32);
        pack(tt, p);
        for (i = 32; i < 64; i++) signedMsg[i] = tt[i - 32];
        hash = Crypto.createHash("sha512");
        const h = hash.update(signedMsg).digest();
        reduce(h);
        const x = new Float64Array(64);
        for (i = 0; i < 64; i++) x[i] = 0;
        for (i = 0; i < 32; i++) x[i] = r[i];
        for (i = 0; i < 32; i++) {
          for (j = 0; j < 32; j++) {
            x[i + j] += h[i] * d[j];
          }
        }
        modL(signedMsg.subarray(32), x);
        return signedMsg.subarray(0, 64);
      }
      permitHash() {
        return true;
      }
      hash(conf) {
        let i;
        let p = [gf(), gf(), gf(), gf()];
        const signedMsg = Buffer.alloc(96);
        const bytePwd = Buffer.from(conf.password);
        let hash = Crypto.createHash("sha512");
        const d = hash.update(bytePwd).digest();
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        for (i = 0; i < 32; i++) signedMsg[64 + i] = seed[i];
        for (i = 0; i < 32; i++) signedMsg[32 + i] = d[32 + i];
        hash = Crypto.createHash("sha512");
        const r = hash.update(signedMsg.subarray(32, 96)).digest();
        reduce(r);
        scalarbase(p, r);
        return r;
      }
    };
    var gf = function(init) {
      const r = new Float64Array(16);
      if (init) for (let i = 0; i < init.length; i++) r[i] = init[i];
      return r;
    };
    var gf0 = gf();
    var gf1 = gf([1]);
    var D2 = gf([
      61785,
      9906,
      39828,
      60374,
      45398,
      33411,
      5274,
      224,
      53552,
      61171,
      33010,
      6542,
      64743,
      22239,
      55772,
      9222
    ]);
    var X = gf([
      54554,
      36645,
      11616,
      51542,
      42930,
      38181,
      51040,
      26924,
      56412,
      64982,
      57905,
      49316,
      21502,
      52590,
      14035,
      8553
    ]);
    var Y = gf([
      26200,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214,
      26214
    ]);
    var L = new Float64Array([
      237,
      211,
      245,
      92,
      26,
      99,
      18,
      88,
      214,
      156,
      247,
      162,
      222,
      249,
      222,
      20,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      16
    ]);
    function reduce(r) {
      const x = new Float64Array(64);
      let i;
      for (i = 0; i < 64; i++) x[i] = r[i];
      for (i = 0; i < 64; i++) r[i] = 0;
      modL(r, x);
    }
    function modL(r, x) {
      let carry, i, j, k;
      for (i = 63; i >= 32; --i) {
        carry = 0;
        for (j = i - 32, k = i - 12; j < k; ++j) {
          x[j] += carry - 16 * x[i] * L[j - (i - 32)];
          carry = x[j] + 128 >> 8;
          x[j] -= carry * 256;
        }
        x[j] += carry;
        x[i] = 0;
      }
      carry = 0;
      for (j = 0; j < 32; j++) {
        x[j] += carry - (x[31] >> 4) * L[j];
        carry = x[j] >> 8;
        x[j] &= 255;
      }
      for (j = 0; j < 32; j++) x[j] -= carry * L[j];
      for (i = 0; i < 32; i++) {
        x[i + 1] += x[i] >> 8;
        r[i] = x[i] & 255;
      }
    }
    function scalarbase(p, s) {
      const q = [gf(), gf(), gf(), gf()];
      set25519(q[0], X);
      set25519(q[1], Y);
      set25519(q[2], gf1);
      M(q[3], X, Y);
      scalarmult(p, q, s);
    }
    function set25519(r, a) {
      for (let i = 0; i < 16; i++) r[i] = a[i] | 0;
    }
    function M(o, a, b) {
      let v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0;
      const b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
      v = a[0];
      t0 += v * b0;
      t1 += v * b1;
      t2 += v * b2;
      t3 += v * b3;
      t4 += v * b4;
      t5 += v * b5;
      t6 += v * b6;
      t7 += v * b7;
      t8 += v * b8;
      t9 += v * b9;
      t10 += v * b10;
      t11 += v * b11;
      t12 += v * b12;
      t13 += v * b13;
      t14 += v * b14;
      t15 += v * b15;
      v = a[1];
      t1 += v * b0;
      t2 += v * b1;
      t3 += v * b2;
      t4 += v * b3;
      t5 += v * b4;
      t6 += v * b5;
      t7 += v * b6;
      t8 += v * b7;
      t9 += v * b8;
      t10 += v * b9;
      t11 += v * b10;
      t12 += v * b11;
      t13 += v * b12;
      t14 += v * b13;
      t15 += v * b14;
      t16 += v * b15;
      v = a[2];
      t2 += v * b0;
      t3 += v * b1;
      t4 += v * b2;
      t5 += v * b3;
      t6 += v * b4;
      t7 += v * b5;
      t8 += v * b6;
      t9 += v * b7;
      t10 += v * b8;
      t11 += v * b9;
      t12 += v * b10;
      t13 += v * b11;
      t14 += v * b12;
      t15 += v * b13;
      t16 += v * b14;
      t17 += v * b15;
      v = a[3];
      t3 += v * b0;
      t4 += v * b1;
      t5 += v * b2;
      t6 += v * b3;
      t7 += v * b4;
      t8 += v * b5;
      t9 += v * b6;
      t10 += v * b7;
      t11 += v * b8;
      t12 += v * b9;
      t13 += v * b10;
      t14 += v * b11;
      t15 += v * b12;
      t16 += v * b13;
      t17 += v * b14;
      t18 += v * b15;
      v = a[4];
      t4 += v * b0;
      t5 += v * b1;
      t6 += v * b2;
      t7 += v * b3;
      t8 += v * b4;
      t9 += v * b5;
      t10 += v * b6;
      t11 += v * b7;
      t12 += v * b8;
      t13 += v * b9;
      t14 += v * b10;
      t15 += v * b11;
      t16 += v * b12;
      t17 += v * b13;
      t18 += v * b14;
      t19 += v * b15;
      v = a[5];
      t5 += v * b0;
      t6 += v * b1;
      t7 += v * b2;
      t8 += v * b3;
      t9 += v * b4;
      t10 += v * b5;
      t11 += v * b6;
      t12 += v * b7;
      t13 += v * b8;
      t14 += v * b9;
      t15 += v * b10;
      t16 += v * b11;
      t17 += v * b12;
      t18 += v * b13;
      t19 += v * b14;
      t20 += v * b15;
      v = a[6];
      t6 += v * b0;
      t7 += v * b1;
      t8 += v * b2;
      t9 += v * b3;
      t10 += v * b4;
      t11 += v * b5;
      t12 += v * b6;
      t13 += v * b7;
      t14 += v * b8;
      t15 += v * b9;
      t16 += v * b10;
      t17 += v * b11;
      t18 += v * b12;
      t19 += v * b13;
      t20 += v * b14;
      t21 += v * b15;
      v = a[7];
      t7 += v * b0;
      t8 += v * b1;
      t9 += v * b2;
      t10 += v * b3;
      t11 += v * b4;
      t12 += v * b5;
      t13 += v * b6;
      t14 += v * b7;
      t15 += v * b8;
      t16 += v * b9;
      t17 += v * b10;
      t18 += v * b11;
      t19 += v * b12;
      t20 += v * b13;
      t21 += v * b14;
      t22 += v * b15;
      v = a[8];
      t8 += v * b0;
      t9 += v * b1;
      t10 += v * b2;
      t11 += v * b3;
      t12 += v * b4;
      t13 += v * b5;
      t14 += v * b6;
      t15 += v * b7;
      t16 += v * b8;
      t17 += v * b9;
      t18 += v * b10;
      t19 += v * b11;
      t20 += v * b12;
      t21 += v * b13;
      t22 += v * b14;
      t23 += v * b15;
      v = a[9];
      t9 += v * b0;
      t10 += v * b1;
      t11 += v * b2;
      t12 += v * b3;
      t13 += v * b4;
      t14 += v * b5;
      t15 += v * b6;
      t16 += v * b7;
      t17 += v * b8;
      t18 += v * b9;
      t19 += v * b10;
      t20 += v * b11;
      t21 += v * b12;
      t22 += v * b13;
      t23 += v * b14;
      t24 += v * b15;
      v = a[10];
      t10 += v * b0;
      t11 += v * b1;
      t12 += v * b2;
      t13 += v * b3;
      t14 += v * b4;
      t15 += v * b5;
      t16 += v * b6;
      t17 += v * b7;
      t18 += v * b8;
      t19 += v * b9;
      t20 += v * b10;
      t21 += v * b11;
      t22 += v * b12;
      t23 += v * b13;
      t24 += v * b14;
      t25 += v * b15;
      v = a[11];
      t11 += v * b0;
      t12 += v * b1;
      t13 += v * b2;
      t14 += v * b3;
      t15 += v * b4;
      t16 += v * b5;
      t17 += v * b6;
      t18 += v * b7;
      t19 += v * b8;
      t20 += v * b9;
      t21 += v * b10;
      t22 += v * b11;
      t23 += v * b12;
      t24 += v * b13;
      t25 += v * b14;
      t26 += v * b15;
      v = a[12];
      t12 += v * b0;
      t13 += v * b1;
      t14 += v * b2;
      t15 += v * b3;
      t16 += v * b4;
      t17 += v * b5;
      t18 += v * b6;
      t19 += v * b7;
      t20 += v * b8;
      t21 += v * b9;
      t22 += v * b10;
      t23 += v * b11;
      t24 += v * b12;
      t25 += v * b13;
      t26 += v * b14;
      t27 += v * b15;
      v = a[13];
      t13 += v * b0;
      t14 += v * b1;
      t15 += v * b2;
      t16 += v * b3;
      t17 += v * b4;
      t18 += v * b5;
      t19 += v * b6;
      t20 += v * b7;
      t21 += v * b8;
      t22 += v * b9;
      t23 += v * b10;
      t24 += v * b11;
      t25 += v * b12;
      t26 += v * b13;
      t27 += v * b14;
      t28 += v * b15;
      v = a[14];
      t14 += v * b0;
      t15 += v * b1;
      t16 += v * b2;
      t17 += v * b3;
      t18 += v * b4;
      t19 += v * b5;
      t20 += v * b6;
      t21 += v * b7;
      t22 += v * b8;
      t23 += v * b9;
      t24 += v * b10;
      t25 += v * b11;
      t26 += v * b12;
      t27 += v * b13;
      t28 += v * b14;
      t29 += v * b15;
      v = a[15];
      t15 += v * b0;
      t16 += v * b1;
      t17 += v * b2;
      t18 += v * b3;
      t19 += v * b4;
      t20 += v * b5;
      t21 += v * b6;
      t22 += v * b7;
      t23 += v * b8;
      t24 += v * b9;
      t25 += v * b10;
      t26 += v * b11;
      t27 += v * b12;
      t28 += v * b13;
      t29 += v * b14;
      t30 += v * b15;
      t0 += 38 * t16;
      t1 += 38 * t17;
      t2 += 38 * t18;
      t3 += 38 * t19;
      t4 += 38 * t20;
      t5 += 38 * t21;
      t6 += 38 * t22;
      t7 += 38 * t23;
      t8 += 38 * t24;
      t9 += 38 * t25;
      t10 += 38 * t26;
      t11 += 38 * t27;
      t12 += 38 * t28;
      t13 += 38 * t29;
      t14 += 38 * t30;
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      c = 1;
      v = t0 + c + 65535;
      c = Math.floor(v / 65536);
      t0 = v - c * 65536;
      v = t1 + c + 65535;
      c = Math.floor(v / 65536);
      t1 = v - c * 65536;
      v = t2 + c + 65535;
      c = Math.floor(v / 65536);
      t2 = v - c * 65536;
      v = t3 + c + 65535;
      c = Math.floor(v / 65536);
      t3 = v - c * 65536;
      v = t4 + c + 65535;
      c = Math.floor(v / 65536);
      t4 = v - c * 65536;
      v = t5 + c + 65535;
      c = Math.floor(v / 65536);
      t5 = v - c * 65536;
      v = t6 + c + 65535;
      c = Math.floor(v / 65536);
      t6 = v - c * 65536;
      v = t7 + c + 65535;
      c = Math.floor(v / 65536);
      t7 = v - c * 65536;
      v = t8 + c + 65535;
      c = Math.floor(v / 65536);
      t8 = v - c * 65536;
      v = t9 + c + 65535;
      c = Math.floor(v / 65536);
      t9 = v - c * 65536;
      v = t10 + c + 65535;
      c = Math.floor(v / 65536);
      t10 = v - c * 65536;
      v = t11 + c + 65535;
      c = Math.floor(v / 65536);
      t11 = v - c * 65536;
      v = t12 + c + 65535;
      c = Math.floor(v / 65536);
      t12 = v - c * 65536;
      v = t13 + c + 65535;
      c = Math.floor(v / 65536);
      t13 = v - c * 65536;
      v = t14 + c + 65535;
      c = Math.floor(v / 65536);
      t14 = v - c * 65536;
      v = t15 + c + 65535;
      c = Math.floor(v / 65536);
      t15 = v - c * 65536;
      t0 += c - 1 + 37 * (c - 1);
      o[0] = t0;
      o[1] = t1;
      o[2] = t2;
      o[3] = t3;
      o[4] = t4;
      o[5] = t5;
      o[6] = t6;
      o[7] = t7;
      o[8] = t8;
      o[9] = t9;
      o[10] = t10;
      o[11] = t11;
      o[12] = t12;
      o[13] = t13;
      o[14] = t14;
      o[15] = t15;
    }
    function scalarmult(p, q, s) {
      let b, i;
      set25519(p[0], gf0);
      set25519(p[1], gf1);
      set25519(p[2], gf1);
      set25519(p[3], gf0);
      for (i = 255; i >= 0; --i) {
        b = s[i / 8 | 0] >> (i & 7) & 1;
        cswap(p, q, b);
        add(q, p);
        add(p, p);
        cswap(p, q, b);
      }
    }
    function pack(r, p) {
      const tx = gf(), ty = gf(), zi = gf();
      inv25519(zi, p[2]);
      M(tx, p[0], zi);
      M(ty, p[1], zi);
      pack25519(r, ty);
      r[31] ^= par25519(tx) << 7;
    }
    function inv25519(o, i) {
      const c = gf();
      let a;
      for (a = 0; a < 16; a++) c[a] = i[a];
      for (a = 253; a >= 0; a--) {
        S(c, c);
        if (a !== 2 && a !== 4) M(c, c, i);
      }
      for (a = 0; a < 16; a++) o[a] = c[a];
    }
    function S(o, a) {
      M(o, a, a);
    }
    function par25519(a) {
      const d = new Uint8Array(32);
      pack25519(d, a);
      return d[0] & 1;
    }
    function car25519(o) {
      let i, v, c = 1;
      for (i = 0; i < 16; i++) {
        v = o[i] + c + 65535;
        c = Math.floor(v / 65536);
        o[i] = v - c * 65536;
      }
      o[0] += c - 1 + 37 * (c - 1);
    }
    function pack25519(o, n) {
      let i, j, b;
      const m = gf(), t = gf();
      for (i = 0; i < 16; i++) t[i] = n[i];
      car25519(t);
      car25519(t);
      car25519(t);
      for (j = 0; j < 2; j++) {
        m[0] = t[0] - 65517;
        for (i = 1; i < 15; i++) {
          m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
          m[i - 1] &= 65535;
        }
        m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
        b = m[15] >> 16 & 1;
        m[14] &= 65535;
        sel25519(t, m, 1 - b);
      }
      for (i = 0; i < 16; i++) {
        o[2 * i] = t[i] & 255;
        o[2 * i + 1] = t[i] >> 8;
      }
    }
    function cswap(p, q, b) {
      for (let i = 0; i < 4; i++) {
        sel25519(p[i], q[i], b);
      }
    }
    function A(o, a, b) {
      for (let i = 0; i < 16; i++) o[i] = a[i] + b[i];
    }
    function Z(o, a, b) {
      for (let i = 0; i < 16; i++) o[i] = a[i] - b[i];
    }
    function add(p, q) {
      const a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
      Z(a, p[1], p[0]);
      Z(t, q[1], q[0]);
      M(a, a, t);
      A(b, p[0], p[1]);
      A(t, q[0], q[1]);
      M(b, b, t);
      M(c, p[3], q[3]);
      M(c, c, D2);
      M(d, p[2], q[2]);
      A(d, d, d);
      Z(e, b, a);
      Z(f, d, c);
      A(g, d, c);
      A(h, b, a);
      M(p[0], e, f);
      M(p[1], h, g);
      M(p[2], g, f);
      M(p[3], e, h);
    }
    function sel25519(p, q, b) {
      const c = ~(b - 1);
      let t;
      for (let i = 0; i < 16; i++) {
        t = c & (p[i] ^ q[i]);
        p[i] ^= t;
        q[i] ^= t;
      }
    }
    module.exports = Ed25519PasswordAuth;
  }
});

// node_modules/mariadb/lib/cmd/handshake/auth/parsec-auth.js
var require_parsec_auth = __commonJS({
  "node_modules/mariadb/lib/cmd/handshake/auth/parsec-auth.js"(exports, module) {
    "use strict";
    var PluginAuth = require_plugin_auth();
    var crypto = require_crypto();
    var Errors = require_errors();
    var pkcs8Ed25519header = Buffer.from([
      48,
      46,
      2,
      1,
      0,
      48,
      5,
      6,
      3,
      43,
      101,
      112,
      4,
      34,
      4,
      32
    ]);
    var _hash;
    var ParsecAuth = class extends PluginAuth {
      constructor(packSeq, compressPackSeq, pluginData, cmdParam, reject, multiAuthResolver) {
        super(cmdParam, multiAuthResolver, reject);
        __privateAdd(this, _hash);
        this.multiAuthResolver = multiAuthResolver;
        this.pluginData = pluginData;
        this.sequenceNo = packSeq;
        this.compressSequenceNo = compressPackSeq;
      }
      start(out, opts, info) {
        if (!info.extSalt) {
          out.startPacket(this);
          out.writeEmptyPacket(true);
          this.onPacketReceive = this.requestForSalt;
        } else {
          this.parseExtSalt(Buffer.from(info.extSalt, "hex"), info);
          this.sendScramble(out, opts, info);
        }
      }
      requestForSalt(packet, out, opts, info) {
        this.parseExtSalt(packet.readBufferRemaining(), info);
        this.sendScramble(out, opts, info);
      }
      parseExtSalt(extSalt, info) {
        if (extSalt.length < 2 || extSalt[0] !== 80 || extSalt[1] > 3) {
          return this.throwError(
            Errors.createFatalError("Wrong parsec authentication format", Errors.ER_AUTHENTICATION_BAD_PACKET, info),
            info
          );
        }
        this.iterations = extSalt[1];
        this.salt = extSalt.slice(2);
      }
      sendScramble(out, opts, info) {
        const derivedKey = crypto.pbkdf2Sync(opts.password || "", this.salt, 1024 << this.iterations, 32, "sha512");
        const privateKey = toPkcs8der(derivedKey);
        const rawPublicKey = this.getEd25519PublicKeyFromPrivateKey(derivedKey);
        __privateSet(this, _hash, Buffer.concat([Buffer.from([80, this.iterations]), this.salt, rawPublicKey]));
        const client_scramble = crypto.randomBytes(32);
        const message = Buffer.concat([this.pluginData, client_scramble]);
        const signature = crypto.sign(null, message, privateKey);
        out.startPacket(this);
        out.writeBuffer(client_scramble, 0, 32);
        out.writeBuffer(signature, 0, 64);
        out.flushPacket();
        this.emit("send_end");
        this.onPacketReceive = this.multiAuthResolver;
      }
      getEd25519PublicKeyFromPrivateKey(privateKeyBuffer) {
        const privateKey = crypto.createPrivateKey({
          key: Buffer.concat([pkcs8Ed25519header, privateKeyBuffer]),
          format: "der",
          type: "pkcs8",
          name: "ed25519"
        });
        const publicKey = crypto.createPublicKey(privateKey);
        return publicKey.export({
          type: "spki",
          format: "der"
        }).subarray(-32);
      }
      permitHash() {
        return true;
      }
      hash(conf) {
        return __privateGet(this, _hash);
      }
    };
    _hash = new WeakMap();
    var toPkcs8der = (rawB64) => {
      const prefixPrivateEd25519 = Buffer.from("302e020100300506032b657004220420", "hex");
      const der = Buffer.concat([prefixPrivateEd25519, rawB64]);
      return crypto.createPrivateKey({ key: der, format: "der", type: "pkcs8" });
    };
    module.exports = ParsecAuth;
  }
});

// node_modules/mariadb/lib/cmd/handshake/auth/pam-password-auth.js
var require_pam_password_auth = __commonJS({
  "node_modules/mariadb/lib/cmd/handshake/auth/pam-password-auth.js"(exports, module) {
    var PluginAuth = require_plugin_auth();
    var PamPasswordAuth = class extends PluginAuth {
      constructor(packSeq, compressPackSeq, pluginData, cmdParam, reject, multiAuthResolver) {
        super(cmdParam, multiAuthResolver, reject);
        this.pluginData = pluginData;
        this.sequenceNo = packSeq;
        this.compressSequenceNo = compressPackSeq;
        this.counter = 0;
        this.multiAuthResolver = multiAuthResolver;
      }
      start(out, opts, info) {
        this.exchange(this.pluginData, out, opts, info);
        this.onPacketReceive = this.response;
      }
      exchange(buffer, out, opts, info) {
        out.startPacket(this);
        let pwd;
        if (Array.isArray(opts.password)) {
          pwd = opts.password[this.counter];
          this.counter++;
        } else {
          pwd = opts.password;
        }
        if (pwd) out.writeString(pwd);
        out.writeInt8(0);
        out.flushPacket();
      }
      response(packet, out, opts, info) {
        const marker = packet.peek();
        switch (marker) {
          //*********************************************************************************************************
          //* OK_Packet and Err_Packet ending packet
          //*********************************************************************************************************
          case 0:
          case 255:
            this.emit("send_end");
            return this.multiAuthResolver(packet, out, opts, info);
          default:
            let promptData = packet.readBuffer();
            this.exchange(promptData, out, opts, info);
            this.onPacketReceive = this.response;
        }
      }
    };
    module.exports = PamPasswordAuth;
  }
});

// node_modules/mariadb/lib/cmd/handshake/auth/sha256-password-auth.js
var require_sha256_password_auth = __commonJS({
  "node_modules/mariadb/lib/cmd/handshake/auth/sha256-password-auth.js"(exports, module) {
    var PluginAuth = require_plugin_auth();
    var fs = require_fs();
    var crypto = require_crypto();
    var Errors = require_errors();
    var Crypto = require_crypto();
    var Sha256PasswordAuth = class _Sha256PasswordAuth extends PluginAuth {
      constructor(packSeq, compressPackSeq, pluginData, cmdParam, reject, multiAuthResolver) {
        super(cmdParam, multiAuthResolver, reject);
        this.pluginData = pluginData;
        this.sequenceNo = packSeq;
        this.compressSequenceNo = compressPackSeq;
        this.counter = 0;
        this.counter = 0;
        this.initialState = true;
        this.multiAuthResolver = multiAuthResolver;
      }
      start(out, opts, info) {
        this.exchange(this.pluginData, out, opts, info);
        this.onPacketReceive = this.response;
      }
      exchange(buffer, out, opts, info) {
        if (this.initialState) {
          if (!opts.password) {
            out.startPacket(this);
            out.writeEmptyPacket(true);
            return;
          } else if (opts.ssl) {
            out.startPacket(this);
            if (opts.password) {
              out.writeString(opts.password);
            }
            out.writeInt8(0);
            out.flushPacket();
            return;
          } else {
            if (opts.rsaPublicKey) {
              try {
                let key = opts.rsaPublicKey;
                if (!key.includes("-----BEGIN")) {
                  key = fs.readFileSync(key, "utf8");
                }
                this.publicKey = _Sha256PasswordAuth.retrievePublicKey(key);
              } catch (err) {
                return this.throwError(err, info);
              }
            } else {
              if (!opts.allowPublicKeyRetrieval) {
                return this.throwError(
                  Errors.createFatalError(
                    "RSA public key is not available client side. Either set option `rsaPublicKey` to indicate public key path, or allow public key retrieval with option `allowPublicKeyRetrieval`",
                    Errors.ER_CANNOT_RETRIEVE_RSA_KEY,
                    info
                  ),
                  info
                );
              }
              this.initialState = false;
              out.startPacket(this);
              out.writeInt8(1);
              out.flushPacket();
              return;
            }
          }
          _Sha256PasswordAuth.sendSha256PwdPacket(this, this.pluginData, this.publicKey, opts.password, out);
        } else {
          this.publicKey = _Sha256PasswordAuth.retrievePublicKey(buffer.toString("utf8", 1));
          _Sha256PasswordAuth.sendSha256PwdPacket(this, this.pluginData, this.publicKey, opts.password, out);
        }
      }
      static retrievePublicKey(key) {
        return key.replace("(-+BEGIN PUBLIC KEY-+\\r?\\n|\\n?-+END PUBLIC KEY-+\\r?\\n?)", "");
      }
      static sendSha256PwdPacket(cmd, pluginData, publicKey, password, out) {
        const truncatedSeed = pluginData.slice(0, pluginData.length - 1);
        out.startPacket(cmd);
        const enc = _Sha256PasswordAuth.encrypt(truncatedSeed, password, publicKey);
        out.writeBuffer(enc, 0, enc.length);
        out.flushPacket();
      }
      static encryptSha256Password(password, seed2) {
        if (!password) return Buffer.alloc(0);
        let hash = Crypto.createHash("sha256");
        let stage1 = hash.update(password, "utf8").digest();
        hash = Crypto.createHash("sha256");
        let stage2 = hash.update(stage1).digest();
        hash = Crypto.createHash("sha256");
        hash.update(stage2);
        hash.update(seed2);
        let digest = hash.digest();
        let returnBytes = Buffer.allocUnsafe(digest.length);
        for (let i = 0; i < digest.length; i++) {
          returnBytes[i] = stage1[i] ^ digest[i];
        }
        return returnBytes;
      }
      // encrypt password with public key
      static encrypt(seed2, password, publicKey) {
        const nullFinishedPwd = Buffer.from(password + "\0");
        const xorBytes = Buffer.allocUnsafe(nullFinishedPwd.length);
        const seedLength = seed2.length;
        for (let i = 0; i < xorBytes.length; i++) {
          xorBytes[i] = nullFinishedPwd[i] ^ seed2[i % seedLength];
        }
        return crypto.publicEncrypt({ key: publicKey, padding: crypto.constants.RSA_PKCS1_OAEP_PADDING }, xorBytes);
      }
      response(packet, out, opts, info) {
        const marker = packet.peek();
        switch (marker) {
          //*********************************************************************************************************
          //* OK_Packet and Err_Packet ending packet
          //*********************************************************************************************************
          case 0:
          case 255:
            this.emit("send_end");
            return this.multiAuthResolver(packet, out, opts, info);
          default:
            let promptData = packet.readBufferRemaining();
            this.exchange(promptData, out, opts, info);
            this.onPacketReceive = this.response;
        }
      }
    };
    module.exports = Sha256PasswordAuth;
  }
});

// node_modules/mariadb/lib/cmd/handshake/auth/caching-sha2-password-auth.js
var require_caching_sha2_password_auth = __commonJS({
  "node_modules/mariadb/lib/cmd/handshake/auth/caching-sha2-password-auth.js"(exports, module) {
    var PluginAuth = require_plugin_auth();
    var fs = require_fs();
    var Errors = require_errors();
    var Sha256PasswordAuth = require_sha256_password_auth();
    var State = {
      INIT: "INIT",
      FAST_AUTH_RESULT: "FAST_AUTH_RESULT",
      REQUEST_SERVER_KEY: "REQUEST_SERVER_KEY",
      SEND_AUTH: "SEND_AUTH"
    };
    var CachingSha2PasswordAuth = class extends PluginAuth {
      constructor(packSeq, compressPackSeq, pluginData, cmdParam, reject, multiAuthResolver) {
        super(cmdParam, multiAuthResolver, reject);
        this.multiAuthResolver = multiAuthResolver;
        this.pluginData = pluginData;
        this.sequenceNo = packSeq;
        this.compressSequenceNo = compressPackSeq;
        this.counter = 0;
        this.state = State.INIT;
      }
      start(out, opts, info) {
        this.exchange(this.pluginData, out, opts, info);
        this.onPacketReceive = this.response;
      }
      exchange(packet, out, opts, info) {
        switch (this.state) {
          case State.INIT:
            const truncatedSeed = this.pluginData.slice(0, this.pluginData.length - 1);
            const encPwd = Sha256PasswordAuth.encryptSha256Password(opts.password, truncatedSeed);
            out.startPacket(this);
            if (encPwd.length > 0) {
              out.writeBuffer(encPwd, 0, encPwd.length);
              out.flushPacket();
            } else {
              out.writeEmptyPacket(true);
            }
            this.state = State.FAST_AUTH_RESULT;
            return;
          case State.FAST_AUTH_RESULT:
            const fastAuthResult = packet[1];
            switch (fastAuthResult) {
              case 3:
                return;
              case 4:
                if (opts.ssl) {
                  out.startPacket(this);
                  out.writeString(opts.password);
                  out.writeInt8(0);
                  out.flushPacket();
                  return;
                }
                if (opts.cachingRsaPublicKey) {
                  try {
                    let key = opts.cachingRsaPublicKey;
                    if (!key.includes("-----BEGIN")) {
                      key = fs.readFileSync(key, "utf8");
                    }
                    this.publicKey = Sha256PasswordAuth.retrievePublicKey(key);
                  } catch (err) {
                    return this.throwError(err, info);
                  }
                  Sha256PasswordAuth.sendSha256PwdPacket(this, this.pluginData, this.publicKey, opts.password, out);
                } else {
                  if (!opts.allowPublicKeyRetrieval) {
                    return this.throwError(
                      Errors.createFatalError(
                        "RSA public key is not available client side. Either set option `cachingRsaPublicKey` to indicate public key path, or allow public key retrieval with option `allowPublicKeyRetrieval`",
                        Errors.ER_CANNOT_RETRIEVE_RSA_KEY,
                        info
                      ),
                      info
                    );
                  }
                  this.state = State.REQUEST_SERVER_KEY;
                  out.startPacket(this);
                  out.writeInt8(2);
                  out.flushPacket();
                }
            }
            return;
          case State.REQUEST_SERVER_KEY:
            this.publicKey = Sha256PasswordAuth.retrievePublicKey(packet.toString(void 0, 1));
            this.state = State.SEND_AUTH;
            Sha256PasswordAuth.sendSha256PwdPacket(this, this.pluginData, this.publicKey, opts.password, out);
            return;
        }
      }
      response(packet, out, opts, info) {
        const marker = packet.peek();
        switch (marker) {
          //*********************************************************************************************************
          //* OK_Packet and Err_Packet ending packet
          //*********************************************************************************************************
          case 0:
          case 255:
            this.emit("send_end");
            return this.multiAuthResolver(packet, out, opts, info);
          default:
            let promptData = packet.readBufferRemaining();
            this.exchange(promptData, out, opts, info);
            this.onPacketReceive = this.response;
        }
      }
    };
    module.exports = CachingSha2PasswordAuth;
  }
});

// node_modules/mariadb/lib/cmd/handshake/authentication.js
var require_authentication = __commonJS({
  "node_modules/mariadb/lib/cmd/handshake/authentication.js"(exports, module) {
    "use strict";
    var Command = require_command();
    var Errors = require_errors();
    var Capabilities = require_capabilities();
    var Handshake = require_handshake();
    var ServerStatus = require_server_status();
    var StateChange = require_state_change();
    var Collations = require_collations();
    var Crypto = require_crypto();
    var utils = require_utils();
    var tls = require_tls();
    var authenticationPlugins = {
      mysql_native_password: require_native_password_auth(),
      mysql_clear_password: require_clear_password_auth(),
      client_ed25519: require_ed25519_password_auth(),
      parsec: require_parsec_auth(),
      dialog: require_pam_password_auth(),
      sha256_password: require_sha256_password_auth(),
      caching_sha2_password: require_caching_sha2_password_auth()
    };
    var Authentication = class _Authentication extends Command {
      constructor(cmdParam, resolve, reject, _createSecureContext, getSocket) {
        super(cmdParam, resolve, reject);
        this.cmdParam = cmdParam;
        this._createSecureContext = _createSecureContext;
        this.getSocket = getSocket;
        this.plugin = new Handshake(this, getSocket, this.handshakeResult, reject);
      }
      onPacketReceive(packet, out, opts, info) {
        this.plugin.sequenceNo = this.sequenceNo;
        this.plugin.compressSequenceNo = this.compressSequenceNo;
        this.plugin.onPacketReceive(packet, out, opts, info);
      }
      /**
       * Fast-path handshake results :
       *  - if plugin was the one expected by server, server will send OK_Packet / ERR_Packet.
       *  - if not, server send an AuthSwitchRequest packet, indicating the specific PLUGIN to use with this user.
       *    dispatching to plugin handler then.
       *
       * @param packet    current packet
       * @param out       output buffer
       * @param opts      options
       * @param info      connection info
       * @returns {*}     return null if authentication succeed, depending on plugin conversation if not finished
       */
      handshakeResult(packet, out, opts, info) {
        const marker = packet.peek();
        switch (marker) {
          //*********************************************************************************************************
          //* AuthSwitchRequest packet
          //*********************************************************************************************************
          case 254:
            this.dispatchAuthSwitchRequest(packet, out, opts, info);
            return;
          //*********************************************************************************************************
          //* OK_Packet - authentication succeeded
          //*********************************************************************************************************
          case 0:
            this.plugin.onPacketReceive = null;
            packet.skip(1);
            packet.skipLengthCodedNumber();
            packet.skipLengthCodedNumber();
            info.status = packet.readUInt16();
            if (info.requireValidCert) {
              if (info.selfSignedCertificate) {
                packet.skip(2);
                if (packet.remaining()) {
                  const validationHash = packet.readBufferLengthEncoded();
                  if (validationHash.length > 0) {
                    if (!this.plugin.permitHash() || !Boolean(this.cmdParam.opts.password)) {
                      return this.throwNewError(
                        "Self signed certificates. Either set `ssl: { rejectUnauthorized: false }` (trust mode) or provide server certificate to client",
                        true,
                        info,
                        "08000",
                        Errors.ER_SELF_SIGNED_NO_PWD
                      );
                    }
                    if (this.validateFingerPrint(validationHash, info)) {
                      return this.successEnd();
                    }
                  }
                }
                return this.throwNewError("self-signed certificate", true, info, "08000", Errors.ER_SELF_SIGNED);
              } else {
                const validationFunction = opts.ssl === true || opts.ssl.checkServerIdentity === null ? tls.checkServerIdentity : opts.ssl.checkServerIdentity;
                const identityError = validationFunction(
                  typeof opts.ssl === "object" && opts.ssl.servername ? opts.ssl.servername : opts.host,
                  info.tlsCert
                );
                if (identityError) {
                  return this.throwNewError(
                    "certificate identify Error: " + identityError.message,
                    true,
                    info,
                    "08000",
                    Errors.ER_TLS_IDENTITY_ERROR
                  );
                }
              }
            }
            let mustRedirect = false;
            if (info.status & ServerStatus.SESSION_STATE_CHANGED) {
              packet.skip(2);
              packet.skipLengthCodedNumber();
              while (packet.remaining()) {
                const len = packet.readUnsignedLength();
                if (len > 0) {
                  const subPacket = packet.subPacketLengthEncoded(len);
                  while (subPacket.remaining()) {
                    const type = subPacket.readUInt8();
                    switch (type) {
                      case StateChange.SESSION_TRACK_SYSTEM_VARIABLES:
                        let subSubPacket;
                        do {
                          subSubPacket = subPacket.subPacketLengthEncoded(subPacket.readUnsignedLength());
                          const variable = subSubPacket.readStringLengthEncoded();
                          const value = subSubPacket.readStringLengthEncoded();
                          switch (variable) {
                            case "character_set_client":
                              info.collation = Collations.fromCharset(value);
                              if (info.collation === void 0) {
                                this.throwError(new Error("unknown charset : '" + value + "'"), info);
                                return;
                              }
                              opts.emit("collation", info.collation);
                              break;
                            case "redirect_url":
                              if (value !== "") {
                                mustRedirect = true;
                                info.redirect(value, this.successEnd.bind(this));
                              }
                              break;
                            case "maxscale":
                              info.maxscaleVersion = value;
                              break;
                            case "connection_id":
                              info.threadId = parseInt(value);
                              break;
                            default:
                          }
                        } while (subSubPacket.remaining() > 0);
                        break;
                      case StateChange.SESSION_TRACK_SCHEMA:
                        const subSubPacket2 = subPacket.subPacketLengthEncoded(subPacket.readUnsignedLength());
                        info.database = subSubPacket2.readStringLengthEncoded();
                        break;
                    }
                  }
                }
              }
            }
            if (!mustRedirect) this.successEnd();
            return;
          //*********************************************************************************************************
          //* ERR_Packet
          //*********************************************************************************************************
          case 255:
            this.plugin.onPacketReceive = null;
            const authErr = packet.readError(info, this.displaySql(), void 0);
            authErr.fatal = true;
            if (info.requireValidCert && info.selfSignedCertificate) {
              return this.plugin.throwNewError(
                "Self signed certificates. Either set `ssl: { rejectUnauthorized: false }` (trust mode) or provide server certificate to client",
                true,
                info,
                "08000",
                Errors.ER_SELF_SIGNED_NO_PWD
              );
            }
            return this.plugin.throwError(authErr, info);
          //*********************************************************************************************************
          //* unexpected
          //*********************************************************************************************************
          default:
            this.throwNewError(
              `Unexpected type of packet during handshake phase : ${marker}`,
              true,
              info,
              "42000",
              Errors.ER_AUTHENTICATION_BAD_PACKET
            );
        }
      }
      validateFingerPrint(validationHash, info) {
        if (validationHash.length === 0 || !info.tlsFingerprint) return false;
        if (validationHash[0] !== 1) {
          const err = Errors.createFatalError(
            `Unexpected hash format for fingerprint hash encoding`,
            Errors.ER_UNEXPECTED_PACKET,
            this.info
          );
          if (this.opts.logger.error) this.opts.logger.error(err);
          return false;
        }
        const pwdHash = this.plugin.hash(this.cmdParam.opts);
        let hash = Crypto.createHash("sha256");
        let digest = hash.update(pwdHash).update(info.seed).update(Buffer.from(info.tlsFingerprint, "hex")).digest();
        const hashHex = utils.toHexString(digest);
        const serverValidationHex = validationHash.toString("ascii", 1, validationHash.length).toLowerCase();
        return hashHex === serverValidationHex;
      }
      /**
       * Handle authentication switch request : dispatch to plugin handler.
       *
       * @param packet  packet
       * @param out     output writer
       * @param opts    options
       * @param info    connection information
       */
      dispatchAuthSwitchRequest(packet, out, opts, info) {
        let pluginName, pluginData;
        if (info.clientCapabilities & Capabilities.PLUGIN_AUTH) {
          packet.skip(1);
          if (packet.remaining()) {
            pluginName = packet.readStringNullEnded();
            pluginData = packet.readBufferRemaining();
          } else {
            pluginName = "mysql_old_password";
            pluginData = info.seed.subarray(0, 8);
          }
        } else {
          pluginName = packet.readStringNullEnded("ascii");
          pluginData = packet.readBufferRemaining();
        }
        if (info.requireValidCert && info.selfSignedCertificate && Boolean(this.cmdParam.opts.password) && !this.plugin.permitHash()) {
          return this.throwNewError(
            `Unsupported authentication plugin ${pluginName} with Self signed certificates. Either set 'ssl: { rejectUnauthorized: false }' (trust mode) or provide server certificate to client`,
            true,
            info,
            "08000",
            Errors.ER_SELF_SIGNED_BAD_PLUGIN
          );
        }
        if (opts.restrictedAuth && !opts.restrictedAuth.includes(pluginName)) {
          this.throwNewError(
            `Unsupported authentication plugin ${pluginName}. Authorized plugin: ${opts.restrictedAuth.toString()}`,
            true,
            info,
            "42000",
            Errors.ER_NOT_SUPPORTED_AUTH_PLUGIN
          );
          return;
        }
        try {
          this.plugin.emit("end");
          this.plugin.onPacketReceive = null;
          this.plugin = _Authentication.pluginHandler(
            pluginName,
            this.plugin.sequenceNo,
            this.plugin.compressSequenceNo,
            pluginData,
            info,
            opts,
            out,
            this.cmdParam,
            this.reject,
            this.handshakeResult.bind(this)
          );
          this.plugin.start(out, opts, info);
        } catch (err) {
          this.reject(err);
        }
      }
      static pluginHandler(pluginName, packSeq, compressPackSeq, pluginData, info, opts, out, cmdParam, authReject, multiAuthResolver) {
        let pluginAuth = authenticationPlugins[pluginName];
        if (!pluginAuth) {
          throw Errors.createFatalError(
            `Client does not support authentication protocol '${pluginName}' requested by server.`,
            Errors.ER_AUTHENTICATION_PLUGIN_NOT_SUPPORTED,
            info,
            "08004"
          );
        }
        return new pluginAuth(packSeq, compressPackSeq, pluginData, cmdParam, authReject, multiAuthResolver);
      }
    };
    module.exports = Authentication;
  }
});

// node_modules/mariadb/lib/cmd/quit.js
var require_quit = __commonJS({
  "node_modules/mariadb/lib/cmd/quit.js"(exports, module) {
    "use strict";
    var Command = require_command();
    var QUIT_COMMAND = new Uint8Array([1, 0, 0, 0, 1]);
    var Quit = class extends Command {
      constructor(cmdParam, resolve, reject) {
        super(cmdParam, resolve, reject);
      }
      start(out, opts, info) {
        if (opts.logger.query) opts.logger.query("QUIT");
        this.onPacketReceive = this.skipResults;
        out.fastFlush(this, QUIT_COMMAND);
        this.emit("send_end");
        this.successEnd();
      }
      skipResults(packet, out, opts, info) {
      }
    };
    module.exports = Quit;
  }
});

// node_modules/mariadb/lib/cmd/ping.js
var require_ping = __commonJS({
  "node_modules/mariadb/lib/cmd/ping.js"(exports, module) {
    "use strict";
    var Command = require_command();
    var ServerStatus = require_server_status();
    var PING_COMMAND = new Uint8Array([1, 0, 0, 0, 14]);
    var Ping = class extends Command {
      constructor(cmdParam, resolve, reject) {
        super(cmdParam, resolve, reject);
      }
      start(out, opts, info) {
        if (opts.logger.query) opts.logger.query("PING");
        this.onPacketReceive = this.readPingResponsePacket;
        out.fastFlush(this, PING_COMMAND);
        this.emit("send_end");
      }
      /**
       * Read ping response packet.
       * packet can be :
       * - an ERR_Packet
       * - an OK_Packet
       *
       * @param packet  query response
       * @param out     output writer
       * @param opts    connection options
       * @param info    connection info
       */
      readPingResponsePacket(packet, out, opts, info) {
        packet.skip(1);
        packet.skipLengthCodedNumber();
        packet.skipLengthCodedNumber();
        info.status = packet.readUInt16();
        if (info.redirectRequest && (info.status & ServerStatus.STATUS_IN_TRANS) === 0) {
          info.redirect(info.redirectRequest, this.successEnd.bind(this, null));
        } else {
          this.successEnd(null);
        }
      }
    };
    module.exports = Ping;
  }
});

// node_modules/mariadb/lib/cmd/reset.js
var require_reset = __commonJS({
  "node_modules/mariadb/lib/cmd/reset.js"(exports, module) {
    "use strict";
    var Command = require_command();
    var ServerStatus = require_server_status();
    var RESET_COMMAND = new Uint8Array([1, 0, 0, 0, 31]);
    var Reset = class extends Command {
      constructor(cmdParam, resolve, reject) {
        super(cmdParam, resolve, reject);
      }
      start(out, opts, info) {
        if (opts.logger.query) opts.logger.query("RESET");
        this.onPacketReceive = this.readResetResponsePacket;
        out.fastFlush(this, RESET_COMMAND);
        this.emit("send_end");
      }
      /**
       * Read response packet.
       * packet can be :
       * - an ERR_Packet
       * - a OK_Packet
       *
       * @param packet  query response
       * @param out     output writer
       * @param opts    connection options
       * @param info    connection info
       */
      readResetResponsePacket(packet, out, opts, info) {
        packet.skip(1);
        packet.skipLengthCodedNumber();
        packet.skipLengthCodedNumber();
        info.status = packet.readUInt16();
        if (info.redirectRequest && (info.status & ServerStatus.STATUS_IN_TRANS) === 0) {
          info.redirect(info.redirectRequest, this.successEnd.bind(this));
        } else {
          this.successEnd();
        }
      }
    };
    module.exports = Reset;
  }
});

// node_modules/mariadb/lib/const/field-type.js
var require_field_type = __commonJS({
  "node_modules/mariadb/lib/const/field-type.js"(exports, module) {
    module.exports.DECIMAL = 0;
    module.exports.TINY = 1;
    module.exports.SHORT = 2;
    module.exports.INT = 3;
    module.exports.FLOAT = 4;
    module.exports.DOUBLE = 5;
    module.exports.NULL = 6;
    module.exports.TIMESTAMP = 7;
    module.exports.BIGINT = 8;
    module.exports.INT24 = 9;
    module.exports.DATE = 10;
    module.exports.TIME = 11;
    module.exports.DATETIME = 12;
    module.exports.YEAR = 13;
    module.exports.NEWDATE = 14;
    module.exports.VARCHAR = 15;
    module.exports.BIT = 16;
    module.exports.TIMESTAMP2 = 17;
    module.exports.DATETIME2 = 18;
    module.exports.TIME2 = 19;
    module.exports.JSON = 245;
    module.exports.NEWDECIMAL = 246;
    module.exports.ENUM = 247;
    module.exports.SET = 248;
    module.exports.TINY_BLOB = 249;
    module.exports.MEDIUM_BLOB = 250;
    module.exports.LONG_BLOB = 251;
    module.exports.BLOB = 252;
    module.exports.VAR_STRING = 253;
    module.exports.STRING = 254;
    module.exports.GEOMETRY = 255;
    var typeNames = [];
    typeNames[0] = "DECIMAL";
    typeNames[1] = "TINY";
    typeNames[2] = "SHORT";
    typeNames[3] = "INT";
    typeNames[4] = "FLOAT";
    typeNames[5] = "DOUBLE";
    typeNames[6] = "NULL";
    typeNames[7] = "TIMESTAMP";
    typeNames[8] = "BIGINT";
    typeNames[9] = "INT24";
    typeNames[10] = "DATE";
    typeNames[11] = "TIME";
    typeNames[12] = "DATETIME";
    typeNames[13] = "YEAR";
    typeNames[14] = "NEWDATE";
    typeNames[15] = "VARCHAR";
    typeNames[16] = "BIT";
    typeNames[17] = "TIMESTAMP2";
    typeNames[18] = "DATETIME2";
    typeNames[19] = "TIME2";
    typeNames[245] = "JSON";
    typeNames[246] = "NEWDECIMAL";
    typeNames[247] = "ENUM";
    typeNames[248] = "SET";
    typeNames[249] = "TINY_BLOB";
    typeNames[250] = "MEDIUM_BLOB";
    typeNames[251] = "LONG_BLOB";
    typeNames[252] = "BLOB";
    typeNames[253] = "VAR_STRING";
    typeNames[254] = "STRING";
    typeNames[255] = "GEOMETRY";
    module.exports.TYPES = typeNames;
  }
});

// node_modules/mariadb/lib/const/field-detail.js
var require_field_detail = __commonJS({
  "node_modules/mariadb/lib/const/field-detail.js"(exports, module) {
    module.exports.NOT_NULL = 1;
    module.exports.PRIMARY_KEY = 2;
    module.exports.UNIQUE_KEY = 4;
    module.exports.MULTIPLE_KEY = 8;
    module.exports.BLOB = 1 << 4;
    module.exports.UNSIGNED = 1 << 5;
    module.exports.ZEROFILL_FLAG = 1 << 6;
    module.exports.BINARY_COLLATION = 1 << 7;
    module.exports.ENUM = 1 << 8;
    module.exports.AUTO_INCREMENT = 1 << 9;
    module.exports.TIMESTAMP = 1 << 10;
    module.exports.SET = 1 << 11;
    module.exports.NO_DEFAULT_VALUE_FLAG = 1 << 12;
    module.exports.ON_UPDATE_NOW_FLAG = 1 << 13;
    module.exports.NUM_FLAG = 1 << 14;
  }
});

// node_modules/mariadb/lib/cmd/column-definition.js
var require_column_definition = __commonJS({
  "node_modules/mariadb/lib/cmd/column-definition.js"(exports, module) {
    "use strict";
    var Collations = require_collations();
    var FieldType = require_field_type();
    var FieldDetails = require_field_detail();
    var Capabilities = require_capabilities();
    var _stringParser;
    var ColumnDef = class {
      constructor(packet, info, skipName) {
        __privateAdd(this, _stringParser);
        __privateSet(this, _stringParser, skipName ? new StringParser(packet) : new StringParserWithName(packet));
        if (info.clientCapabilities & Capabilities.MARIADB_CLIENT_EXTENDED_METADATA) {
          const len = packet.readUnsignedLength();
          if (len > 0) {
            const subPacket = packet.subPacketLengthEncoded(len);
            while (subPacket.remaining()) {
              switch (subPacket.readUInt8()) {
                case 0:
                  this.dataTypeName = subPacket.readAsciiStringLengthEncoded();
                  break;
                case 1:
                  this.dataTypeFormat = subPacket.readAsciiStringLengthEncoded();
                  break;
                default:
                  subPacket.skip(subPacket.readUnsignedLength());
                  break;
              }
            }
          }
        }
        packet.skip(1);
        this.collation = Collations.fromIndex(packet.readUInt16());
        this.columnLength = packet.readUInt32();
        this.columnType = packet.readUInt8();
        this.flags = packet.readUInt16();
        this.scale = packet.readUInt8();
        this.type = FieldType.TYPES[this.columnType];
      }
      __getDefaultGeomVal() {
        if (this.dataTypeName) {
          switch (this.dataTypeName) {
            case "point":
              return { type: "Point" };
            case "linestring":
              return { type: "LineString" };
            case "polygon":
              return { type: "Polygon" };
            case "multipoint":
              return { type: "MultiPoint" };
            case "multilinestring":
              return { type: "MultiLineString" };
            case "multipolygon":
              return { type: "MultiPolygon" };
            default:
              return { type: this.dataTypeName };
          }
        }
        return null;
      }
      db() {
        return __privateGet(this, _stringParser).db();
      }
      schema() {
        return __privateGet(this, _stringParser).schema();
      }
      table() {
        return __privateGet(this, _stringParser).table();
      }
      orgTable() {
        return __privateGet(this, _stringParser).orgTable();
      }
      name() {
        return __privateGet(this, _stringParser).name();
      }
      orgName() {
        return __privateGet(this, _stringParser).orgName();
      }
      signed() {
        return (this.flags & FieldDetails.UNSIGNED) === 0;
      }
      isSet() {
        return (this.flags & FieldDetails.SET) !== 0;
      }
    };
    _stringParser = new WeakMap();
    var BaseStringParser = class {
      constructor(encoding, readFct, saveBuf, initialPos) {
        this.buf = saveBuf;
        this.encoding = encoding;
        this.readString = readFct;
        this.initialPos = initialPos;
      }
      _readIdentifier(skip) {
        let pos = this.initialPos;
        while (skip-- > 0) {
          const type2 = this.buf[pos++];
          pos += type2 < 251 ? type2 : 2 + this.buf[pos] + this.buf[pos + 1] * 2 ** 8;
        }
        const type = this.buf[pos++];
        const len = type < 251 ? type : this.buf[pos++] + this.buf[pos++] * 2 ** 8;
        return this.readString(this.encoding, this.buf, pos, len);
      }
      name() {
        return this._readIdentifier(3);
      }
      db() {
        let pos = this.initialPos;
        return this.readString(this.encoding, this.buf, pos + 1, this.buf[pos]);
      }
      schema() {
        return this.db();
      }
      table() {
        let pos = this.initialPos + 1 + this.buf[this.initialPos];
        const type = this.buf[pos++];
        const len = type < 251 ? type : this.buf[pos++] + this.buf[pos++] * 2 ** 8;
        return this.readString(this.encoding, this.buf, pos, len);
      }
      orgTable() {
        return this._readIdentifier(2);
      }
      orgName() {
        return this._readIdentifier(4);
      }
    };
    var StringParser = class extends BaseStringParser {
      constructor(packet) {
        packet.skip(packet.readUInt8());
        const initPos = packet.pos;
        packet.skip(packet.readUInt8());
        packet.skip(packet.readMetadataLength());
        packet.skip(packet.readUInt8());
        packet.skip(packet.readMetadataLength());
        packet.skip(packet.readUInt8());
        super(packet.encoding, packet.constructor.readString, packet.buf, initPos);
      }
    };
    var StringParserWithName = class extends BaseStringParser {
      constructor(packet) {
        packet.skip(packet.readUInt8());
        const initPos = packet.pos;
        packet.skip(packet.readUInt8());
        packet.skip(packet.readMetadataLength());
        packet.skip(packet.readUInt8());
        const colName = packet.readStringLengthEncoded();
        packet.skip(packet.readUInt8());
        super(packet.encoding, packet.constructor.readString, packet.buf, initPos);
        __publicField(this, "colName");
        this.colName = colName;
      }
      name() {
        return this.colName;
      }
    };
    module.exports = ColumnDef;
  }
});

// node_modules/mariadb/lib/misc/parse.js
var require_parse = __commonJS({
  "node_modules/mariadb/lib/misc/parse.js"(exports, module) {
    var Errors = require_errors();
    var State = {
      Normal: 1,
      String: 2,
      SlashStarComment: 3,
      Escape: 4,
      EOLComment: 5,
      Backtick: 6,
      Placeholder: 7
      /* found placeholder */
    };
    var SLASH_BYTE = "/".charCodeAt(0);
    var STAR_BYTE = "*".charCodeAt(0);
    var BACKSLASH_BYTE = "\\".charCodeAt(0);
    var HASH_BYTE = "#".charCodeAt(0);
    var MINUS_BYTE = "-".charCodeAt(0);
    var LINE_FEED_BYTE = "\n".charCodeAt(0);
    var DBL_QUOTE_BYTE = '"'.charCodeAt(0);
    var QUOTE_BYTE = "'".charCodeAt(0);
    var RADICAL_BYTE = "`".charCodeAt(0);
    var QUESTION_MARK_BYTE = "?".charCodeAt(0);
    var COLON_BYTE = ":".charCodeAt(0);
    var SEMICOLON_BYTE = ";".charCodeAt(0);
    module.exports.splitQuery = function(query) {
      let paramPositions = [];
      let state = State.Normal;
      let lastChar = 0;
      let singleQuotes = false;
      let currentChar;
      const len = query.length;
      for (let i = 0; i < len; i++) {
        currentChar = query[i];
        if (state === State.Escape && !(currentChar === QUOTE_BYTE && singleQuotes || currentChar === DBL_QUOTE_BYTE && !singleQuotes)) {
          state = State.String;
          lastChar = currentChar;
          continue;
        }
        switch (currentChar) {
          case STAR_BYTE:
            if (state === State.Normal && lastChar === SLASH_BYTE) {
              state = State.SlashStarComment;
            }
            break;
          case SLASH_BYTE:
            if (state === State.SlashStarComment && lastChar === STAR_BYTE) {
              state = State.Normal;
            } else if (state === State.Normal && lastChar === SLASH_BYTE) {
              state = State.EOLComment;
            }
            break;
          case HASH_BYTE:
            if (state === State.Normal) {
              state = State.EOLComment;
            }
            break;
          case MINUS_BYTE:
            if (state === State.Normal && lastChar === MINUS_BYTE) {
              state = State.EOLComment;
            }
            break;
          case LINE_FEED_BYTE:
            if (state === State.EOLComment) {
              state = State.Normal;
            }
            break;
          case DBL_QUOTE_BYTE:
            if (state === State.Normal) {
              state = State.String;
              singleQuotes = false;
            } else if (state === State.String && !singleQuotes) {
              state = State.Normal;
            } else if (state === State.Escape) {
              state = State.String;
            }
            break;
          case QUOTE_BYTE:
            if (state === State.Normal) {
              state = State.String;
              singleQuotes = true;
            } else if (state === State.String && singleQuotes) {
              state = State.Normal;
            } else if (state === State.Escape) {
              state = State.String;
            }
            break;
          case BACKSLASH_BYTE:
            if (state === State.String) {
              state = State.Escape;
            }
            break;
          case QUESTION_MARK_BYTE:
            if (state === State.Normal) {
              paramPositions.push(i, ++i);
            }
            break;
          case RADICAL_BYTE:
            if (state === State.Backtick) {
              state = State.Normal;
            } else if (state === State.Normal) {
              state = State.Backtick;
            }
            break;
        }
        lastChar = currentChar;
      }
      return paramPositions;
    };
    module.exports.splitQueryPlaceholder = function(query, info, initialValues, displaySql) {
      let placeholderValues = Object.assign({}, initialValues);
      let paramPositions = [];
      let values = [];
      let state = State.Normal;
      let lastChar = 0;
      let singleQuotes = false;
      let car;
      const len = query.length;
      for (let i = 0; i < len; i++) {
        car = query[i];
        if (state === State.Escape && !(car === QUOTE_BYTE && singleQuotes || car === DBL_QUOTE_BYTE && !singleQuotes)) {
          state = State.String;
          lastChar = car;
          continue;
        }
        switch (car) {
          case STAR_BYTE:
            if (state === State.Normal && lastChar === SLASH_BYTE) {
              state = State.SlashStarComment;
            }
            break;
          case SLASH_BYTE:
            if (state === State.SlashStarComment && lastChar === STAR_BYTE) {
              state = State.Normal;
            } else if (state === State.Normal && lastChar === SLASH_BYTE) {
              state = State.EOLComment;
            }
            break;
          case HASH_BYTE:
            if (state === State.Normal) {
              state = State.EOLComment;
            }
            break;
          case MINUS_BYTE:
            if (state === State.Normal && lastChar === MINUS_BYTE) {
              state = State.EOLComment;
            }
            break;
          case LINE_FEED_BYTE:
            if (state === State.EOLComment) {
              state = State.Normal;
            }
            break;
          case DBL_QUOTE_BYTE:
            if (state === State.Normal) {
              state = State.String;
              singleQuotes = false;
            } else if (state === State.String && !singleQuotes) {
              state = State.Normal;
            } else if (state === State.Escape) {
              state = State.String;
            }
            break;
          case QUOTE_BYTE:
            if (state === State.Normal) {
              state = State.String;
              singleQuotes = true;
            } else if (state === State.String && singleQuotes) {
              state = State.Normal;
            } else if (state === State.Escape) {
              state = State.String;
            }
            break;
          case BACKSLASH_BYTE:
            if (state === State.String) {
              state = State.Escape;
            }
            break;
          case QUESTION_MARK_BYTE:
            if (state === State.Normal) {
              const key = Object.keys(placeholderValues)[0];
              values.push(placeholderValues[key]);
              delete placeholderValues[key];
              paramPositions.push(i);
              paramPositions.push(++i);
            }
            break;
          case COLON_BYTE:
            if (state === State.Normal) {
              let j = 1;
              while (i + j < len && query[i + j] >= "0".charCodeAt(0) && query[i + j] <= "9".charCodeAt(0) || query[i + j] >= "A".charCodeAt(0) && query[i + j] <= "Z".charCodeAt(0) || query[i + j] >= "a".charCodeAt(0) && query[i + j] <= "z".charCodeAt(0) || query[i + j] === "-".charCodeAt(0) || query[i + j] === "_".charCodeAt(0)) {
                j++;
              }
              paramPositions.push(i, i + j);
              const placeholderName = query.toString("utf8", i + 1, i + j);
              i += j;
              let val;
              if (placeholderName in placeholderValues) {
                val = placeholderValues[placeholderName];
                delete placeholderValues[placeholderName];
              } else {
                val = initialValues[placeholderName];
              }
              if (val === void 0) {
                throw Errors.createError(
                  `Placeholder '${placeholderName}' is not defined`,
                  Errors.ER_PLACEHOLDER_UNDEFINED,
                  info,
                  "HY000",
                  displaySql.call()
                );
              }
              values.push(val);
            }
            break;
          case RADICAL_BYTE:
            if (state === State.Backtick) {
              state = State.Normal;
            } else if (state === State.Normal) {
              state = State.Backtick;
            }
            break;
        }
        lastChar = car;
      }
      return { paramPositions, values };
    };
    module.exports.searchPlaceholder = function(sql) {
      let sqlPlaceHolder = "";
      let placeHolderIndex = [];
      let state = State.Normal;
      let lastChar = "\0";
      let singleQuotes = false;
      let lastParameterPosition = 0;
      let idx = 0;
      let car = sql.charAt(idx++);
      let placeholderName;
      while (car !== "") {
        if (state === State.Escape && !(car === "'" && singleQuotes || car === '"' && !singleQuotes)) {
          state = State.String;
          lastChar = car;
          car = sql.charAt(idx++);
          continue;
        }
        switch (car) {
          case "*":
            if (state === State.Normal && lastChar === "/") state = State.SlashStarComment;
            break;
          case "/":
            if (state === State.SlashStarComment && lastChar === "*") state = State.Normal;
            break;
          case "#":
            if (state === State.Normal) state = State.EOLComment;
            break;
          case "-":
            if (state === State.Normal && lastChar === "-") {
              state = State.EOLComment;
            }
            break;
          case "\n":
            if (state === State.EOLComment) {
              state = State.Normal;
            }
            break;
          case '"':
            if (state === State.Normal) {
              state = State.String;
              singleQuotes = false;
            } else if (state === State.String && !singleQuotes) {
              state = State.Normal;
            } else if (state === State.Escape && !singleQuotes) {
              state = State.String;
            }
            break;
          case "'":
            if (state === State.Normal) {
              state = State.String;
              singleQuotes = true;
            } else if (state === State.String && singleQuotes) {
              state = State.Normal;
              singleQuotes = false;
            } else if (state === State.Escape && singleQuotes) {
              state = State.String;
            }
            break;
          case "\\":
            if (state === State.String) state = State.Escape;
            break;
          case ":":
            if (state === State.Normal) {
              sqlPlaceHolder += sql.substring(lastParameterPosition, idx - 1) + "?";
              placeholderName = "";
              while ((car = sql.charAt(idx++)) !== "" && car >= "0" && car <= "9" || car >= "A" && car <= "Z" || car >= "a" && car <= "z" || car === "-" || car === "_") {
                placeholderName += car;
              }
              idx--;
              placeHolderIndex.push(placeholderName);
              lastParameterPosition = idx;
            }
            break;
          case "`":
            if (state === State.Backtick) {
              state = State.Normal;
            } else if (state === State.Normal) {
              state = State.Backtick;
            }
        }
        lastChar = car;
        car = sql.charAt(idx++);
      }
      if (lastParameterPosition === 0) {
        sqlPlaceHolder = sql;
      } else {
        sqlPlaceHolder += sql.substring(lastParameterPosition);
      }
      return { sql: sqlPlaceHolder, placeHolderIndex };
    };
    module.exports.validateFileName = function(sql, parameters, fileName) {
      let queryValidator = new RegExp(
        "^(\\s*\\/\\*([^\\*]|\\*[^\\/])*\\*\\/)*\\s*LOAD\\s+DATA\\s+((LOW_PRIORITY|CONCURRENT)\\s+)?LOCAL\\s+INFILE\\s+'" + fileName.replace(/\\/g, "\\\\\\\\").replace(".", "\\.") + "'",
        "i"
      );
      if (queryValidator.test(sql)) return true;
      if (parameters != null) {
        queryValidator = new RegExp(
          "^(\\s*\\/\\*([^\\*]|\\*[^\\/])*\\*\\/)*\\s*LOAD\\s+DATA\\s+((LOW_PRIORITY|CONCURRENT)\\s+)?LOCAL\\s+INFILE\\s+\\?",
          "i"
        );
        if (queryValidator.test(sql) && parameters.length > 0) {
          if (Array.isArray(parameters)) {
            return parameters[0].toLowerCase() === fileName.toLowerCase();
          }
          return parameters.toLowerCase() === fileName.toLowerCase();
        }
      }
      return false;
    };
    module.exports.parseQueries = function(bufState) {
      let state = State.Normal;
      let lastChar = 0;
      let currByte;
      let queries = [];
      let singleQuotes = false;
      for (let i = bufState.offset; i < bufState.end; i++) {
        currByte = bufState.buffer[i];
        if (state === State.Escape && !(currByte === QUOTE_BYTE && singleQuotes || currByte === DBL_QUOTE_BYTE && !singleQuotes)) {
          state = State.String;
          lastChar = currByte;
          continue;
        }
        switch (currByte) {
          case STAR_BYTE:
            if (state === State.Normal && lastChar === SLASH_BYTE) {
              state = State.SlashStarComment;
            }
            break;
          case SLASH_BYTE:
            if (state === State.SlashStarComment && lastChar === STAR_BYTE) {
              state = State.Normal;
            } else if (state === State.Normal && lastChar === SLASH_BYTE) {
              state = State.EOLComment;
            }
            break;
          case HASH_BYTE:
            if (state === State.Normal) {
              state = State.EOLComment;
            }
            break;
          case MINUS_BYTE:
            if (state === State.Normal && lastChar === MINUS_BYTE) {
              state = State.EOLComment;
            }
            break;
          case LINE_FEED_BYTE:
            if (state === State.EOLComment) {
              state = State.Normal;
            }
            break;
          case DBL_QUOTE_BYTE:
            if (state === State.Normal) {
              state = State.String;
              singleQuotes = false;
            } else if (state === State.String && !singleQuotes) {
              state = State.Normal;
            } else if (state === State.Escape) {
              state = State.String;
            }
            break;
          case QUOTE_BYTE:
            if (state === State.Normal) {
              state = State.String;
              singleQuotes = true;
            } else if (state === State.String && singleQuotes) {
              state = State.Normal;
            } else if (state === State.Escape) {
              state = State.String;
            }
            break;
          case BACKSLASH_BYTE:
            if (state === State.String) {
              state = State.Escape;
            }
            break;
          case SEMICOLON_BYTE:
            if (state === State.Normal) {
              queries.push(bufState.buffer.toString("utf8", bufState.offset, i));
              bufState.offset = i + 1;
            }
            break;
          case RADICAL_BYTE:
            if (state === State.Backtick) {
              state = State.Normal;
            } else if (state === State.Normal) {
              state = State.Backtick;
            }
            break;
        }
        lastChar = currByte;
      }
      return queries;
    };
  }
});

// node_modules/mariadb/lib/cmd/decoder/binary-decoder.js
var require_binary_decoder = __commonJS({
  "node_modules/mariadb/lib/cmd/decoder/binary-decoder.js"(exports, module) {
    "use strict";
    var FieldType = require_field_type();
    var Errors = require_errors();
    module.exports.newRow = function(packet, columns) {
      packet.skip(1);
      const len = ~~((columns.length + 9) / 8);
      const nullBitMap = new Array(len);
      for (let i = 0; i < len; i++) nullBitMap[i] = packet.readUInt8();
      return nullBitMap;
    };
    module.exports.castWrapper = function(column, packet, opts, nullBitmap, index) {
      column.string = () => isNullBitmap(index, nullBitmap) ? null : packet.readStringLengthEncoded();
      column.buffer = () => isNullBitmap(index, nullBitmap) ? null : packet.readBufferLengthEncoded();
      column.float = () => isNullBitmap(index, nullBitmap) ? null : packet.readFloat();
      column.tiny = () => isNullBitmap(index, nullBitmap) ? null : column.signed() ? packet.readInt8() : packet.readUInt8();
      column.short = () => isNullBitmap(index, nullBitmap) ? null : column.signed() ? packet.readInt16() : packet.readUInt16();
      column.int = () => isNullBitmap(index, nullBitmap) ? null : packet.readInt32();
      column.long = () => isNullBitmap(index, nullBitmap) ? null : packet.readBigInt64();
      column.decimal = () => isNullBitmap(index, nullBitmap) ? null : packet.readDecimalLengthEncoded();
      column.date = () => isNullBitmap(index, nullBitmap) ? null : packet.readBinaryDate(opts);
      column.datetime = () => isNullBitmap(index, nullBitmap) ? null : packet.readBinaryDateTime();
      column.geometry = () => {
        let defaultVal = null;
        if (column.dataTypeName) {
          switch (column.dataTypeName) {
            case "point":
              defaultVal = { type: "Point" };
              break;
            case "linestring":
              defaultVal = { type: "LineString" };
              break;
            case "polygon":
              defaultVal = { type: "Polygon" };
              break;
            case "multipoint":
              defaultVal = { type: "MultiPoint" };
              break;
            case "multilinestring":
              defaultVal = { type: "MultiLineString" };
              break;
            case "multipolygon":
              defaultVal = { type: "MultiPolygon" };
              break;
            default:
              defaultVal = { type: column.dataTypeName };
              break;
          }
        }
        if (isNullBitmap(index, nullBitmap)) {
          return defaultVal;
        }
        return packet.readGeometry(defaultVal);
      };
    };
    module.exports.parser = function(col, opts) {
      const defaultParser = col.signed() ? DEFAULT_SIGNED_PARSER_TYPE[col.columnType] : DEFAULT_UNSIGNED_PARSER_TYPE[col.columnType];
      if (defaultParser) return defaultParser;
      switch (col.columnType) {
        case FieldType.BIGINT:
          if (col.signed()) {
            return opts.bigIntAsNumber || opts.supportBigNumbers ? readBigintAsIntBinarySigned : readBigintBinarySigned;
          }
          return opts.bigIntAsNumber || opts.supportBigNumbers ? readBigintAsIntBinaryUnsigned : readBigintBinaryUnsigned;
        case FieldType.DATETIME:
        case FieldType.TIMESTAMP:
          return opts.dateStrings ? readTimestampStringBinary.bind(null, col.scale) : readTimestampBinary;
        case FieldType.DECIMAL:
        case FieldType.NEWDECIMAL:
          return col.scale === 0 ? readDecimalAsIntBinary : readDecimalBinary;
        case FieldType.GEOMETRY:
          let defaultVal = col.__getDefaultGeomVal();
          return readGeometryBinary.bind(null, defaultVal);
        case FieldType.BIT:
          if (col.columnLength === 1 && opts.bitOneIsBoolean) {
            return readBitBinaryBoolean;
          }
          return readBinaryBuffer;
        case FieldType.JSON:
          return opts.jsonStrings ? readStringBinary : readJsonBinary;
        default:
          if (col.dataTypeFormat && col.dataTypeFormat === "json" && opts.autoJsonMap) {
            return readJsonBinary;
          }
          if (col.collation.index === 63) {
            return readBinaryBuffer;
          }
          if (col.isSet()) {
            return readBinarySet;
          }
          return readStringBinary;
      }
    };
    var isNullBitmap = (index, nullBitmap) => {
      return (nullBitmap[~~((index + 2) / 8)] & 1 << (index + 2) % 8) > 0;
    };
    var readTinyBinarySigned = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readInt8();
    var readTinyBinaryUnsigned = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readUInt8();
    var readShortBinarySigned = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readInt16();
    var readShortBinaryUnsigned = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readUInt16();
    var readMediumBinarySigned = (packet, opts, throwUnexpectedError, nullBitmap, index) => {
      if (isNullBitmap(index, nullBitmap)) {
        return null;
      }
      const result = packet.readInt24();
      packet.skip(1);
      return result;
    };
    var readMediumBinaryUnsigned = (packet, opts, throwUnexpectedError, nullBitmap, index) => {
      if (isNullBitmap(index, nullBitmap)) {
        return null;
      }
      const result = packet.readUInt24();
      packet.skip(1);
      return result;
    };
    var readIntBinarySigned = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readInt32();
    var readIntBinaryUnsigned = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readUInt32();
    var readFloatBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readFloat();
    var readDoubleBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readDouble();
    var readBigintBinaryUnsigned = function(packet, opts, throwUnexpectedError, nullBitmap, index) {
      if (isNullBitmap(index, nullBitmap)) return null;
      return packet.readBigUInt64();
    };
    var readBigintBinarySigned = function(packet, opts, throwUnexpectedError, nullBitmap, index) {
      if (isNullBitmap(index, nullBitmap)) return null;
      return packet.readBigInt64();
    };
    var readBigintAsIntBinaryUnsigned = function(packet, opts, throwUnexpectedError, nullBitmap, index) {
      if (isNullBitmap(index, nullBitmap)) return null;
      const val = packet.readBigUInt64();
      if (opts.bigIntAsNumber && opts.checkNumberRange && !Number.isSafeInteger(Number(val))) {
        return throwUnexpectedError(
          `value ${val} can't safely be converted to number`,
          false,
          null,
          "42000",
          Errors.ER_PARSING_PRECISION
        );
      }
      if (opts.supportBigNumbers && (opts.bigNumberStrings || !Number.isSafeInteger(Number(val)))) {
        return val.toString();
      }
      return Number(val);
    };
    var readBigintAsIntBinarySigned = function(packet, opts, throwUnexpectedError, nullBitmap, index) {
      if (isNullBitmap(index, nullBitmap)) return null;
      const val = packet.readBigInt64();
      if (opts.bigIntAsNumber && opts.checkNumberRange && !Number.isSafeInteger(Number(val))) {
        return throwUnexpectedError(
          `value ${val} can't safely be converted to number`,
          false,
          null,
          "42000",
          Errors.ER_PARSING_PRECISION
        );
      }
      if (opts.supportBigNumbers && (opts.bigNumberStrings || !Number.isSafeInteger(Number(val)))) {
        return val.toString();
      }
      return Number(val);
    };
    var readGeometryBinary = (defaultVal, packet, opts, throwUnexpectedError, nullBitmap, index) => {
      if (isNullBitmap(index, nullBitmap)) {
        return defaultVal;
      }
      return packet.readGeometry(defaultVal);
    };
    var readDateBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readBinaryDate(opts);
    var readTimestampBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readBinaryDateTime();
    var readTimestampStringBinary = (scale, packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readBinaryDateTimeAsString(scale);
    var readTimeBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readBinaryTime();
    var readDecimalAsIntBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) => {
      if (isNullBitmap(index, nullBitmap)) return null;
      const valDec = packet.readDecimalLengthEncoded();
      if (valDec != null && (opts.decimalAsNumber || opts.supportBigNumbers)) {
        if (opts.decimalAsNumber && opts.checkNumberRange && !Number.isSafeInteger(Number(valDec))) {
          return throwUnexpectedError(
            `value ${valDec} can't safely be converted to number`,
            false,
            null,
            "42000",
            Errors.ER_PARSING_PRECISION
          );
        }
        if (opts.supportBigNumbers && (opts.bigNumberStrings || !Number.isSafeInteger(Number(valDec)))) {
          return valDec;
        }
        return Number(valDec);
      }
      return valDec;
    };
    var readDecimalBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) => {
      if (isNullBitmap(index, nullBitmap)) return null;
      const valDec = packet.readDecimalLengthEncoded();
      if (valDec != null && (opts.decimalAsNumber || opts.supportBigNumbers)) {
        const numberValue = Number(valDec);
        if (opts.supportBigNumbers && (opts.bigNumberStrings || Number.isInteger(numberValue) && !Number.isSafeInteger(numberValue))) {
          return valDec;
        }
        return numberValue;
      }
      return valDec;
    };
    var readJsonBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : JSON.parse(packet.readStringLengthEncoded());
    var readBitBinaryBoolean = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readBufferLengthEncoded()[0] === 1;
    var readBinaryBuffer = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readBufferLengthEncoded();
    var readBinarySet = (packet, opts, throwUnexpectedError, nullBitmap, index) => {
      if (isNullBitmap(index, nullBitmap)) return null;
      const string = packet.readStringLengthEncoded();
      return string == null ? null : string === "" ? [] : string.split(",");
    };
    var readStringBinary = (packet, opts, throwUnexpectedError, nullBitmap, index) => isNullBitmap(index, nullBitmap) ? null : packet.readStringLengthEncoded();
    var DEFAULT_SIGNED_PARSER_TYPE = Array(256);
    DEFAULT_SIGNED_PARSER_TYPE[FieldType.TINY] = readTinyBinarySigned;
    DEFAULT_SIGNED_PARSER_TYPE[FieldType.YEAR] = readShortBinarySigned;
    DEFAULT_SIGNED_PARSER_TYPE[FieldType.SHORT] = readShortBinarySigned;
    DEFAULT_SIGNED_PARSER_TYPE[FieldType.INT24] = readMediumBinarySigned;
    DEFAULT_SIGNED_PARSER_TYPE[FieldType.INT] = readIntBinarySigned;
    DEFAULT_SIGNED_PARSER_TYPE[FieldType.FLOAT] = readFloatBinary;
    DEFAULT_SIGNED_PARSER_TYPE[FieldType.DOUBLE] = readDoubleBinary;
    DEFAULT_SIGNED_PARSER_TYPE[FieldType.DATE] = readDateBinary;
    DEFAULT_SIGNED_PARSER_TYPE[FieldType.TIME] = readTimeBinary;
    var DEFAULT_UNSIGNED_PARSER_TYPE = Array(256);
    DEFAULT_UNSIGNED_PARSER_TYPE[FieldType.TINY] = readTinyBinaryUnsigned;
    DEFAULT_UNSIGNED_PARSER_TYPE[FieldType.YEAR] = readShortBinaryUnsigned;
    DEFAULT_UNSIGNED_PARSER_TYPE[FieldType.SHORT] = readShortBinaryUnsigned;
    DEFAULT_UNSIGNED_PARSER_TYPE[FieldType.INT24] = readMediumBinaryUnsigned;
    DEFAULT_UNSIGNED_PARSER_TYPE[FieldType.INT] = readIntBinaryUnsigned;
    DEFAULT_UNSIGNED_PARSER_TYPE[FieldType.FLOAT] = readFloatBinary;
    DEFAULT_UNSIGNED_PARSER_TYPE[FieldType.DOUBLE] = readDoubleBinary;
    DEFAULT_UNSIGNED_PARSER_TYPE[FieldType.DATE] = readDateBinary;
    DEFAULT_UNSIGNED_PARSER_TYPE[FieldType.TIME] = readTimeBinary;
  }
});

// node_modules/mariadb/lib/cmd/decoder/text-decoder.js
var require_text_decoder = __commonJS({
  "node_modules/mariadb/lib/cmd/decoder/text-decoder.js"(exports, module) {
    "use strict";
    var FieldType = require_field_type();
    var Errors = require_errors();
    module.exports.parser = function(col, opts) {
      const defaultParser = DEFAULT_PARSER_TYPE[col.columnType];
      if (defaultParser) return defaultParser;
      switch (col.columnType) {
        case FieldType.DECIMAL:
        case FieldType.NEWDECIMAL:
          return col.scale === 0 ? readDecimalAsIntLengthCoded : readDecimalLengthCoded;
        case FieldType.BIGINT:
          if (opts.bigIntAsNumber || opts.supportBigNumbers) return readBigIntAsNumberLengthCoded;
          return readBigIntLengthCoded;
        case FieldType.GEOMETRY:
          const defaultVal = col.__getDefaultGeomVal();
          return function(packet, opts2, throwUnexpectedError) {
            return packet.readGeometry(defaultVal);
          };
        case FieldType.BIT:
          if (col.columnLength === 1 && opts.bitOneIsBoolean) {
            return readBitAsBoolean;
          }
          return readBufferLengthEncoded;
        case FieldType.JSON:
          return opts.jsonStrings ? readStringLengthEncoded : readJson;
        default:
          if (col.dataTypeFormat === "json" && opts.autoJsonMap) {
            return readJson;
          }
          if (col.collation.index === 63) {
            return readBufferLengthEncoded;
          }
          if (col.isSet()) {
            return readSet;
          }
          return readStringLengthEncoded;
      }
    };
    module.exports.castWrapper = function(column, packet, opts, nullBitmap, index) {
      const p = packet;
      column.string = () => p.readStringLengthEncoded();
      column.buffer = () => p.readBufferLengthEncoded();
      column.float = () => p.readFloatLengthCoded();
      column.tiny = column.short = column.int = () => p.readIntLengthEncoded();
      column.long = () => p.readBigIntLengthEncoded();
      column.decimal = () => p.readDecimalLengthEncoded();
      column.date = () => p.readDate(opts);
      column.datetime = () => p.readDateTime();
      column.geometry = () => {
        let defaultVal = null;
        if (column.dataTypeName) {
          const geoTypes = {
            point: { type: "Point" },
            linestring: { type: "LineString" },
            polygon: { type: "Polygon" },
            multipoint: { type: "MultiPoint" },
            multilinestring: { type: "MultiLineString" },
            multipolygon: { type: "MultiPolygon" }
          };
          defaultVal = geoTypes[column.dataTypeName] || { type: column.dataTypeName };
        }
        return p.readGeometry(defaultVal);
      };
    };
    var readIntLengthEncoded = (packet, opts, throwUnexpectedError) => packet.readIntLengthEncoded();
    var readStringLengthEncoded = (packet, opts, throwUnexpectedError) => packet.readStringLengthEncoded();
    var readFloatLengthCoded = (packet, opts, throwUnexpectedError) => packet.readFloatLengthCoded();
    var readBigIntLengthCoded = (packet, opts, throwUnexpectedError) => packet.readBigIntLengthEncoded();
    var readAsciiStringLengthEncoded = (packet, opts, throwUnexpectedError) => packet.readAsciiStringLengthEncoded();
    var readBitAsBoolean = (packet, opts, throwUnexpectedError) => {
      const val = packet.readBufferLengthEncoded();
      return val == null ? null : val[0] === 1;
    };
    var readBufferLengthEncoded = (packet, opts, throwUnexpectedError) => packet.readBufferLengthEncoded();
    var readJson = (packet, opts, throwUnexpectedError) => {
      const jsonStr = packet.readStringLengthEncoded();
      return jsonStr === null ? null : JSON.parse(jsonStr);
    };
    var readSet = (packet, opts, throwUnexpectedError) => {
      const string = packet.readStringLengthEncoded();
      return string == null ? null : string === "" ? [] : string.split(",");
    };
    var readDate = (packet, opts, throwUnexpectedError) => opts.dateStrings ? packet.readAsciiStringLengthEncoded() : packet.readDate();
    var readTimestamp = (packet, opts, throwUnexpectedError) => opts.dateStrings ? packet.readAsciiStringLengthEncoded() : packet.readDateTime();
    var DEFAULT_PARSER_TYPE = new Array(256);
    DEFAULT_PARSER_TYPE[FieldType.TINY] = readIntLengthEncoded;
    DEFAULT_PARSER_TYPE[FieldType.SHORT] = readIntLengthEncoded;
    DEFAULT_PARSER_TYPE[FieldType.INT] = readIntLengthEncoded;
    DEFAULT_PARSER_TYPE[FieldType.INT24] = readIntLengthEncoded;
    DEFAULT_PARSER_TYPE[FieldType.YEAR] = readIntLengthEncoded;
    DEFAULT_PARSER_TYPE[FieldType.FLOAT] = readFloatLengthCoded;
    DEFAULT_PARSER_TYPE[FieldType.DOUBLE] = readFloatLengthCoded;
    DEFAULT_PARSER_TYPE[FieldType.DATE] = readDate;
    DEFAULT_PARSER_TYPE[FieldType.DATETIME] = readTimestamp;
    DEFAULT_PARSER_TYPE[FieldType.TIMESTAMP] = readTimestamp;
    DEFAULT_PARSER_TYPE[FieldType.TIME] = readAsciiStringLengthEncoded;
    var readBigIntAsNumberLengthCoded = (packet, opts, throwUnexpectedError) => {
      const len = packet.readUnsignedLength();
      if (len === null) return null;
      if (len < 16) {
        const val2 = packet._atoi(len);
        if (opts.supportBigNumbers && opts.bigNumberStrings) {
          return `${val2}`;
        }
        return val2;
      }
      const val = packet.readBigIntFromLen(len);
      if (opts.bigIntAsNumber && opts.checkNumberRange && !Number.isSafeInteger(Number(val))) {
        return throwUnexpectedError(
          `value ${val} can't safely be converted to number`,
          false,
          null,
          "42000",
          Errors.ER_PARSING_PRECISION
        );
      }
      const numVal = Number(val);
      if (opts.supportBigNumbers && (opts.bigNumberStrings || !Number.isSafeInteger(numVal))) {
        return val.toString();
      }
      return numVal;
    };
    var readDecimalAsIntLengthCoded = (packet, opts, throwUnexpectedError) => {
      const valDec = packet.readDecimalLengthEncoded();
      if (valDec === null) return null;
      if (!(opts.decimalAsNumber || opts.supportBigNumbers)) return valDec;
      const numValue = Number(valDec);
      if (opts.decimalAsNumber && opts.checkNumberRange && !Number.isSafeInteger(numValue)) {
        return throwUnexpectedError(
          `value ${valDec} can't safely be converted to number`,
          false,
          null,
          "42000",
          Errors.ER_PARSING_PRECISION
        );
      }
      if (opts.supportBigNumbers && (opts.bigNumberStrings || !Number.isSafeInteger(numValue))) {
        return valDec;
      }
      return numValue;
    };
    var readDecimalLengthCoded = (packet, opts, throwUnexpectedError) => {
      const valDec = packet.readDecimalLengthEncoded();
      if (valDec === null) return null;
      if (!(opts.decimalAsNumber || opts.supportBigNumbers)) return valDec;
      const numberValue = Number(valDec);
      if (opts.supportBigNumbers && (opts.bigNumberStrings || Number.isInteger(numberValue) && !Number.isSafeInteger(numberValue))) {
        return valDec;
      }
      return numberValue;
    };
  }
});

// node_modules/mariadb/lib/cmd/class/ok-packet.js
var require_ok_packet = __commonJS({
  "node_modules/mariadb/lib/cmd/class/ok-packet.js"(exports, module) {
    "use strict";
    var OkPacket = class {
      constructor(affectedRows, insertId, warningStatus) {
        this.affectedRows = affectedRows;
        this.insertId = insertId;
        this.warningStatus = warningStatus;
      }
    };
    module.exports = OkPacket;
  }
});

// node_modules/mariadb/lib/cmd/parser.js
var require_parser = __commonJS({
  "node_modules/mariadb/lib/cmd/parser.js"(exports, module) {
    "use strict";
    var Command = require_command();
    var ServerStatus = require_server_status();
    var ColumnDefinition = require_column_definition();
    var Errors = require_errors();
    var fs = require_fs();
    var Parse = require_parse();
    var BinaryDecoder = require_binary_decoder();
    var TextDecoder = require_text_decoder();
    var OkPacket = require_ok_packet();
    var StateChange = require_state_change();
    var Collations = require_collations();
    var privateFields = /* @__PURE__ */ new Set([
      "__defineGetter__",
      "__defineSetter__",
      "__lookupGetter__",
      "__lookupSetter__",
      "__proto__"
    ]);
    var Parser = class _Parser extends Command {
      /**
       * Create a new Parser instance
       *
       * @param {Function} resolve - Promise resolve function
       * @param {Function} reject - Promise reject function
       * @param {Object} connOpts - Connection options
       * @param {Object} cmdParam - Command parameters
       */
      constructor(resolve, reject, connOpts, cmdParam) {
        super(cmdParam, resolve, reject);
        this._responseIndex = 0;
        this._rows = [];
        this.opts = cmdParam.opts ? Object.assign({}, connOpts, cmdParam.opts) : connOpts;
        this.sql = cmdParam.sql;
        this.initialValues = cmdParam.values;
        this.canSkipMeta = false;
      }
      /**
       * Read Query response packet.
       * Packet can be:
       * - a result-set
       * - an ERR_Packet
       * - an OK_Packet
       * - LOCAL_INFILE Packet
       *
       * @param {Object} packet - Query response packet
       * @param {Object} out - Output writer
       * @param {Object} opts - Connection options
       * @param {Object} info - Connection info
       * @returns {Function|null} Next packet handler or null
       */
      readResponsePacket(packet, out, opts, info) {
        switch (packet.peek()) {
          case 0:
            return this.readOKPacket(packet, out, opts, info);
          case 255:
            return this.handleErrorPacket(packet, info);
          case 251:
            return this.readLocalInfile(packet, out, opts, info);
          default:
            return this.readResultSet(packet, info);
        }
      }
      /**
       * Handle error packet
       *
       * @param {Object} packet - Error packet
       * @param {Object} info - Connection info
       * @returns {null} Always returns null
       * @private
       */
      handleErrorPacket(packet, info) {
        this._columns = null;
        const err = packet.readError(info, this.opts.logParam ? this.displaySql() : this.sql, this.cmdParam.stack);
        info.status |= ServerStatus.STATUS_IN_TRANS;
        return this.throwError(err, info);
      }
      /**
       * Read result-set packets
       * @see https://mariadb.com/kb/en/library/resultset/
       *
       * @param {Object} packet - Column count packet
       * @param {Object} info - Connection information
       * @returns {Function} Next packet handler
       */
      readResultSet(packet, info) {
        this._columnCount = packet.readUnsignedLength();
        this._rows.push([]);
        if (this.canSkipMeta && info.serverPermitSkipMeta && packet.readUInt8() === 0) {
          return this.handleSkippedMeta(info);
        }
        this._columns = [];
        return this.onPacketReceive = this.readColumn;
      }
      /**
       * Handle skipped metadata case
       *
       * @param {Object} info - Connection information
       * @returns {Function} Next packet handler
       * @private
       */
      handleSkippedMeta(info) {
        this._columns = this.prepare.columns;
        this._columnCount = this._columns.length;
        this.emit("fields", this._columns);
        this.setParser();
        return this.onPacketReceive = info.eofDeprecated ? this.readResultSetRow : this.readIntermediateEOF;
      }
      /**
       * Read OK_Packet
       * @see https://mariadb.com/kb/en/library/ok_packet/
       *
       * @param {Object} packet - OK_Packet
       * @param {Object} out - Output writer
       * @param {Object} opts - Connection options
       * @param {Object} info - Connection information
       * @returns {Function|null} Next packet handler or null
       */
      readOKPacket(packet, out, opts, info) {
        packet.skip(1);
        const affectedRows = packet.readUnsignedLength();
        let insertId = this.processInsertId(packet.readInsertId(), info);
        info.status = packet.readUInt16();
        const okPacket = new OkPacket(affectedRows, insertId, packet.readUInt16());
        let mustRedirect = false;
        if (info.status & ServerStatus.SESSION_STATE_CHANGED) {
          mustRedirect = this.processSessionStateChanges(packet, info, opts);
        }
        if (this.inStream) {
          this.handleNewRows(okPacket);
        }
        if (mustRedirect) {
          return null;
        }
        if (info.redirectRequest && (info.status & ServerStatus.STATUS_IN_TRANS) === 0 && (info.status & ServerStatus.MORE_RESULTS_EXISTS) === 0) {
          info.redirect(info.redirectRequest, this.okPacketSuccess.bind(this, okPacket, info));
        } else {
          this.okPacketSuccess(okPacket, info);
        }
        return null;
      }
      /**
       * Process insertId based on connection options
       *
       * @param {BigInt} insertId - Raw insertId from packet
       * @param {Object} info - Connection info
       * @returns {BigInt|Number|String} Processed insertId
       * @private
       */
      processInsertId(insertId, info) {
        if (this.opts.supportBigNumbers || this.opts.insertIdAsNumber) {
          if (this.opts.insertIdAsNumber && this.opts.checkNumberRange && !Number.isSafeInteger(Number(insertId))) {
            this.onPacketReceive = info.status & ServerStatus.MORE_RESULTS_EXISTS ? this.readResponsePacket : null;
            this.throwUnexpectedError(
              `last insert id value ${insertId} can't safely be converted to number`,
              false,
              info,
              "42000",
              Errors.ER_PARSING_PRECISION
            );
            return insertId;
          }
          if (this.opts.supportBigNumbers && (this.opts.bigNumberStrings || !Number.isSafeInteger(Number(insertId)))) {
            return insertId.toString();
          } else {
            return Number(insertId);
          }
        }
        return insertId;
      }
      /**
       * Process session state changes
       *
       * @param {Object} packet - Packet containing session state changes
       * @param {Object} info - Connection information
       * @param {Object} opts - Connection options
       * @returns {Boolean} True if redirection is needed
       * @private
       */
      processSessionStateChanges(packet, info, opts) {
        let mustRedirect = false;
        packet.skipLengthCodedNumber();
        while (packet.remaining()) {
          const len = packet.readUnsignedLength();
          if (len > 0) {
            const subPacket = packet.subPacketLengthEncoded(len);
            while (subPacket.remaining()) {
              const type = subPacket.readUInt8();
              switch (type) {
                case StateChange.SESSION_TRACK_SYSTEM_VARIABLES:
                  mustRedirect = this.processSystemVariables(subPacket, info, opts) || mustRedirect;
                  break;
                case StateChange.SESSION_TRACK_SCHEMA:
                  info.database = this.readSchemaChange(subPacket);
                  break;
              }
            }
          }
        }
        return mustRedirect;
      }
      /**
       * Process system variables changes
       *
       * @param {Object} subPacket - Packet containing system variables
       * @param {Object} info - Connection information
       * @param {Object} opts - Connection options
       * @returns {Boolean} True if redirection is needed
       * @private
       */
      processSystemVariables(subPacket, info, opts) {
        let mustRedirect = false;
        let subSubPacket;
        do {
          subSubPacket = subPacket.subPacketLengthEncoded(subPacket.readUnsignedLength());
          const variable = subSubPacket.readStringLengthEncoded();
          const value = subSubPacket.readStringLengthEncoded();
          switch (variable) {
            case "character_set_client":
              info.collation = Collations.fromCharset(value);
              if (info.collation === void 0) {
                this.throwError(new Error(`unknown charset: '${value}'`), info);
                return false;
              }
              opts.emit("collation", info.collation);
              break;
            case "redirect_url":
              if (value !== "") {
                mustRedirect = true;
                info.redirect(value, this.okPacketSuccess.bind(this, this.okPacket, info));
              }
              break;
            case "connection_id":
              info.threadId = parseInt(value);
              break;
          }
        } while (subSubPacket.remaining() > 0);
        return mustRedirect;
      }
      /**
       * Read schema change from packet
       *
       * @param {Object} subPacket - Packet containing schema change
       * @returns {String} New schema name
       * @private
       */
      readSchemaChange(subPacket) {
        const subSubPacket = subPacket.subPacketLengthEncoded(subPacket.readUnsignedLength());
        return subSubPacket.readStringLengthEncoded();
      }
      /**
       * Handle OK packet success
       *
       * @param {Object} okPacket - OK packet
       * @param {Object} info - Connection information
       */
      okPacketSuccess(okPacket, info) {
        if (this._responseIndex === 0) {
          if (info.status & ServerStatus.MORE_RESULTS_EXISTS) {
            this._rows.push(okPacket);
            this._responseIndex++;
            return this.onPacketReceive = this.readResponsePacket;
          }
          return this.success(this.opts.metaAsArray ? [okPacket, []] : okPacket);
        }
        this._rows.push(okPacket);
        if (info.status & ServerStatus.MORE_RESULTS_EXISTS) {
          this._responseIndex++;
          return this.onPacketReceive = this.readResponsePacket;
        }
        if (this.opts.metaAsArray) {
          if (!this._meta) {
            this._meta = new Array(this._responseIndex);
          }
          this._meta[this._responseIndex] = null;
          this.success([this._rows, this._meta]);
        } else {
          this.success(this._rows);
        }
      }
      /**
       * Complete query with success
       *
       * @param {*} val - Result value
       */
      success(val) {
        this.successEnd(val);
        this._columns = null;
        this._rows = [];
      }
      /**
       * Read column information metadata
       * @see https://mariadb.com/kb/en/library/resultset/#column-definition-packet
       *
       * @param {Object} packet - Column definition packet
       * @param {Object} out - Output writer
       * @param {Object} opts - Connection options
       * @param {Object} info - Connection information
       */
      readColumn(packet, out, opts, info) {
        this._columns.push(new ColumnDefinition(packet, info, this.opts.rowsAsArray));
        if (this._columns.length === this._columnCount) {
          this.setParser();
          if (this.canSkipMeta && info.serverPermitSkipMeta && this.prepare != null) {
            if (this._responseIndex === 0) this.prepare.columns = this._columns;
          }
          this.emit("fields", this._columns);
          this.onPacketReceive = info.eofDeprecated ? this.readResultSetRow : this.readIntermediateEOF;
        }
      }
      /**
       * Set up row parsers based on column information
       */
      setParser() {
        this._parseFunction = new Array(this._columnCount);
        if (this.opts.typeCast) {
          for (let i = 0; i < this._columnCount; i++) {
            this._parseFunction[i] = this.readCastValue.bind(this, this._columns[i]);
          }
        } else {
          const dataParser = this.binary ? BinaryDecoder.parser : TextDecoder.parser;
          for (let i = 0; i < this._columnCount; i++) {
            this._parseFunction[i] = dataParser(this._columns[i], this.opts);
          }
        }
        if (this.opts.rowsAsArray) {
          this.parseRow = this.parseRowAsArray;
        } else {
          this.tableHeader = new Array(this._columnCount);
          this.parseRow = this.binary ? this.parseRowStdBinary : this.parseRowStdText;
          if (this.opts.nestTables) {
            this.configureNestedTables();
          } else {
            for (let i = 0; i < this._columnCount; i++) {
              this.tableHeader[i] = this._columns[i].name();
            }
            this.checkDuplicates();
          }
        }
      }
      /**
       * Configure nested tables format
       * @private
       */
      configureNestedTables() {
        if (typeof this.opts.nestTables === "string") {
          for (let i = 0; i < this._columnCount; i++) {
            this.tableHeader[i] = this._columns[i].table() + this.opts.nestTables + this._columns[i].name();
          }
          this.checkDuplicates();
        } else if (this.opts.nestTables === true) {
          this.parseRow = this.parseRowNested;
          for (let i = 0; i < this._columnCount; i++) {
            this.tableHeader[i] = [this._columns[i].table(), this._columns[i].name()];
          }
          this.checkNestTablesDuplicatesAndPrivateFields();
        }
      }
      /**
       * Check for duplicate column names
       */
      checkDuplicates() {
        if (this.opts.checkDuplicate) {
          for (let i = 0; i < this._columnCount; i++) {
            if (this.tableHeader.indexOf(this.tableHeader[i], i + 1) > 0) {
              const dupes = this.tableHeader.reduce(
                (acc, v, i2, arr) => arr.indexOf(v) !== i2 && acc.indexOf(v) === -1 ? acc.concat(v) : acc,
                []
              );
              this.throwUnexpectedError(
                `Error in results, duplicate field name \`${dupes[0]}\`.
(see option \`checkDuplicate\`)`,
                false,
                null,
                "42000",
                Errors.ER_DUPLICATE_FIELD
              );
            }
          }
        }
      }
      /**
       * Check for duplicates and private fields in nested tables
       */
      checkNestTablesDuplicatesAndPrivateFields() {
        if (this.opts.checkDuplicate) {
          for (let i = 0; i < this._columnCount; i++) {
            for (let j = 0; j < i; j++) {
              if (this.tableHeader[j][0] === this.tableHeader[i][0] && this.tableHeader[j][1] === this.tableHeader[i][1]) {
                this.throwUnexpectedError(
                  `Error in results, duplicate field name \`${this.tableHeader[i][0]}\`.\`${this.tableHeader[i][1]}\`
(see option \`checkDuplicate\`)`,
                  false,
                  null,
                  "42000",
                  Errors.ER_DUPLICATE_FIELD
                );
              }
            }
          }
        }
        for (let i = 0; i < this._columnCount; i++) {
          if (privateFields.has(this.tableHeader[i][0])) {
            this.throwUnexpectedError(
              `Use of \`${this.tableHeader[i][0]}\` is not permitted with option \`nestTables\``,
              false,
              null,
              "42000",
              Errors.ER_PRIVATE_FIELDS_USE
            );
            this.parseRow = () => {
              return {};
            };
          }
        }
      }
      /**
       * Read intermediate EOF
       * Only for server before MariaDB 10.2 / MySQL 5.7 that doesn't have CLIENT_DEPRECATE_EOF capability
       * @see https://mariadb.com/kb/en/library/eof_packet/
       *
       * @param {Object} packet - EOF Packet
       * @param {Object} out - Output writer
       * @param {Object} opts - Connection options
       * @param {Object} info - Connection information
       * @returns {Function|null} Next packet handler or null
       */
      readIntermediateEOF(packet, out, opts, info) {
        if (packet.peek() !== 254) {
          return this.throwNewError("Error in protocol, expected EOF packet", true, info, "42000", Errors.ER_EOF_EXPECTED);
        }
        packet.skip(3);
        info.status = packet.readUInt16();
        this.isOutParameter = info.status & ServerStatus.PS_OUT_PARAMS;
        return this.onPacketReceive = this.readResultSetRow;
      }
      /**
       * Add new rows to the result set
       *
       * @param {Object} row - Row data
       */
      handleNewRows(row) {
        this._rows[this._responseIndex].push(row);
      }
      /**
       * Check if packet is result-set end = EOF of OK_Packet with EOF header according to CLIENT_DEPRECATE_EOF capability
       * or a result-set row
       *
       * @param packet    current packet
       * @param out       output writer
       * @param opts      connection options
       * @param info      connection information
       * @returns {*}
       */
      readResultSetRow(packet, out, opts, info) {
        if (packet.peek() >= 254) {
          if (packet.peek() === 255) {
            info.status |= ServerStatus.STATUS_IN_TRANS;
            return this.throwError(
              packet.readError(info, this.opts.logParam ? this.displaySql() : this.sql, this.cmdParam.err),
              info
            );
          }
          if (!info.eofDeprecated && packet.length() < 13 || info.eofDeprecated && packet.length() < 16777215) {
            if (!info.eofDeprecated) {
              packet.skip(3);
              info.status = packet.readUInt16();
            } else {
              packet.skip(1);
              packet.skipLengthCodedNumber();
              packet.skipLengthCodedNumber();
              info.status = packet.readUInt16();
            }
            if (info.redirectRequest && (info.status & ServerStatus.STATUS_IN_TRANS) === 0 && (info.status & ServerStatus.MORE_RESULTS_EXISTS) === 0) {
              info.redirect(info.redirectRequest, this.resultSetEndingPacketResult.bind(this, info));
            } else {
              this.resultSetEndingPacketResult(info);
            }
            return;
          }
        }
        this.handleNewRows(this.parseRow(packet));
      }
      resultSetEndingPacketResult(info) {
        if (this.opts.metaAsArray) {
          if (info.status & ServerStatus.MORE_RESULTS_EXISTS || this.isOutParameter) {
            if (!this._meta) this._meta = [];
            this._meta[this._responseIndex] = this._columns;
            this._responseIndex++;
            return this.onPacketReceive = this.readResponsePacket;
          }
          if (this._responseIndex === 0) {
            this.success([this._rows[0], this._columns]);
          } else {
            if (!this._meta) this._meta = [];
            this._meta[this._responseIndex] = this._columns;
            this.success([this._rows, this._meta]);
          }
        } else {
          Object.defineProperty(this._rows[this._responseIndex], "meta", {
            value: this._columns,
            writable: true,
            enumerable: this.opts.metaEnumerable
          });
          if (info.status & ServerStatus.MORE_RESULTS_EXISTS || this.isOutParameter) {
            this._responseIndex++;
            return this.onPacketReceive = this.readResponsePacket;
          }
          this.success(this._responseIndex === 0 ? this._rows[0] : this._rows);
        }
      }
      /**
       * Display current SQL with parameters (truncated if too big)
       *
       * @returns {string}
       */
      displaySql() {
        if (this.opts && this.initialValues) {
          if (this.sql.length > this.opts.debugLen) {
            return this.sql.substring(0, this.opts.debugLen) + "...";
          }
          let sqlMsg = this.sql + " - parameters:";
          return _Parser.logParameters(this.opts, sqlMsg, this.initialValues);
        }
        if (this.sql.length > this.opts.debugLen) {
          return this.sql.substring(0, this.opts.debugLen) + "... - parameters:[]";
        }
        return this.sql + " - parameters:[]";
      }
      static logParameters(opts, sqlMsg, values) {
        if (opts.namedPlaceholders) {
          sqlMsg += "{";
          let first = true;
          for (let key in values) {
            if (first) {
              first = false;
            } else {
              sqlMsg += ",";
            }
            sqlMsg += "'" + key + "':";
            let param = values[key];
            sqlMsg = _Parser.logParam(sqlMsg, param);
            if (sqlMsg.length > opts.debugLen) {
              return sqlMsg.substring(0, opts.debugLen) + "...";
            }
          }
          sqlMsg += "}";
        } else {
          sqlMsg += "[";
          if (Array.isArray(values)) {
            for (let i = 0; i < values.length; i++) {
              if (i !== 0) sqlMsg += ",";
              let param = values[i];
              sqlMsg = _Parser.logParam(sqlMsg, param);
              if (sqlMsg.length > opts.debugLen) {
                return sqlMsg.substring(0, opts.debugLen) + "...";
              }
            }
          } else {
            sqlMsg = _Parser.logParam(sqlMsg, values);
            if (sqlMsg.length > opts.debugLen) {
              return sqlMsg.substring(0, opts.debugLen) + "...";
            }
          }
          sqlMsg += "]";
        }
        return sqlMsg;
      }
      parseRowAsArray(packet) {
        const row = new Array(this._columnCount);
        const nullBitMap = this.binary ? BinaryDecoder.newRow(packet, this._columns) : null;
        for (let i = 0; i < this._columnCount; i++) {
          row[i] = this._parseFunction[i](packet, this.opts, this.unexpectedError, nullBitMap, i);
        }
        return row;
      }
      parseRowNested(packet) {
        const row = {};
        const nullBitMap = this.binary ? BinaryDecoder.newRow(packet, this._columns) : null;
        for (let i = 0; i < this._columnCount; i++) {
          if (!row[this.tableHeader[i][0]]) row[this.tableHeader[i][0]] = {};
          row[this.tableHeader[i][0]][this.tableHeader[i][1]] = this._parseFunction[i](
            packet,
            this.opts,
            this.unexpectedError,
            nullBitMap,
            i
          );
        }
        return row;
      }
      parseRowStdText(packet) {
        const row = {};
        for (let i = 0; i < this._columnCount; i++) {
          row[this.tableHeader[i]] = this._parseFunction[i](packet, this.opts, this.unexpectedError);
        }
        return row;
      }
      parseRowStdBinary(packet) {
        const nullBitMap = BinaryDecoder.newRow(packet, this._columns);
        const row = {};
        for (let i = 0; i < this._columnCount; i++) {
          row[this.tableHeader[i]] = this._parseFunction[i](packet, this.opts, this.unexpectedError, nullBitMap, i);
        }
        return row;
      }
      readCastValue(column, packet, opts, unexpectedError, nullBitmap, index) {
        if (this.binary) {
          BinaryDecoder.castWrapper(column, packet, opts, nullBitmap, index);
        } else {
          TextDecoder.castWrapper(column, packet, opts, nullBitmap, index);
        }
        const dataParser = this.binary ? BinaryDecoder.parser : TextDecoder.parser;
        return opts.typeCast(column, dataParser(column, opts).bind(null, packet, opts, unexpectedError, nullBitmap, index));
      }
      readLocalInfile(packet, out, opts, info) {
        packet.skip(1);
        out.startPacket(this);
        const fileName = packet.readStringRemaining();
        if (!Parse.validateFileName(this.sql, this.initialValues, fileName)) {
          out.writeEmptyPacket();
          const error = Errors.createError(
            "LOCAL INFILE wrong filename. '" + fileName + "' doesn't correspond to query " + this.sql + ". Query cancelled. Check for malicious server / proxy",
            Errors.ER_LOCAL_INFILE_WRONG_FILENAME,
            info,
            "HY000",
            this.sql
          );
          process.nextTick(this.reject, error);
          this.reject = null;
          this.resolve = null;
          return this.onPacketReceive = this.readResponsePacket;
        }
        let stream;
        try {
          stream = this.opts.infileStreamFactory ? this.opts.infileStreamFactory(fileName) : fs.createReadStream(fileName);
        } catch (e) {
          out.writeEmptyPacket();
          const error = Errors.createError(
            `LOCAL INFILE infileStreamFactory failed`,
            Errors.ER_LOCAL_INFILE_NOT_READABLE,
            info,
            "22000",
            this.opts.logParam ? this.displaySql() : this.sql
          );
          error.cause = e;
          process.nextTick(this.reject, error);
          this.reject = null;
          this.resolve = null;
          return this.onPacketReceive = this.readResponsePacket;
        }
        stream.on(
          "error",
          (function(err) {
            out.writeEmptyPacket();
            const error = Errors.createError(
              `LOCAL INFILE command failed: ${err.message}`,
              Errors.ER_LOCAL_INFILE_NOT_READABLE,
              info,
              "22000",
              this.sql
            );
            process.nextTick(this.reject, error);
            this.reject = null;
            this.resolve = null;
          }).bind(this)
        );
        stream.on("data", (chunk) => {
          out.writeBuffer(chunk, 0, chunk.length);
        });
        stream.on("end", () => {
          if (!out.isEmpty()) {
            out.flushBuffer(false);
          }
          out.writeEmptyPacket();
        });
        this.onPacketReceive = this.readResponsePacket;
      }
      static logParam(sqlMsg, param) {
        if (param == null) {
          sqlMsg += param === void 0 ? "undefined" : "null";
        } else {
          switch (param.constructor.name) {
            case "Buffer":
              sqlMsg += "0x" + param.toString("hex", 0, Math.min(1024, param.length));
              break;
            case "String":
              sqlMsg += "'" + param + "'";
              break;
            case "Date":
              sqlMsg += getStringDate(param);
              break;
            case "Object":
              sqlMsg += JSON.stringify(param);
              break;
            default:
              sqlMsg += param.toString();
          }
        }
        return sqlMsg;
      }
    };
    function getStringDate(param) {
      return "'" + ("00" + (param.getMonth() + 1)).slice(-2) + "/" + ("00" + param.getDate()).slice(-2) + "/" + param.getFullYear() + " " + ("00" + param.getHours()).slice(-2) + ":" + ("00" + param.getMinutes()).slice(-2) + ":" + ("00" + param.getSeconds()).slice(-2) + "." + ("000" + param.getMilliseconds()).slice(-3) + "'";
    }
    module.exports = Parser;
  }
});

// node_modules/mariadb/lib/cmd/query.js
var require_query = __commonJS({
  "node_modules/mariadb/lib/cmd/query.js"(exports, module) {
    "use strict";
    var Parser = require_parser();
    var Errors = require_errors();
    var Parse = require_parse();
    var TextEncoder = require_text_encoder();
    var { Readable } = require_stream();
    var QUOTE = 39;
    var Query = class extends Parser {
      constructor(resolve, reject, connOpts, cmdParam) {
        super(resolve, reject, connOpts, cmdParam);
        this.binary = false;
      }
      /**
       * Send COM_QUERY
       *
       * @param out   output writer
       * @param opts  connection options
       * @param info  connection information
       */
      start(out, opts, info) {
        if (opts.logger.query) opts.logger.query(`QUERY: ${opts.logParam ? this.displaySql() : this.sql}`);
        this.onPacketReceive = this.readResponsePacket;
        if (this.initialValues === void 0) {
          out.startPacket(this);
          out.writeInt8(3);
          if (!this.handleTimeout(out, info)) return;
          out.writeString(this.sql);
          out.flush();
          this.emit("send_end");
          return;
        }
        this.encodedSql = out.encodeString(this.sql);
        if (this.opts.namedPlaceholders) {
          try {
            const parsed = Parse.splitQueryPlaceholder(
              this.encodedSql,
              info,
              this.initialValues,
              this.opts.logParam ? this.displaySql.bind(this) : () => this.sql
            );
            this.paramPositions = parsed.paramPositions;
            this.values = parsed.values;
          } catch (err) {
            this.emit("send_end");
            return this.throwError(err, info);
          }
        } else {
          this.paramPositions = Parse.splitQuery(this.encodedSql);
          this.values = Array.isArray(this.initialValues) ? this.initialValues : [this.initialValues];
          if (!this.validateParameters(info)) return;
        }
        out.startPacket(this);
        out.writeInt8(3);
        if (!this.handleTimeout(out, info)) return;
        this.paramPos = 0;
        this.sqlPos = 0;
        const len = this.paramPositions.length / 2;
        for (this.valueIdx = 0; this.valueIdx < len; ) {
          out.writeBuffer(this.encodedSql, this.sqlPos, this.paramPositions[this.paramPos++] - this.sqlPos);
          this.sqlPos = this.paramPositions[this.paramPos++];
          const value = this.values[this.valueIdx++];
          if (value == null) {
            out.writeStringAscii("NULL");
            continue;
          }
          switch (typeof value) {
            case "boolean":
              out.writeStringAscii(value ? "true" : "false");
              break;
            case "bigint":
            case "number":
              out.writeStringAscii(`${value}`);
              break;
            case "string":
              out.writeStringEscapeQuote(value);
              break;
            case "object":
              if (typeof value.pipe === "function" && typeof value.read === "function") {
                this.sending = true;
                this.paramWritten = this._paramWritten.bind(this, out, info);
                out.writeInt8(QUOTE);
                value.on("data", out.writeBufferEscape.bind(out));
                value.on(
                  "end",
                  (function() {
                    out.writeInt8(QUOTE);
                    this.paramWritten();
                  }).bind(this)
                );
                return;
              }
              if (Object.prototype.toString.call(value) === "[object Date]") {
                out.writeStringAscii(TextEncoder.getLocalDate(value));
              } else if (Buffer.isBuffer(value)) {
                out.writeStringAscii("_BINARY '");
                out.writeBufferEscape(value);
                out.writeInt8(QUOTE);
              } else if (typeof value.toSqlString === "function") {
                out.writeStringEscapeQuote(String(value.toSqlString()));
              } else if (Array.isArray(value)) {
                if (opts.arrayParenthesis) {
                  out.writeStringAscii("(");
                }
                for (let i = 0; i < value.length; i++) {
                  if (i !== 0) out.writeStringAscii(",");
                  if (value[i] == null) {
                    out.writeStringAscii("NULL");
                  } else TextEncoder.writeParam(out, value[i], opts, info);
                }
                if (opts.arrayParenthesis) {
                  out.writeStringAscii(")");
                }
              } else {
                if (value.type != null && [
                  "Point",
                  "LineString",
                  "Polygon",
                  "MultiPoint",
                  "MultiLineString",
                  "MultiPolygon",
                  "GeometryCollection"
                ].includes(value.type)) {
                  let prefix = info.isMariaDB() && info.hasMinVersion(10, 1, 4) || !info.isMariaDB() && info.hasMinVersion(5, 7, 6) ? "ST_" : "";
                  switch (value.type) {
                    case "Point":
                      out.writeStringAscii(
                        prefix + "PointFromText('POINT(" + TextEncoder.geoPointToString(value.coordinates) + ")')"
                      );
                      break;
                    case "LineString":
                      out.writeStringAscii(
                        prefix + "LineFromText('LINESTRING(" + TextEncoder.geoArrayPointToString(value.coordinates) + ")')"
                      );
                      break;
                    case "Polygon":
                      out.writeStringAscii(
                        prefix + "PolygonFromText('POLYGON(" + TextEncoder.geoMultiArrayPointToString(value.coordinates) + ")')"
                      );
                      break;
                    case "MultiPoint":
                      out.writeStringAscii(
                        prefix + "MULTIPOINTFROMTEXT('MULTIPOINT(" + TextEncoder.geoArrayPointToString(value.coordinates) + ")')"
                      );
                      break;
                    case "MultiLineString":
                      out.writeStringAscii(
                        prefix + "MLineFromText('MULTILINESTRING(" + TextEncoder.geoMultiArrayPointToString(value.coordinates) + ")')"
                      );
                      break;
                    case "MultiPolygon":
                      out.writeStringAscii(
                        prefix + "MPolyFromText('MULTIPOLYGON(" + TextEncoder.geoMultiPolygonToString(value.coordinates) + ")')"
                      );
                      break;
                    case "GeometryCollection":
                      out.writeStringAscii(
                        prefix + "GeomCollFromText('GEOMETRYCOLLECTION(" + TextEncoder.geometricCollectionToString(value.geometries) + ")')"
                      );
                      break;
                  }
                } else if (String === value.constructor) {
                  out.writeStringEscapeQuote(value);
                  break;
                } else {
                  if (opts.permitSetMultiParamEntries) {
                    let first = true;
                    for (let key in value) {
                      const val = value[key];
                      if (typeof val === "function") continue;
                      if (first) {
                        first = false;
                      } else {
                        out.writeStringAscii(",");
                      }
                      out.writeString("`" + key + "`");
                      if (val == null) {
                        out.writeStringAscii("=NULL");
                      } else {
                        out.writeStringAscii("=");
                        TextEncoder.writeParam(out, val, opts, info);
                      }
                    }
                    if (first) out.writeStringEscapeQuote(JSON.stringify(value));
                  } else {
                    out.writeStringEscapeQuote(JSON.stringify(value));
                  }
                }
              }
              break;
          }
        }
        out.writeBuffer(this.encodedSql, this.sqlPos, this.encodedSql.length - this.sqlPos);
        out.flush();
        this.emit("send_end");
      }
      /**
       * If timeout is set, prepend query with SET STATEMENT max_statement_time=xx FOR, or throw an error
       * @param out buffer
       * @param info server information
       * @returns {boolean} false if an error has been thrown
       */
      handleTimeout(out, info) {
        if (this.opts.timeout) {
          if (info.isMariaDB()) {
            if (info.hasMinVersion(10, 1, 2)) {
              out.writeString(`SET STATEMENT max_statement_time=${this.opts.timeout / 1e3} FOR `);
              return true;
            } else {
              this.sendCancelled(
                `Cannot use timeout for xpand/MariaDB server before 10.1.2. timeout value: ${this.opts.timeout}`,
                Errors.ER_TIMEOUT_NOT_SUPPORTED,
                info
              );
              return false;
            }
          } else {
            this.sendCancelled(
              `Cannot use timeout for MySQL server. timeout value: ${this.opts.timeout}`,
              Errors.ER_TIMEOUT_NOT_SUPPORTED,
              info
            );
            return false;
          }
        }
        return true;
      }
      /**
       * Validate that parameters exists and are defined.
       *
       * @param info        connection info
       * @returns {boolean} return false if any error occur.
       */
      validateParameters(info) {
        if (this.paramPositions.length / 2 > this.values.length) {
          this.sendCancelled(
            `Parameter at position ${this.values.length + 1} is not set`,
            Errors.ER_MISSING_PARAMETER,
            info
          );
          return false;
        }
        return true;
      }
      _paramWritten(out, info) {
        while (true) {
          if (this.valueIdx === this.paramPositions.length / 2) {
            out.writeBuffer(this.encodedSql, this.sqlPos, this.encodedSql.length - this.sqlPos);
            out.flush();
            this.sending = false;
            this.emit("send_end");
            return;
          } else {
            const value = this.values[this.valueIdx++];
            out.writeBuffer(this.encodedSql, this.sqlPos, this.paramPositions[this.paramPos++] - this.sqlPos);
            this.sqlPos = this.paramPositions[this.paramPos++];
            if (value == null) {
              out.writeStringAscii("NULL");
              continue;
            }
            if (typeof value === "object" && typeof value.pipe === "function" && typeof value.read === "function") {
              out.writeInt8(QUOTE);
              value.once(
                "end",
                (function() {
                  out.writeInt8(QUOTE);
                  this._paramWritten(out, info);
                }).bind(this)
              );
              value.on("data", out.writeBufferEscape.bind(out));
              return;
            }
            TextEncoder.writeParam(out, value, this.opts, info);
          }
        }
      }
      _stream(socket, options) {
        this.socket = socket;
        options = options || {};
        options.objectMode = true;
        options.read = () => {
          this.socket.resume();
        };
        this.inStream = new Readable(options);
        this.on("fields", function(meta) {
          this.inStream.emit("fields", meta);
        });
        this.on("error", function(err) {
          this.inStream.emit("error", err);
        });
        this.on("close", function(err) {
          this.inStream.emit("error", err);
        });
        this.on("end", function(err) {
          if (err) this.inStream.emit("error", err);
          this.socket.resume();
          this.inStream.push(null);
        });
        this.inStream.close = (function() {
          this.handleNewRows = () => {
          };
          this.socket.resume();
        }).bind(this);
        this.handleNewRows = function(row) {
          if (!this.inStream.push(row)) {
            this.socket.pause();
          }
        };
        return this.inStream;
      }
    };
    module.exports = Query;
  }
});

// node_modules/mariadb/lib/cmd/encoder/binary-encoder.js
var require_binary_encoder = __commonJS({
  "node_modules/mariadb/lib/cmd/encoder/binary-encoder.js"(exports, module) {
    "use strict";
    var BinaryEncoder = class {
      /**
       * Write (and escape) current parameter value to output writer
       *
       * @param out     output writer
       * @param value   current parameter
       * @param opts    connection options
       * @param info    connection information
       */
      static writeParam(out, value, opts, info) {
        switch (typeof value) {
          case "boolean":
            out.writeInt8(value ? 1 : 0);
            break;
          case "bigint":
            if (value >= 2n ** 63n) {
              out.writeLengthEncodedString(value.toString());
            } else {
              out.writeBigInt(value);
            }
            break;
          case "number":
            if (Number.isInteger(value) && value >= -2147483648 && value < 2147483647) {
              out.writeInt32(value);
              break;
            }
            out.writeDouble(value);
            break;
          case "string":
            out.writeLengthEncodedString(value);
            break;
          case "object":
            if (Object.prototype.toString.call(value) === "[object Date]") {
              out.writeBinaryDate(value);
            } else if (Buffer.isBuffer(value)) {
              out.writeLengthEncodedBuffer(value);
            } else if (typeof value.toSqlString === "function") {
              out.writeLengthEncodedString(String(value.toSqlString()));
            } else {
              out.writeLengthEncodedString(JSON.stringify(value));
            }
            break;
          default:
            out.writeLengthEncodedBuffer(value);
        }
      }
      static getBufferFromGeometryValue(value, headerType) {
        let geoBuff;
        let pos;
        let type;
        if (!headerType) {
          switch (value.type) {
            case "Point":
              geoBuff = Buffer.allocUnsafe(21);
              geoBuff.writeInt8(1, 0);
              geoBuff.writeInt32LE(1, 1);
              if (value.coordinates && Array.isArray(value.coordinates) && value.coordinates.length >= 2 && !isNaN(value.coordinates[0]) && !isNaN(value.coordinates[1])) {
                geoBuff.writeDoubleLE(value.coordinates[0], 5);
                geoBuff.writeDoubleLE(value.coordinates[1], 13);
                return geoBuff;
              } else {
                return null;
              }
            case "LineString":
              if (value.coordinates && Array.isArray(value.coordinates)) {
                const pointNumber = value.coordinates.length;
                geoBuff = Buffer.allocUnsafe(9 + 16 * pointNumber);
                geoBuff.writeInt8(1, 0);
                geoBuff.writeInt32LE(2, 1);
                geoBuff.writeInt32LE(pointNumber, 5);
                for (let i = 0; i < pointNumber; i++) {
                  if (value.coordinates[i] && Array.isArray(value.coordinates[i]) && value.coordinates[i].length >= 2 && !isNaN(value.coordinates[i][0]) && !isNaN(value.coordinates[i][1])) {
                    geoBuff.writeDoubleLE(value.coordinates[i][0], 9 + 16 * i);
                    geoBuff.writeDoubleLE(value.coordinates[i][1], 17 + 16 * i);
                  } else {
                    return null;
                  }
                }
                return geoBuff;
              } else {
                return null;
              }
            case "Polygon":
              if (value.coordinates && Array.isArray(value.coordinates)) {
                const numRings = value.coordinates.length;
                let size = 0;
                for (let i = 0; i < numRings; i++) {
                  size += 4 + 16 * value.coordinates[i].length;
                }
                geoBuff = Buffer.allocUnsafe(9 + size);
                geoBuff.writeInt8(1, 0);
                geoBuff.writeInt32LE(3, 1);
                geoBuff.writeInt32LE(numRings, 5);
                pos = 9;
                for (let i = 0; i < numRings; i++) {
                  const lineString = value.coordinates[i];
                  if (lineString && Array.isArray(lineString)) {
                    geoBuff.writeInt32LE(lineString.length, pos);
                    pos += 4;
                    for (let j = 0; j < lineString.length; j++) {
                      if (lineString[j] && Array.isArray(lineString[j]) && lineString[j].length >= 2 && !isNaN(lineString[j][0]) && !isNaN(lineString[j][1])) {
                        geoBuff.writeDoubleLE(lineString[j][0], pos);
                        geoBuff.writeDoubleLE(lineString[j][1], pos + 8);
                        pos += 16;
                      } else {
                        return null;
                      }
                    }
                  }
                }
                return geoBuff;
              } else {
                return null;
              }
            case "MultiPoint":
              type = "MultiPoint";
              geoBuff = Buffer.allocUnsafe(9);
              geoBuff.writeInt8(1, 0);
              geoBuff.writeInt32LE(4, 1);
              break;
            case "MultiLineString":
              type = "MultiLineString";
              geoBuff = Buffer.allocUnsafe(9);
              geoBuff.writeInt8(1, 0);
              geoBuff.writeInt32LE(5, 1);
              break;
            case "MultiPolygon":
              type = "MultiPolygon";
              geoBuff = Buffer.allocUnsafe(9);
              geoBuff.writeInt8(1, 0);
              geoBuff.writeInt32LE(6, 1);
              break;
            case "GeometryCollection":
              geoBuff = Buffer.allocUnsafe(9);
              geoBuff.writeInt8(1, 0);
              geoBuff.writeInt32LE(7, 1);
              if (value.geometries && Array.isArray(value.geometries)) {
                const coordinateLength = value.geometries.length;
                const subArrays = [geoBuff];
                for (let i = 0; i < coordinateLength; i++) {
                  const tmpBuf = this.getBufferFromGeometryValue(value.geometries[i]);
                  if (tmpBuf === null) break;
                  subArrays.push(tmpBuf);
                }
                geoBuff.writeInt32LE(subArrays.length - 1, 5);
                return Buffer.concat(subArrays);
              } else {
                geoBuff.writeInt32LE(0, 5);
                return geoBuff;
              }
            default:
              return null;
          }
          if (value.coordinates && Array.isArray(value.coordinates)) {
            const coordinateLength = value.coordinates.length;
            const subArrays = [geoBuff];
            for (let i = 0; i < coordinateLength; i++) {
              const tmpBuf = this.getBufferFromGeometryValue(value.coordinates[i], type);
              if (tmpBuf === null) break;
              subArrays.push(tmpBuf);
            }
            geoBuff.writeInt32LE(subArrays.length - 1, 5);
            return Buffer.concat(subArrays);
          } else {
            geoBuff.writeInt32LE(0, 5);
            return geoBuff;
          }
        } else {
          switch (headerType) {
            case "MultiPoint":
              if (value && Array.isArray(value) && value.length >= 2 && !isNaN(value[0]) && !isNaN(value[1])) {
                geoBuff = Buffer.allocUnsafe(21);
                geoBuff.writeInt8(1, 0);
                geoBuff.writeInt32LE(1, 1);
                geoBuff.writeDoubleLE(value[0], 5);
                geoBuff.writeDoubleLE(value[1], 13);
                return geoBuff;
              }
              return null;
            case "MultiLineString":
              if (value && Array.isArray(value)) {
                const pointNumber = value.length;
                geoBuff = Buffer.allocUnsafe(9 + 16 * pointNumber);
                geoBuff.writeInt8(1, 0);
                geoBuff.writeInt32LE(2, 1);
                geoBuff.writeInt32LE(pointNumber, 5);
                for (let i = 0; i < pointNumber; i++) {
                  if (value[i] && Array.isArray(value[i]) && value[i].length >= 2 && !isNaN(value[i][0]) && !isNaN(value[i][1])) {
                    geoBuff.writeDoubleLE(value[i][0], 9 + 16 * i);
                    geoBuff.writeDoubleLE(value[i][1], 17 + 16 * i);
                  } else {
                    return null;
                  }
                }
                return geoBuff;
              }
              return null;
            case "MultiPolygon":
              if (value && Array.isArray(value)) {
                const numRings = value.length;
                let size = 0;
                for (let i = 0; i < numRings; i++) {
                  size += 4 + 16 * value[i].length;
                }
                geoBuff = Buffer.allocUnsafe(9 + size);
                geoBuff.writeInt8(1, 0);
                geoBuff.writeInt32LE(3, 1);
                geoBuff.writeInt32LE(numRings, 5);
                pos = 9;
                for (let i = 0; i < numRings; i++) {
                  const lineString = value[i];
                  if (lineString && Array.isArray(lineString)) {
                    geoBuff.writeInt32LE(lineString.length, pos);
                    pos += 4;
                    for (let j = 0; j < lineString.length; j++) {
                      if (lineString[j] && Array.isArray(lineString[j]) && lineString[j].length >= 2 && !isNaN(lineString[j][0]) && !isNaN(lineString[j][1])) {
                        geoBuff.writeDoubleLE(lineString[j][0], pos);
                        geoBuff.writeDoubleLE(lineString[j][1], pos + 8);
                        pos += 16;
                      } else {
                        return null;
                      }
                    }
                  }
                }
                return geoBuff;
              }
              return null;
          }
          return null;
        }
      }
    };
    module.exports = BinaryEncoder;
  }
});

// node_modules/mariadb/lib/cmd/class/prepare-wrapper.js
var require_prepare_wrapper = __commonJS({
  "node_modules/mariadb/lib/cmd/class/prepare-wrapper.js"(exports, module) {
    "use strict";
    var _closed, _cacheWrapper, _prepare, _conn;
    var PrepareWrapper = class {
      constructor(cacheWrapper, prepare) {
        __privateAdd(this, _closed, false);
        __privateAdd(this, _cacheWrapper);
        __privateAdd(this, _prepare);
        __privateAdd(this, _conn);
        __privateSet(this, _cacheWrapper, cacheWrapper);
        __privateSet(this, _prepare, prepare);
        __privateSet(this, _conn, prepare.conn);
        this.execute = __privateGet(this, _prepare).execute;
        this.executeStream = __privateGet(this, _prepare).executeStream;
      }
      get conn() {
        return __privateGet(this, _conn);
      }
      get id() {
        return __privateGet(this, _prepare).id;
      }
      get parameterCount() {
        return __privateGet(this, _prepare).parameterCount;
      }
      get _placeHolderIndex() {
        return __privateGet(this, _prepare)._placeHolderIndex;
      }
      get columns() {
        return __privateGet(this, _prepare).columns;
      }
      set columns(columns) {
        __privateGet(this, _prepare).columns = columns;
      }
      get database() {
        return __privateGet(this, _prepare).database;
      }
      get query() {
        return __privateGet(this, _prepare).query;
      }
      isClose() {
        return __privateGet(this, _closed);
      }
      close() {
        if (!__privateGet(this, _closed)) {
          __privateSet(this, _closed, true);
          __privateGet(this, _cacheWrapper).decrementUse();
        }
      }
      toString() {
        return "PrepareWrapper{closed:" + __privateGet(this, _closed) + ",cache:" + __privateGet(this, _cacheWrapper) + "}";
      }
    };
    _closed = new WeakMap();
    _cacheWrapper = new WeakMap();
    _prepare = new WeakMap();
    _conn = new WeakMap();
    module.exports = PrepareWrapper;
  }
});

// node_modules/mariadb/lib/cmd/class/prepare-cache-wrapper.js
var require_prepare_cache_wrapper = __commonJS({
  "node_modules/mariadb/lib/cmd/class/prepare-cache-wrapper.js"(exports, module) {
    "use strict";
    var PrepareWrapper = require_prepare_wrapper();
    var _use, _cached, _prepare;
    var PrepareCacheWrapper = class {
      constructor(prepare) {
        __privateAdd(this, _use, 0);
        __privateAdd(this, _cached);
        __privateAdd(this, _prepare);
        __privateSet(this, _prepare, prepare);
        __privateSet(this, _cached, true);
      }
      incrementUse() {
        __privateSet(this, _use, __privateGet(this, _use) + 1);
        return new PrepareWrapper(this, __privateGet(this, _prepare));
      }
      unCache() {
        __privateSet(this, _cached, false);
        if (__privateGet(this, _use) === 0) {
          __privateGet(this, _prepare).close();
        }
      }
      decrementUse() {
        __privateSet(this, _use, __privateGet(this, _use) - 1);
        if (__privateGet(this, _use) === 0 && !__privateGet(this, _cached)) {
          __privateGet(this, _prepare).close();
        }
      }
      toString() {
        return "Prepare{use:" + __privateGet(this, _use) + ",cached:" + __privateGet(this, _cached) + "}";
      }
    };
    _use = new WeakMap();
    _cached = new WeakMap();
    _prepare = new WeakMap();
    module.exports = PrepareCacheWrapper;
  }
});

// node_modules/mariadb/lib/cmd/execute.js
var require_execute = __commonJS({
  "node_modules/mariadb/lib/cmd/execute.js"(exports, module) {
    "use strict";
    var Parser = require_parser();
    var Errors = require_errors();
    var BinaryEncoder = require_binary_encoder();
    var FieldType = require_field_type();
    var Parse = require_parse();
    var Execute = class extends Parser {
      constructor(resolve, reject, connOpts, cmdParam, prepare) {
        super(resolve, reject, connOpts, cmdParam);
        this.binary = true;
        this.prepare = prepare;
        this.canSkipMeta = true;
      }
      /**
       * Send COM_QUERY
       *
       * @param out   output writer
       * @param opts  connection options
       * @param info  connection information
       */
      start(out, opts, info) {
        this.onPacketReceive = this.readResponsePacket;
        this.values = [];
        if (this.opts.namedPlaceholders) {
          if (this.prepare) {
            this.values = new Array(this.prepare.parameterCount);
            this.placeHolderIndex = this.prepare._placeHolderIndex;
          } else {
            const res = Parse.searchPlaceholder(this.sql);
            this.placeHolderIndex = res.placeHolderIndex;
            this.values = new Array(this.placeHolderIndex.length);
          }
          if (this.initialValues) {
            for (let i = 0; i < this.placeHolderIndex.length; i++) {
              this.values[i] = this.initialValues[this.placeHolderIndex[i]];
            }
          }
        } else {
          if (this.initialValues)
            this.values = Array.isArray(this.initialValues) ? this.initialValues : [this.initialValues];
        }
        this.parameterCount = this.prepare ? this.prepare.parameterCount : this.values.length;
        if (!this.validateParameters(info)) return;
        this.parametersType = new Array(this.parameterCount);
        let hasLongData = false;
        let val;
        for (let i = 0; i < this.parameterCount; i++) {
          val = this.values[i];
          if (val && val.type != null && [
            "Point",
            "LineString",
            "Polygon",
            "MultiPoint",
            "MultiLineString",
            "MultiPolygon",
            "GeometryCollection"
          ].includes(val.type)) {
            const geoBuff = BinaryEncoder.getBufferFromGeometryValue(val);
            if (geoBuff == null) {
              this.values[i] = null;
              val = null;
            } else {
              this.values[i] = Buffer.concat([
                Buffer.from([0, 0, 0, 0]),
                // SRID
                geoBuff
                // WKB
              ]);
              val = this.values[i];
            }
          }
          if (val == null) {
            this.parametersType[i] = NULL_PARAM_TYPE;
          } else {
            switch (typeof val) {
              case "boolean":
                this.parametersType[i] = BOOLEAN_TYPE;
                break;
              case "bigint":
                if (val >= 2n ** 63n) {
                  this.parametersType[i] = BIG_BIGINT_TYPE;
                } else {
                  this.parametersType[i] = BIGINT_TYPE;
                }
                break;
              case "number":
                if (Number.isInteger(val) && val >= -2147483648 && val < 2147483647) {
                  this.parametersType[i] = INT_TYPE;
                  break;
                }
                this.parametersType[i] = DOUBLE_TYPE;
                break;
              case "string":
                this.parametersType[i] = STRING_TYPE;
                break;
              case "object":
                if (Object.prototype.toString.call(val) === "[object Date]") {
                  this.parametersType[i] = DATE_TYPE;
                } else if (Buffer.isBuffer(val)) {
                  if (val.length < 16384 || !this.prepare) {
                    this.parametersType[i] = BLOB_TYPE;
                  } else {
                    this.parametersType[i] = LONGBLOB_TYPE;
                    hasLongData = true;
                  }
                } else if (typeof val.toSqlString === "function") {
                  this.parametersType[i] = STRING_FCT_TYPE;
                } else if (typeof val.pipe === "function" && typeof val.read === "function") {
                  hasLongData = true;
                  this.parametersType[i] = STREAM_TYPE;
                } else if (String === val.constructor) {
                  this.parametersType[i] = STRING_TOSTR_TYPE;
                } else {
                  this.parametersType[i] = STRINGIFY_TYPE;
                }
                break;
            }
          }
        }
        this.longDataStep = false;
        if (hasLongData) {
          for (let i = 0; i < this.parameterCount; i++) {
            if (this.parametersType[i].isLongData()) {
              if (opts.logger.query)
                opts.logger.query(
                  `EXECUTE: (${this.prepare ? this.prepare.id : -1}) sql: ${opts.logParam ? this.displaySql() : this.sql}`
                );
              if (!this.longDataStep) {
                this.longDataStep = true;
                this.registerStreamSendEvent(out, info);
                this.currentParam = i;
              }
              this.sendComStmtLongData(out, info, this.values[i]);
              return;
            }
          }
        }
        if (!this.longDataStep) {
          if (opts.logger.query)
            opts.logger.query(
              `EXECUTE: (${this.prepare ? this.prepare.id : -1}) sql: ${opts.logParam ? this.displaySql() : this.sql}`
            );
          this.sendComStmtExecute(out, info);
        }
      }
      /**
       * Validate that parameters exists and are defined.
       *
       * @param info        connection info
       * @returns {boolean} return false if any error occur.
       */
      validateParameters(info) {
        if (this.parameterCount > this.values.length) {
          this.sendCancelled(
            `Parameter at position ${this.values.length} is not set\\nsql: ${this.opts.logParam ? this.displaySql() : this.sql}`,
            Errors.ER_MISSING_PARAMETER,
            info
          );
          return false;
        }
        if (this.opts.namedPlaceholders && this.placeHolderIndex) {
          for (let i = 0; i < this.parameterCount; i++) {
            if (this.values[i] === void 0) {
              let errMsg = `Parameter named ${this.placeHolderIndex[i]} is not set`;
              if (this.placeHolderIndex.length < this.parameterCount) {
                errMsg = `Command expect ${this.parameterCount} parameters, but found only ${this.placeHolderIndex.length} named parameters. You probably use question mark in place of named parameters`;
              }
              this.sendCancelled(errMsg, Errors.ER_PARAMETER_UNDEFINED, info);
              return false;
            }
          }
        }
        return true;
      }
      sendComStmtLongData(out, info, value) {
        out.startPacket(this);
        out.writeInt8(24);
        out.writeInt32(this.prepare.id);
        out.writeInt16(this.currentParam);
        if (Buffer.isBuffer(value)) {
          out.writeBuffer(value, 0, value.length);
          out.flush();
          this.currentParam++;
          return this.paramWritten();
        }
        this.sending = true;
        value.on("data", function(chunk) {
          out.writeBuffer(chunk, 0, chunk.length);
        });
        value.on(
          "end",
          (function() {
            out.flush();
            this.currentParam++;
            this.paramWritten();
          }).bind(this)
        );
      }
      /**
       * Send a COM_STMT_EXECUTE
       * @param out
       * @param info
       */
      sendComStmtExecute(out, info) {
        let nullCount = ~~((this.parameterCount + 7) / 8);
        const nullBitsBuffer = Buffer.alloc(nullCount);
        for (let i = 0; i < this.parameterCount; i++) {
          if (this.values[i] == null) {
            nullBitsBuffer[~~(i / 8)] |= 1 << i % 8;
          }
        }
        out.startPacket(this);
        out.writeInt8(23);
        out.writeInt32(this.prepare ? this.prepare.id : -1);
        out.writeInt8(0);
        out.writeInt32(1);
        out.writeBuffer(nullBitsBuffer, 0, nullCount);
        out.writeInt8(1);
        for (let i = 0; i < this.parameterCount; i++) {
          out.writeInt8(this.parametersType[i].type);
          out.writeInt8(0);
        }
        for (let i = 0; i < this.parameterCount; i++) {
          const parameterType = this.parametersType[i];
          if (parameterType.encoder) parameterType.encoder(out, this.values[i]);
        }
        out.flush();
        this.sending = false;
        this.emit("send_end");
      }
      /**
       * Define params events.
       * Each parameter indicate that he is written to socket,
       * emitting event so next stream parameter can be written.
       */
      registerStreamSendEvent(out, info) {
        this.paramWritten = (function() {
          if (this.longDataStep) {
            for (; this.currentParam < this.parameterCount; this.currentParam++) {
              if (this.parametersType[this.currentParam].isLongData()) {
                const value = this.values[this.currentParam];
                this.sendComStmtLongData(out, info, value);
                return;
              }
            }
            this.longDataStep = false;
          }
          if (!this.longDataStep) {
            this.sendComStmtExecute(out, info);
          }
        }).bind(this);
      }
    };
    var ParameterType = class {
      constructor(type, encoder, pipe = false, isNull = false) {
        this.pipe = pipe;
        this.type = type;
        this.encoder = encoder;
        this.isNull = isNull;
      }
      isLongData() {
        return this.encoder === null && !this.isNull;
      }
    };
    var NULL_PARAM_TYPE = new ParameterType(FieldType.VAR_STRING, null, false, true);
    var BOOLEAN_TYPE = new ParameterType(FieldType.TINY, (out, value) => out.writeInt8(value ? 1 : 0));
    var BIG_BIGINT_TYPE = new ParameterType(
      FieldType.NEWDECIMAL,
      (out, value) => out.writeLengthEncodedString(value.toString())
    );
    var BIGINT_TYPE = new ParameterType(FieldType.BIGINT, (out, value) => out.writeBigInt(value));
    var INT_TYPE = new ParameterType(FieldType.INT, (out, value) => out.writeInt32(value));
    var DOUBLE_TYPE = new ParameterType(FieldType.DOUBLE, (out, value) => out.writeDouble(value));
    var STRING_TYPE = new ParameterType(FieldType.VAR_STRING, (out, value) => out.writeLengthEncodedString(value));
    var STRING_TOSTR_TYPE = new ParameterType(
      FieldType.VAR_STRING,
      (out, value) => out.writeLengthEncodedString(value.toString())
    );
    var DATE_TYPE = new ParameterType(FieldType.DATETIME, (out, value) => out.writeBinaryDate(value));
    var BLOB_TYPE = new ParameterType(FieldType.BLOB, (out, value) => out.writeLengthEncodedBuffer(value));
    var LONGBLOB_TYPE = new ParameterType(FieldType.BLOB, null);
    var STRING_FCT_TYPE = new ParameterType(
      FieldType.VAR_STRING,
      (out, value) => out.writeLengthEncodedString(String(value.toSqlString()))
    );
    var STREAM_TYPE = new ParameterType(FieldType.BLOB, null, true);
    var STRINGIFY_TYPE = new ParameterType(
      FieldType.VAR_STRING,
      (out, value) => out.writeLengthEncodedString(JSON.stringify(value))
    );
    module.exports = Execute;
  }
});

// node_modules/mariadb/lib/cmd/execute-stream.js
var require_execute_stream = __commonJS({
  "node_modules/mariadb/lib/cmd/execute-stream.js"(exports, module) {
    "use strict";
    var Execute = require_execute();
    var { Readable } = require_stream();
    var ExecuteStream = class extends Execute {
      constructor(cmdParam, connOpts, prepare, socket) {
        super(
          () => {
          },
          () => {
          },
          connOpts,
          cmdParam,
          prepare
        );
        this.socket = socket;
        this.inStream = new Readable({
          objectMode: true,
          read: () => {
            this.socket.resume();
          }
        });
        this.on("fields", function(meta) {
          this.inStream.emit("fields", meta);
        });
        this.on("error", function(err) {
          this.inStream.emit("error", err);
        });
        this.on("close", function(err) {
          this.inStream.emit("error", err);
        });
        this.on("end", function(err) {
          if (err) this.inStream.emit("error", err);
          this.socket.resume();
          this.inStream.push(null);
        });
        this.inStream.close = (function() {
          this.handleNewRows = () => {
          };
          this.socket.resume();
        }).bind(this);
      }
      handleNewRows(row) {
        if (!this.inStream.push(row)) {
          this.socket.pause();
        }
      }
    };
    module.exports = ExecuteStream;
  }
});

// node_modules/mariadb/lib/cmd/class/prepare-result-packet.js
var require_prepare_result_packet = __commonJS({
  "node_modules/mariadb/lib/cmd/class/prepare-result-packet.js"(exports, module) {
    "use strict";
    var Errors = require_errors();
    var ExecuteStream = require_execute_stream();
    var Parser = require_parser();
    var _conn;
    var PrepareResultPacket = class {
      constructor(statementId, parameterCount, columns, database, sql, placeHolderIndex, conn) {
        __privateAdd(this, _conn);
        this.id = statementId;
        this.parameterCount = parameterCount;
        this.columns = columns;
        this.database = database;
        this.query = sql;
        this.closed = false;
        this._placeHolderIndex = placeHolderIndex;
        __privateSet(this, _conn, conn);
      }
      get conn() {
        return __privateGet(this, _conn);
      }
      execute(values, opts, cb, stack) {
        let _opts = opts, _cb = cb;
        if (typeof _opts === "function") {
          _cb = _opts;
          _opts = void 0;
        }
        if (this.isClose()) {
          let sql = this.query;
          if (this.conn.opts.logParam) {
            if (this.query.length > this.conn.opts.debugLen) {
              sql = this.query.substring(0, this.conn.opts.debugLen) + "...";
            } else {
              let sqlMsg = this.query + " - parameters:";
              sql = Parser.logParameters(this.conn.opts, sqlMsg, values);
            }
          }
          const error = Errors.createError(
            `Execute fails, prepare command as already been closed`,
            Errors.ER_PREPARE_CLOSED,
            null,
            "22000",
            sql
          );
          if (!_cb) {
            return Promise.reject(error);
          } else {
            _cb(error);
            return;
          }
        }
        const cmdParam = {
          sql: this.query,
          values,
          opts: _opts,
          callback: _cb
        };
        if (stack) cmdParam.stack = stack;
        const conn = this.conn;
        const promise = new Promise((resolve, reject) => conn.executePromise.call(conn, cmdParam, this, resolve, reject));
        if (!_cb) {
          return promise;
        } else {
          promise.then((res) => {
            if (_cb) _cb(null, res, null);
          }).catch(_cb || function(err) {
          });
        }
      }
      executeStream(values, opts, cb, stack) {
        let _opts = opts, _cb = cb;
        if (typeof _opts === "function") {
          _cb = _opts;
          _opts = void 0;
        }
        if (this.isClose()) {
          const error = Errors.createError(
            `Execute fails, prepare command as already been closed`,
            Errors.ER_PREPARE_CLOSED,
            null,
            "22000",
            this.query
          );
          if (!_cb) {
            throw error;
          } else {
            _cb(error);
            return;
          }
        }
        const cmdParam = {
          sql: this.query,
          values,
          opts: _opts,
          callback: _cb
        };
        if (stack) cmdParam.stack = stack;
        const cmd = new ExecuteStream(cmdParam, this.conn.opts, this, this.conn.socket);
        if (this.conn.opts.logger.error) cmd.on("error", this.conn.opts.logger.error);
        this.conn.addCommand(cmd, true);
        return cmd.inStream;
      }
      isClose() {
        return this.closed;
      }
      close() {
        if (!this.closed) {
          this.closed = true;
          __privateGet(this, _conn).emit("close_prepare", this);
        }
      }
      toString() {
        return "Prepare{closed:" + this.closed + "}";
      }
    };
    _conn = new WeakMap();
    module.exports = PrepareResultPacket;
  }
});

// node_modules/mariadb/lib/cmd/prepare.js
var require_prepare = __commonJS({
  "node_modules/mariadb/lib/cmd/prepare.js"(exports, module) {
    "use strict";
    var Parser = require_parser();
    var Parse = require_parse();
    var BinaryEncoder = require_binary_encoder();
    var PrepareCacheWrapper = require_prepare_cache_wrapper();
    var PrepareResult = require_prepare_result_packet();
    var ServerStatus = require_server_status();
    var Errors = require_errors();
    var ColumnDefinition = require_column_definition();
    var Prepare = class extends Parser {
      constructor(resolve, reject, connOpts, cmdParam, conn) {
        super(resolve, reject, connOpts, cmdParam);
        this.encoder = new BinaryEncoder(this.opts);
        this.binary = true;
        this.conn = conn;
        this.executeCommand = cmdParam.executeCommand;
      }
      /**
       * Send COM_STMT_PREPARE
       *
       * @param out   output writer
       * @param opts  connection options
       * @param info  connection information
       */
      start(out, opts, info) {
        if (this.conn.prepareCache) {
          let cachedPrepare = this.conn.prepareCache.get(this.sql);
          if (cachedPrepare) {
            this.emit("send_end");
            return this.successEnd(cachedPrepare);
          }
        }
        if (opts.logger.query) opts.logger.query(`PREPARE: ${this.sql}`);
        this.onPacketReceive = this.readPrepareResultPacket;
        if (this.opts.namedPlaceholders) {
          const res = Parse.searchPlaceholder(this.sql);
          this.sql = res.sql;
          this.placeHolderIndex = res.placeHolderIndex;
        }
        out.startPacket(this);
        out.writeInt8(22);
        out.writeString(this.sql);
        out.flush();
        this.emit("send_end");
      }
      successPrepare(info, opts) {
        let prepare = new PrepareResult(
          this.statementId,
          this.parameterCount,
          this._columns,
          info.database,
          this.sql,
          this.placeHolderIndex,
          this.conn
        );
        if (this.conn.prepareCache) {
          let cached = new PrepareCacheWrapper(prepare);
          this.conn.prepareCache.set(this.sql, cached);
          const cachedWrappedPrepared = cached.incrementUse();
          if (this.executeCommand) this.executeCommand.prepare = cachedWrappedPrepared;
          return this.successEnd(cachedWrappedPrepared);
        }
        if (this.executeCommand) this.executeCommand.prepare = prepare;
        this.successEnd(prepare);
      }
      /**
       * Read COM_STMT_PREPARE response Packet.
       * see https://mariadb.com/kb/en/library/com_stmt_prepare/#com_stmt_prepare-response
       *
       * @param packet    COM_STMT_PREPARE_OK packet
       * @param opts      connection options
       * @param info      connection information
       * @param out       output writer
       * @returns {*}     null or {Result.readResponsePacket} in case of multi-result-set
       */
      readPrepareResultPacket(packet, out, opts, info) {
        switch (packet.peek()) {
          //*********************************************************************************************************
          //* PREPARE response
          //*********************************************************************************************************
          case 0:
            packet.skip(1);
            this.statementId = packet.readInt32();
            this.columnNo = packet.readUInt16();
            this.parameterCount = packet.readUInt16();
            this._parameterNo = this.parameterCount;
            this._columns = [];
            if (this._parameterNo > 0) return this.onPacketReceive = this.skipPrepareParameterPacket;
            if (this.columnNo > 0) return this.onPacketReceive = this.readPrepareColumnsPacket;
            return this.successPrepare(info, opts);
          //*********************************************************************************************************
          //* ERROR response
          //*********************************************************************************************************
          case 255:
            const err = packet.readError(info, this.displaySql(), this.stack);
            info.status |= ServerStatus.STATUS_IN_TRANS;
            this.onPacketReceive = this.readResponsePacket;
            return this.throwError(err, info);
          //*********************************************************************************************************
          //* Unexpected response
          //*********************************************************************************************************
          default:
            info.status |= ServerStatus.STATUS_IN_TRANS;
            this.onPacketReceive = this.readResponsePacket;
            return this.throwError(Errors.ER_UNEXPECTED_PACKET, info);
        }
      }
      readPrepareColumnsPacket(packet, out, opts, info) {
        this.columnNo--;
        this._columns.push(new ColumnDefinition(packet, info, opts.rowsAsArray));
        if (this.columnNo === 0) {
          if (info.eofDeprecated) {
            return this.successPrepare(info, opts);
          }
          this.onPacketReceive = this.skipEofPacket;
        }
      }
      skipEofPacket(packet, out, opts, info) {
        if (this.columnNo > 0) return this.onPacketReceive = this.readPrepareColumnsPacket;
        this.successPrepare(info, opts);
      }
      skipPrepareParameterPacket(packet, out, opts, info) {
        this._parameterNo--;
        if (this._parameterNo === 0) {
          if (info.eofDeprecated) {
            if (this.columnNo > 0) return this.onPacketReceive = this.readPrepareColumnsPacket;
            return this.successPrepare(info, opts);
          }
          this.onPacketReceive = this.skipEofPacket;
        }
      }
      /**
       * Display current SQL with parameters (truncated if too big)
       *
       * @returns {string}
       */
      displaySql() {
        if (this.opts) {
          if (this.sql.length > this.opts.debugLen) {
            return this.sql.substring(0, this.opts.debugLen) + "...";
          }
        }
        return this.sql;
      }
    };
    module.exports = Prepare;
  }
});

// node_modules/mariadb/lib/cmd/close-prepare.js
var require_close_prepare = __commonJS({
  "node_modules/mariadb/lib/cmd/close-prepare.js"(exports, module) {
    "use strict";
    var Command = require_command();
    var ClosePrepare = class extends Command {
      constructor(cmdParam, resolve, reject, prepare) {
        super(cmdParam, resolve, reject);
        this.prepare = prepare;
      }
      start(out, opts, info) {
        if (opts.logger.query) opts.logger.query(`CLOSE PREPARE: (${this.prepare.id}) ${this.prepare.query}`);
        const closeCmd = new Uint8Array([
          5,
          0,
          0,
          0,
          25,
          this.prepare.id,
          this.prepare.id >> 8,
          this.prepare.id >> 16,
          this.prepare.id >> 24
        ]);
        out.fastFlush(this, closeCmd);
        this.onPacketReceive = null;
        this.emit("send_end");
        this.emit("end");
      }
    };
    module.exports = ClosePrepare;
  }
});

// node_modules/mariadb/lib/cmd/batch-bulk.js
var require_batch_bulk = __commonJS({
  "node_modules/mariadb/lib/cmd/batch-bulk.js"(exports, module) {
    "use strict";
    var Parser = require_parser();
    var Errors = require_errors();
    var BinaryEncoder = require_binary_encoder();
    var FieldType = require_field_type();
    var OkPacket = require_ok_packet();
    var Capabilities = require_capabilities();
    var ServerStatus = require_server_status();
    var GEOJSON_TYPES = [
      "Point",
      "LineString",
      "Polygon",
      "MultiPoint",
      "MultiLineString",
      "MultiPolygon",
      "GeometryCollection"
    ];
    var BatchBulk = class extends Parser {
      constructor(resolve, reject, connOpts, prepare, cmdParam) {
        super(resolve, reject, connOpts, cmdParam);
        this.cmdOpts = cmdParam.opts;
        this.binary = true;
        this.prepare = prepare;
        this.canSkipMeta = true;
        this.bulkPacketNo = 0;
        this.sending = false;
        this.firstError = null;
      }
      /**
       * Initiates the batch operation
       *
       * @param {Object} out - Output writer
       * @param {Object} opts - Connection options
       * @param {Object} info - Connection information
       */
      start(out, opts, info) {
        this.info = info;
        this.values = this.initialValues;
        if (this.cmdOpts && this.cmdOpts.timeout) {
          return this.handleTimeoutError(info);
        }
        this.onPacketReceive = this.readResponsePacket;
        if (this.opts.namedPlaceholders && this.prepare._placeHolderIndex) {
          this.processNamedPlaceholders();
        }
        if (!this.validateParameters(info)) return;
        this.sendComStmtBulkExecute(out, opts, info);
      }
      /**
       * Handle timeout error case
       * @param {Object} info - Connection information
       * @private
       */
      handleTimeoutError(info) {
        this.bulkPacketNo = 1;
        this.sending = false;
        return this.sendCancelled("Cannot use timeout for Batch statement", Errors.ER_TIMEOUT_NOT_SUPPORTED);
      }
      /**
       * Process named placeholders to positional parameters
       * @private
       */
      processNamedPlaceholders() {
        this.values = [];
        if (!this.initialValues) return;
        const placeHolderIndex = this.prepare._placeHolderIndex;
        const paramCount = this.prepare.parameterCount;
        for (let r = 0; r < this.initialValues.length; r++) {
          const val = this.initialValues[r];
          const newRow = new Array(paramCount);
          for (let i = 0; i < placeHolderIndex.length; i++) {
            newRow[i] = val[placeHolderIndex[i]];
          }
          this.values[r] = newRow;
        }
      }
      /**
       * Determine parameter header types based on value types
       *
       * @param {Array} value - Parameter values
       * @param {Number} parameterCount - Number of parameters
       * @returns {Array} Array of parameter header types
       */
      parameterHeaderFromValue(value, parameterCount) {
        const parameterHeaderType = new Array(parameterCount);
        for (let i = 0; i < parameterCount; i++) {
          const val = value[i];
          if (val == null) {
            parameterHeaderType[i] = FieldType.VAR_STRING;
            continue;
          }
          const type = typeof val;
          switch (type) {
            case "boolean":
              parameterHeaderType[i] = FieldType.TINY;
              break;
            case "bigint":
              parameterHeaderType[i] = val >= 2n ** 63n ? FieldType.NEWDECIMAL : FieldType.BIGINT;
              break;
            case "number":
              if (Number.isInteger(val) && val >= -2147483648 && val < 2147483647) {
                parameterHeaderType[i] = FieldType.INT;
              } else {
                parameterHeaderType[i] = FieldType.DOUBLE;
              }
              break;
            case "string":
              parameterHeaderType[i] = FieldType.VAR_STRING;
              break;
            case "object":
              parameterHeaderType[i] = this.getObjectFieldType(val);
              break;
            default:
              parameterHeaderType[i] = FieldType.BLOB;
          }
        }
        return parameterHeaderType;
      }
      /**
       * Determine field type for object values
       *
       * @param {Object} val - Object value
       * @returns {Number} Field type constant
       * @private
       */
      getObjectFieldType(val) {
        if (Object.prototype.toString.call(val) === "[object Date]") {
          return FieldType.DATETIME;
        }
        if (Buffer.isBuffer(val)) {
          return FieldType.BLOB;
        }
        if (typeof val.toSqlString === "function") {
          return FieldType.VAR_STRING;
        }
        if (val.type != null && GEOJSON_TYPES.includes(val.type)) {
          return FieldType.BLOB;
        }
        return FieldType.VAR_STRING;
      }
      /**
       * Check if current value has same header as set in initial BULK header
       *
       * @param {Array} parameterHeaderType - Current header types
       * @param {Array} value - Current values
       * @param {Number} parameterCount - Number of parameters
       * @returns {Boolean} True if headers are identical
       */
      checkSameHeader(parameterHeaderType, value, parameterCount) {
        for (let i = 0; i < parameterCount; i++) {
          const val = value[i];
          if (val == null) continue;
          const type = typeof val;
          switch (type) {
            case "boolean":
              if (parameterHeaderType[i] !== FieldType.TINY) return false;
              break;
            case "bigint":
              if (val >= 2n ** 63n) {
                if (parameterHeaderType[i] !== FieldType.VAR_STRING) return false;
              } else {
                if (parameterHeaderType[i] !== FieldType.BIGINT) return false;
              }
              break;
            case "number":
              if (Number.isInteger(val) && val >= -2147483648 && val < 2147483647) {
                if (parameterHeaderType[i] !== FieldType.INT) return false;
              } else {
                if (parameterHeaderType[i] !== FieldType.DOUBLE) return false;
              }
              break;
            case "string":
              if (parameterHeaderType[i] !== FieldType.VAR_STRING) return false;
              break;
            case "object":
              if (!this.checkObjectHeaderType(val, parameterHeaderType[i])) {
                return false;
              }
              break;
            default:
              if (parameterHeaderType[i] !== FieldType.BLOB) return false;
          }
        }
        return true;
      }
      /**
       * Check if object value matches expected header type
       *
       * @param {Object} val - Object value
       * @param {Number} headerType - Expected header type
       * @returns {Boolean} True if types match
       * @private
       */
      checkObjectHeaderType(val, headerType) {
        if (Object.prototype.toString.call(val) === "[object Date]") {
          return headerType === FieldType.TIMESTAMP;
        }
        if (Buffer.isBuffer(val)) {
          return headerType === FieldType.BLOB;
        }
        if (typeof val.toSqlString === "function") {
          return headerType === FieldType.VAR_STRING;
        }
        if (val.type != null && GEOJSON_TYPES.includes(val.type)) {
          return headerType === FieldType.BLOB;
        }
        return headerType === FieldType.VAR_STRING;
      }
      /**
       * Send a COM_STMT_BULK_EXECUTE command
       *
       * @param {Object} out - Output packet writer
       * @param {Object} opts - Connection options
       * @param {Object} info - Connection information
       */
      sendComStmtBulkExecute(out, opts, info) {
        if (opts.logger.query) {
          opts.logger.query(`BULK: (${this.prepare.id}) sql: ${opts.logParam ? this.displaySql() : this.sql}`);
        }
        const parameterCount = this.prepare.parameterCount;
        this.rowIdx = 0;
        this.vals = this.values[this.rowIdx++];
        let parameterHeaderType = this.parameterHeaderFromValue(this.vals, parameterCount);
        let lastCmdData = null;
        this.bulkPacketNo = 0;
        this.sending = true;
        main_loop: while (true) {
          this.bulkPacketNo++;
          out.startPacket(this);
          out.writeInt8(250);
          out.writeInt32(this.prepare.id);
          this.useUnitResult = (info.clientCapabilities & Capabilities.BULK_UNIT_RESULTS) > 0;
          out.writeInt16(this.useUnitResult ? 192 : 128);
          for (let i = 0; i < parameterCount; i++) {
            out.writeInt16(parameterHeaderType[i]);
          }
          if (lastCmdData != null) {
            const err = out.checkMaxAllowedLength(lastCmdData.length, info);
            if (err) {
              this.sending = false;
              this.throwError(err, info);
              return;
            }
            out.writeBuffer(lastCmdData, 0, lastCmdData.length);
            out.mark();
            lastCmdData = null;
            if (this.rowIdx >= this.values.length) {
              break;
            }
            this.vals = this.values[this.rowIdx++];
          }
          parameter_loop: while (true) {
            for (let i = 0; i < parameterCount; i++) {
              const param = this.vals[i];
              if (param != null) {
                if (param.type != null && GEOJSON_TYPES.includes(param.type)) {
                  this.writeGeoJSONParam(out, param, info);
                } else {
                  out.writeInt8(0);
                  BinaryEncoder.writeParam(out, param, this.opts, info);
                }
              } else {
                out.writeInt8(1);
              }
            }
            if (out.isMarked() && (out.hasDataAfterMark() || out.bufIsAfterMaxPacketLength())) {
              out.flushBufferStopAtMark();
              out.mark();
              lastCmdData = out.resetMark();
              break;
            }
            out.mark();
            if (out.hasDataAfterMark()) {
              lastCmdData = out.resetMark();
              break;
            }
            if (this.rowIdx >= this.values.length) {
              break main_loop;
            }
            this.vals = this.values[this.rowIdx++];
            if (!this.checkSameHeader(parameterHeaderType, this.vals, parameterCount)) {
              out.flush();
              parameterHeaderType = this.parameterHeaderFromValue(this.vals, parameterCount);
              break parameter_loop;
            }
          }
        }
        out.flush();
        this.sending = false;
        this.emit("send_end");
      }
      /**
       * Write GeoJSON parameter to output buffer
       *
       * @param {Object} out - Output buffer
       * @param {Object} param - GeoJSON parameter
       * @param {Object} info - connection info data
       * @private
       */
      writeGeoJSONParam(out, param, info) {
        const geoBuff = BinaryEncoder.getBufferFromGeometryValue(param);
        if (geoBuff == null) {
          out.writeInt8(1);
        } else {
          out.writeInt8(0);
          const paramBuff = Buffer.concat([
            Buffer.from([0, 0, 0, 0]),
            // SRID
            geoBuff
            // WKB
          ]);
          BinaryEncoder.writeParam(out, paramBuff, this.opts, info);
        }
      }
      /**
       * Format SQL with parameters for logging
       *
       * @returns {String} Formatted SQL string
       */
      displaySql() {
        if (this.sql.length > this.opts.debugLen) {
          return this.sql.substring(0, this.opts.debugLen) + "...";
        }
        let sqlMsg = this.sql + " - parameters:[";
        for (let i = 0; i < this.initialValues.length; i++) {
          if (i !== 0) sqlMsg += ",";
          let param = this.initialValues[i];
          sqlMsg = Parser.logParameters(this.opts, sqlMsg, param);
          if (sqlMsg.length > this.opts.debugLen) {
            return sqlMsg.substring(0, this.opts.debugLen) + "...";
          }
        }
        sqlMsg += "]";
        return sqlMsg;
      }
      /**
       * Process successful query execution
       *
       * @param {Object} initVal - Query result
       */
      success(initVal) {
        this.bulkPacketNo--;
        if (!this.sending && this.bulkPacketNo === 0) {
          this.packet = null;
          if (this.firstError) {
            this.resolve = null;
            this.onPacketReceive = null;
            this._columns = null;
            this._rows = null;
            process.nextTick(this.reject, this.firstError);
            this.reject = null;
            this.emit("end", this.firstError);
          } else {
            this.processResults();
          }
          return;
        }
        if (!this.firstError) {
          this._responseIndex++;
          this.onPacketReceive = this.readResponsePacket;
        }
      }
      /**
       * Process successful results based on result type
       * @private
       */
      processResults() {
        if (this._rows[0] && this._rows[0][0] && this._rows[0][0]["Affected_rows"] !== void 0) {
          this.processUnitResults();
        } else if (this._rows[0].affectedRows !== void 0 && !(this.opts.fullResult === void 0 || this.opts.fullResult === true)) {
          this.processAggregatedResults();
        } else {
          this.processRowResults();
        }
        this._columns = null;
        this._rows = null;
      }
      /**
       * Process unit results (for bulk operations with unit results)
       * @private
       */
      processUnitResults() {
        if (this.opts.fullResult === void 0 || this.opts.fullResult === true) {
          const rs = [];
          this._rows.forEach((row) => {
            row.forEach((unitRow) => {
              rs.push(new OkPacket(Number(unitRow["Affected_rows"]), BigInt(unitRow["Id"]), 0));
            });
          });
          this.successEnd(this.opts.metaAsArray ? [rs, []] : rs);
        } else {
          let totalAffectedRows = 0;
          this._rows.forEach((row) => {
            row.forEach((unitRow) => {
              totalAffectedRows += Number(unitRow["Affected_rows"]);
            });
          });
          const rs = new OkPacket(totalAffectedRows, BigInt(this._rows[0][0]["Id"]), 0);
          this.successEnd(this.opts.metaAsArray ? [rs, []] : rs);
        }
      }
      /**
       * Process aggregated results (for non-fullResult mode)
       * @private
       */
      processAggregatedResults() {
        let totalAffectedRows = 0;
        this._rows.forEach((row) => {
          totalAffectedRows += row.affectedRows;
        });
        const rs = new OkPacket(totalAffectedRows, this._rows[0].insertId, this._rows[this._rows.length - 1].warningStatus);
        this.successEnd(this.opts.metaAsArray ? [rs, []] : rs);
      }
      /**
       * Process row results (for SELECT queries)
       * @private
       */
      processRowResults() {
        if (this._rows.length === 1) {
          this.successEnd(this.opts.metaAsArray ? [this._rows[0], this._columns] : this._rows[0]);
          return;
        }
        if (this.opts.metaAsArray) {
          if (this.useUnitResult) {
            const rs = [];
            this._rows.forEach((row, i) => {
              if (i % 2 === 0) rs.push(...row);
            });
            this.successEnd([rs, this.prepare.columns]);
          } else {
            const rs = [];
            this._rows.forEach((row) => {
              rs.push(...row);
            });
            this.successEnd([rs, this._columns]);
          }
        } else {
          if (this.useUnitResult) {
            const rs = [];
            this._rows.forEach((row, i) => {
              if (i % 2 === 0) rs.push(...row);
            });
            Object.defineProperty(rs, "meta", {
              value: this._columns,
              writable: true,
              enumerable: this.opts.metaEnumerable
            });
            this.successEnd(rs);
          } else {
            if (this._rows.length === 1) {
              this.successEnd(this._rows[0]);
            } else {
              const rs = [];
              if (Array.isArray(this._rows[0])) {
                this._rows.forEach((row) => {
                  rs.push(...row);
                });
              } else rs.push(...this._rows);
              Object.defineProperty(rs, "meta", {
                value: this._columns,
                writable: true,
                enumerable: this.opts.metaEnumerable
              });
              this.successEnd(rs);
            }
          }
        }
      }
      /**
       * Handle OK packet success
       *
       * @param {Object} okPacket - OK packet
       * @param {Object} info - Connection information
       */
      okPacketSuccess(okPacket, info) {
        this._rows.push(okPacket);
        if (info.status & ServerStatus.MORE_RESULTS_EXISTS) {
          this._responseIndex++;
          return this.onPacketReceive = this.readResponsePacket;
        }
        if (this.opts.metaAsArray) {
          if (!this._meta) {
            this._meta = new Array(this._responseIndex);
          }
          this._meta[this._responseIndex] = null;
          this.success([this._rows, this._meta]);
        } else {
          this.success(this._rows);
        }
      }
      /**
       * Handle errors during query execution
       *
       * @param {Error} err - Error object
       * @param {Object} info - Connection information
       */
      throwError(err, info) {
        this.bulkPacketNo--;
        if (!this.firstError) {
          if (err.fatal) {
            this.bulkPacketNo = 0;
          }
          if (this.cmdParam.stack) {
            err = Errors.createError(
              err.message,
              err.errno,
              info,
              err.sqlState,
              this.sql,
              err.fatal,
              this.cmdParam.stack,
              false
            );
          }
          this.firstError = err;
        }
        if (!this.sending && this.bulkPacketNo === 0) {
          this.resolve = null;
          this.emit("send_end");
          process.nextTick(this.reject, this.firstError);
          this.reject = null;
          this.onPacketReceive = null;
          this.emit("end", this.firstError);
        } else {
          this.onPacketReceive = this.readResponsePacket;
        }
      }
      /**
       * Validate that parameters exist and are defined
       *
       * @param {Object} info - Connection information
       * @returns {Boolean} Returns false if any error occurs
       */
      validateParameters(info) {
        const nbParameter = this.prepare.parameterCount;
        for (let r = 0; r < this.values.length; r++) {
          if (!Array.isArray(this.values[r])) {
            this.values[r] = [this.values[r]];
          }
          if (this.values[r].length < nbParameter) {
            this.emit("send_end");
            this.throwNewError(
              `Expect ${nbParameter} parameters, but at index ${r}, parameters only contains ${this.values[r].length}
 ${this.opts.logParam ? this.displaySql() : this.sql}`,
              false,
              info,
              "HY000",
              Errors.ER_PARAMETER_UNDEFINED
            );
            return false;
          }
        }
        return true;
      }
    };
    module.exports = BatchBulk;
  }
});

// node_modules/mariadb/lib/cmd/change-user.js
var require_change_user = __commonJS({
  "node_modules/mariadb/lib/cmd/change-user.js"(exports, module) {
    "use strict";
    var Iconv = require_lib();
    var Capabilities = require_capabilities();
    var Ed25519PasswordAuth = require_ed25519_password_auth();
    var NativePasswordAuth = require_native_password_auth();
    var Collations = require_collations();
    var Authentication = require_authentication();
    var ChangeUser = class extends Authentication {
      constructor(cmdParam, connOpts, resolve, reject, getSocket) {
        super(cmdParam, resolve, reject, () => {
        }, getSocket);
        this.configAssign(connOpts, cmdParam.opts);
      }
      start(out, opts, info) {
        if (opts.logger.query) opts.logger.query(`CHANGE USER to '${this.opts.user || ""}'`);
        let authToken;
        const pwd = Array.isArray(this.opts.password) ? this.opts.password[0] : this.opts.password;
        switch (info.defaultPluginName) {
          case "mysql_native_password":
          case "":
            authToken = NativePasswordAuth.encryptSha1Password(pwd, info.seed);
            break;
          case "client_ed25519":
            authToken = Ed25519PasswordAuth.encryptPassword(pwd, info.seed);
            break;
          default:
            authToken = Buffer.alloc(0);
            break;
        }
        out.startPacket(this);
        out.writeInt8(17);
        out.writeString(this.opts.user || "");
        out.writeInt8(0);
        if (info.serverCapabilities & Capabilities.SECURE_CONNECTION) {
          out.writeInt8(authToken.length);
          out.writeBuffer(authToken, 0, authToken.length);
        } else {
          out.writeBuffer(authToken, 0, authToken.length);
          out.writeInt8(0);
        }
        if (info.clientCapabilities & Capabilities.CONNECT_WITH_DB) {
          out.writeString(this.opts.database);
          out.writeInt8(0);
          info.database = this.opts.database;
        }
        if (this.opts.collation) {
          if (!this.opts.charset || info.collation.charset !== this.opts.collation.charset) {
            info.collation = this.opts.collation;
          }
        } else {
          if (info.collation.charset !== "utf8" || info.collation.maxLength === 3) {
            info.collation = Collations.fromIndex(224);
          }
        }
        out.writeInt16(info.collation.index);
        if (info.clientCapabilities & Capabilities.PLUGIN_AUTH) {
          out.writeString(info.defaultPluginName);
          out.writeInt8(0);
        }
        if (info.clientCapabilities & Capabilities.CONNECT_ATTRS) {
          out.writeInt8(252);
          let initPos = out.pos;
          out.writeInt16(0);
          const encoding = info.collation.charset;
          writeAttribute(out, "_client_name", encoding);
          writeAttribute(out, "MariaDB connector/Node", encoding);
          let packageJson = require_package();
          writeAttribute(out, "_client_version", encoding);
          writeAttribute(out, packageJson.version, encoding);
          writeAttribute(out, "_node_version", encoding);
          writeAttribute(out, process.versions.node, encoding);
          if (opts.connectAttributes !== true) {
            let attrNames = Object.keys(this.opts.connectAttributes);
            for (let k = 0; k < attrNames.length; ++k) {
              writeAttribute(out, attrNames[k], encoding);
              writeAttribute(out, this.opts.connectAttributes[attrNames[k]], encoding);
            }
          }
          out.writeInt16AtPos(initPos);
        }
        out.flush();
        this.plugin.onPacketReceive = this.handshakeResult.bind(this);
      }
      /**
       * Assign global configuration option used by result-set to current query option.
       * a little faster than Object.assign() since doest copy all information
       *
       * @param connOpts  connection global configuration
       * @param cmdOpts   current options
       */
      configAssign(connOpts, cmdOpts) {
        if (!cmdOpts) {
          this.opts = connOpts;
          return;
        }
        this.opts = cmdOpts ? Object.assign({}, connOpts, cmdOpts) : connOpts;
        if (cmdOpts.charset && typeof cmdOpts.charset === "string") {
          this.opts.collation = Collations.fromCharset(cmdOpts.charset.toLowerCase());
          if (this.opts.collation === void 0) {
            this.opts.collation = Collations.fromName(cmdOpts.charset.toUpperCase());
            if (this.opts.collation !== void 0) {
              this.opts.logger.warning(
                "warning: please use option 'collation' in replacement of 'charset' when using a collation name ('" + cmdOpts.charset + "')\n(collation looks like 'UTF8MB4_UNICODE_CI', charset like 'utf8')."
              );
            }
          }
          if (this.opts.collation === void 0) throw new RangeError("Unknown charset '" + cmdOpts.charset + "'");
        } else if (cmdOpts.collation && typeof cmdOpts.collation === "string") {
          const initial = cmdOpts.collation;
          this.opts.collation = Collations.fromName(initial.toUpperCase());
          if (this.opts.collation === void 0) throw new RangeError("Unknown collation '" + initial + "'");
        } else {
          this.opts.collation = Collations.fromIndex(cmdOpts.charsetNumber) || connOpts.collation;
        }
        connOpts.password = cmdOpts.password;
      }
    };
    function writeAttribute(out, val, encoding) {
      let param = Buffer.isEncoding(encoding) ? Buffer.from(val, encoding) : Iconv.encode(val, encoding);
      out.writeLengthCoded(param.length);
      out.writeBuffer(param, 0, param.length);
    }
    module.exports = ChangeUser;
  }
});

// node_modules/mariadb/lib/const/connection_status.js
var require_connection_status = __commonJS({
  "node_modules/mariadb/lib/const/connection_status.js"(exports, module) {
    "use strict";
    var Status = {
      NOT_CONNECTED: 1,
      CONNECTING: 2,
      AUTHENTICATING: 3,
      INIT_CMD: 4,
      CONNECTED: 5,
      CLOSING: 6,
      CLOSED: 7
    };
    module.exports.Status = Status;
  }
});

// node_modules/mariadb/node_modules/lru-cache/dist/commonjs/index.js
var require_commonjs = __commonJS({
  "node_modules/mariadb/node_modules/lru-cache/dist/commonjs/index.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LRUCache = void 0;
    var perf = typeof performance === "object" && performance && typeof performance.now === "function" ? performance : Date;
    var warned = /* @__PURE__ */ new Set();
    var PROCESS = typeof process === "object" && !!process ? process : {};
    var emitWarning = (msg, type, code, fn) => {
      typeof PROCESS.emitWarning === "function" ? PROCESS.emitWarning(msg, type, code, fn) : console.error(`[${code}] ${type}: ${msg}`);
    };
    var AC = globalThis.AbortController;
    var AS = globalThis.AbortSignal;
    var _a;
    if (typeof AC === "undefined") {
      AS = class AbortSignal {
        constructor() {
          __publicField(this, "onabort");
          __publicField(this, "_onabort", []);
          __publicField(this, "reason");
          __publicField(this, "aborted", false);
        }
        addEventListener(_, fn) {
          this._onabort.push(fn);
        }
      };
      AC = class AbortController {
        constructor() {
          __publicField(this, "signal", new AS());
          warnACPolyfill();
        }
        abort(reason) {
          var _a3, _b2;
          if (this.signal.aborted)
            return;
          this.signal.reason = reason;
          this.signal.aborted = true;
          for (const fn of this.signal._onabort) {
            fn(reason);
          }
          (_b2 = (_a3 = this.signal).onabort) == null ? void 0 : _b2.call(_a3, reason);
        }
      };
      let printACPolyfillWarning = ((_a = PROCESS.env) == null ? void 0 : _a.LRU_CACHE_IGNORE_AC_WARNING) !== "1";
      const warnACPolyfill = () => {
        if (!printACPolyfillWarning)
          return;
        printACPolyfillWarning = false;
        emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.", "NO_ABORT_CONTROLLER", "ENOTSUP", warnACPolyfill);
      };
    }
    var shouldWarn = (code) => !warned.has(code);
    var TYPE = Symbol("type");
    var isPosInt = (n) => n && n === Math.floor(n) && n > 0 && isFinite(n);
    var getUintArray = (max) => !isPosInt(max) ? null : max <= Math.pow(2, 8) ? Uint8Array : max <= Math.pow(2, 16) ? Uint16Array : max <= Math.pow(2, 32) ? Uint32Array : max <= Number.MAX_SAFE_INTEGER ? ZeroArray : null;
    var ZeroArray = class extends Array {
      constructor(size) {
        super(size);
        this.fill(0);
      }
    };
    var _constructing;
    var _Stack = class _Stack {
      constructor(max, HeapCls) {
        __publicField(this, "heap");
        __publicField(this, "length");
        if (!__privateGet(_Stack, _constructing)) {
          throw new TypeError("instantiate Stack using Stack.create(n)");
        }
        this.heap = new HeapCls(max);
        this.length = 0;
      }
      static create(max) {
        const HeapCls = getUintArray(max);
        if (!HeapCls)
          return [];
        __privateSet(_Stack, _constructing, true);
        const s = new _Stack(max, HeapCls);
        __privateSet(_Stack, _constructing, false);
        return s;
      }
      push(n) {
        this.heap[this.length++] = n;
      }
      pop() {
        return this.heap[--this.length];
      }
    };
    _constructing = new WeakMap();
    // private constructor
    __privateAdd(_Stack, _constructing, false);
    var Stack = _Stack;
    var _a2, _b, _max, _maxSize, _dispose, _disposeAfter, _fetchMethod, _memoMethod, _size, _calculatedSize, _keyMap, _keyList, _valList, _next, _prev, _head, _tail, _free, _disposed, _sizes, _starts, _ttls, _hasDispose, _hasFetchMethod, _hasDisposeAfter, _LRUCache_instances, initializeTTLTracking_fn, _updateItemAge, _statusTTL, _setItemTTL, _isStale, initializeSizeTracking_fn, _removeItemSize, _addItemSize, _requireSize, indexes_fn, rindexes_fn, isValidIndex_fn, evict_fn, backgroundFetch_fn, isBackgroundFetch_fn, connect_fn, moveToTail_fn, delete_fn, clear_fn;
    var _LRUCache = class _LRUCache {
      constructor(options) {
        __privateAdd(this, _LRUCache_instances);
        // options that cannot be changed without disaster
        __privateAdd(this, _max);
        __privateAdd(this, _maxSize);
        __privateAdd(this, _dispose);
        __privateAdd(this, _disposeAfter);
        __privateAdd(this, _fetchMethod);
        __privateAdd(this, _memoMethod);
        /**
         * {@link LRUCache.OptionsBase.ttl}
         */
        __publicField(this, "ttl");
        /**
         * {@link LRUCache.OptionsBase.ttlResolution}
         */
        __publicField(this, "ttlResolution");
        /**
         * {@link LRUCache.OptionsBase.ttlAutopurge}
         */
        __publicField(this, "ttlAutopurge");
        /**
         * {@link LRUCache.OptionsBase.updateAgeOnGet}
         */
        __publicField(this, "updateAgeOnGet");
        /**
         * {@link LRUCache.OptionsBase.updateAgeOnHas}
         */
        __publicField(this, "updateAgeOnHas");
        /**
         * {@link LRUCache.OptionsBase.allowStale}
         */
        __publicField(this, "allowStale");
        /**
         * {@link LRUCache.OptionsBase.noDisposeOnSet}
         */
        __publicField(this, "noDisposeOnSet");
        /**
         * {@link LRUCache.OptionsBase.noUpdateTTL}
         */
        __publicField(this, "noUpdateTTL");
        /**
         * {@link LRUCache.OptionsBase.maxEntrySize}
         */
        __publicField(this, "maxEntrySize");
        /**
         * {@link LRUCache.OptionsBase.sizeCalculation}
         */
        __publicField(this, "sizeCalculation");
        /**
         * {@link LRUCache.OptionsBase.noDeleteOnFetchRejection}
         */
        __publicField(this, "noDeleteOnFetchRejection");
        /**
         * {@link LRUCache.OptionsBase.noDeleteOnStaleGet}
         */
        __publicField(this, "noDeleteOnStaleGet");
        /**
         * {@link LRUCache.OptionsBase.allowStaleOnFetchAbort}
         */
        __publicField(this, "allowStaleOnFetchAbort");
        /**
         * {@link LRUCache.OptionsBase.allowStaleOnFetchRejection}
         */
        __publicField(this, "allowStaleOnFetchRejection");
        /**
         * {@link LRUCache.OptionsBase.ignoreFetchAbort}
         */
        __publicField(this, "ignoreFetchAbort");
        // computed properties
        __privateAdd(this, _size);
        __privateAdd(this, _calculatedSize);
        __privateAdd(this, _keyMap);
        __privateAdd(this, _keyList);
        __privateAdd(this, _valList);
        __privateAdd(this, _next);
        __privateAdd(this, _prev);
        __privateAdd(this, _head);
        __privateAdd(this, _tail);
        __privateAdd(this, _free);
        __privateAdd(this, _disposed);
        __privateAdd(this, _sizes);
        __privateAdd(this, _starts);
        __privateAdd(this, _ttls);
        __privateAdd(this, _hasDispose);
        __privateAdd(this, _hasFetchMethod);
        __privateAdd(this, _hasDisposeAfter);
        // conditionally set private methods related to TTL
        __privateAdd(this, _updateItemAge, () => {
        });
        __privateAdd(this, _statusTTL, () => {
        });
        __privateAdd(this, _setItemTTL, () => {
        });
        /* c8 ignore stop */
        __privateAdd(this, _isStale, () => false);
        __privateAdd(this, _removeItemSize, (_i) => {
        });
        __privateAdd(this, _addItemSize, (_i, _s, _st) => {
        });
        __privateAdd(this, _requireSize, (_k, _v, size, sizeCalculation) => {
          if (size || sizeCalculation) {
            throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");
          }
          return 0;
        });
        /**
         * A String value that is used in the creation of the default string
         * description of an object. Called by the built-in method
         * `Object.prototype.toString`.
         */
        __publicField(this, _a2, "LRUCache");
        const { max = 0, ttl, ttlResolution = 1, ttlAutopurge, updateAgeOnGet, updateAgeOnHas, allowStale, dispose, disposeAfter, noDisposeOnSet, noUpdateTTL, maxSize = 0, maxEntrySize = 0, sizeCalculation, fetchMethod, memoMethod, noDeleteOnFetchRejection, noDeleteOnStaleGet, allowStaleOnFetchRejection, allowStaleOnFetchAbort, ignoreFetchAbort } = options;
        if (max !== 0 && !isPosInt(max)) {
          throw new TypeError("max option must be a nonnegative integer");
        }
        const UintArray = max ? getUintArray(max) : Array;
        if (!UintArray) {
          throw new Error("invalid max value: " + max);
        }
        __privateSet(this, _max, max);
        __privateSet(this, _maxSize, maxSize);
        this.maxEntrySize = maxEntrySize || __privateGet(this, _maxSize);
        this.sizeCalculation = sizeCalculation;
        if (this.sizeCalculation) {
          if (!__privateGet(this, _maxSize) && !this.maxEntrySize) {
            throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");
          }
          if (typeof this.sizeCalculation !== "function") {
            throw new TypeError("sizeCalculation set to non-function");
          }
        }
        if (memoMethod !== void 0 && typeof memoMethod !== "function") {
          throw new TypeError("memoMethod must be a function if defined");
        }
        __privateSet(this, _memoMethod, memoMethod);
        if (fetchMethod !== void 0 && typeof fetchMethod !== "function") {
          throw new TypeError("fetchMethod must be a function if specified");
        }
        __privateSet(this, _fetchMethod, fetchMethod);
        __privateSet(this, _hasFetchMethod, !!fetchMethod);
        __privateSet(this, _keyMap, /* @__PURE__ */ new Map());
        __privateSet(this, _keyList, new Array(max).fill(void 0));
        __privateSet(this, _valList, new Array(max).fill(void 0));
        __privateSet(this, _next, new UintArray(max));
        __privateSet(this, _prev, new UintArray(max));
        __privateSet(this, _head, 0);
        __privateSet(this, _tail, 0);
        __privateSet(this, _free, Stack.create(max));
        __privateSet(this, _size, 0);
        __privateSet(this, _calculatedSize, 0);
        if (typeof dispose === "function") {
          __privateSet(this, _dispose, dispose);
        }
        if (typeof disposeAfter === "function") {
          __privateSet(this, _disposeAfter, disposeAfter);
          __privateSet(this, _disposed, []);
        } else {
          __privateSet(this, _disposeAfter, void 0);
          __privateSet(this, _disposed, void 0);
        }
        __privateSet(this, _hasDispose, !!__privateGet(this, _dispose));
        __privateSet(this, _hasDisposeAfter, !!__privateGet(this, _disposeAfter));
        this.noDisposeOnSet = !!noDisposeOnSet;
        this.noUpdateTTL = !!noUpdateTTL;
        this.noDeleteOnFetchRejection = !!noDeleteOnFetchRejection;
        this.allowStaleOnFetchRejection = !!allowStaleOnFetchRejection;
        this.allowStaleOnFetchAbort = !!allowStaleOnFetchAbort;
        this.ignoreFetchAbort = !!ignoreFetchAbort;
        if (this.maxEntrySize !== 0) {
          if (__privateGet(this, _maxSize) !== 0) {
            if (!isPosInt(__privateGet(this, _maxSize))) {
              throw new TypeError("maxSize must be a positive integer if specified");
            }
          }
          if (!isPosInt(this.maxEntrySize)) {
            throw new TypeError("maxEntrySize must be a positive integer if specified");
          }
          __privateMethod(this, _LRUCache_instances, initializeSizeTracking_fn).call(this);
        }
        this.allowStale = !!allowStale;
        this.noDeleteOnStaleGet = !!noDeleteOnStaleGet;
        this.updateAgeOnGet = !!updateAgeOnGet;
        this.updateAgeOnHas = !!updateAgeOnHas;
        this.ttlResolution = isPosInt(ttlResolution) || ttlResolution === 0 ? ttlResolution : 1;
        this.ttlAutopurge = !!ttlAutopurge;
        this.ttl = ttl || 0;
        if (this.ttl) {
          if (!isPosInt(this.ttl)) {
            throw new TypeError("ttl must be a positive integer if specified");
          }
          __privateMethod(this, _LRUCache_instances, initializeTTLTracking_fn).call(this);
        }
        if (__privateGet(this, _max) === 0 && this.ttl === 0 && __privateGet(this, _maxSize) === 0) {
          throw new TypeError("At least one of max, maxSize, or ttl is required");
        }
        if (!this.ttlAutopurge && !__privateGet(this, _max) && !__privateGet(this, _maxSize)) {
          const code = "LRU_CACHE_UNBOUNDED";
          if (shouldWarn(code)) {
            warned.add(code);
            const msg = "TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.";
            emitWarning(msg, "UnboundedCacheWarning", code, _LRUCache);
          }
        }
      }
      /**
       * Do not call this method unless you need to inspect the
       * inner workings of the cache.  If anything returned by this
       * object is modified in any way, strange breakage may occur.
       *
       * These fields are private for a reason!
       *
       * @internal
       */
      static unsafeExposeInternals(c) {
        return {
          // properties
          starts: __privateGet(c, _starts),
          ttls: __privateGet(c, _ttls),
          sizes: __privateGet(c, _sizes),
          keyMap: __privateGet(c, _keyMap),
          keyList: __privateGet(c, _keyList),
          valList: __privateGet(c, _valList),
          next: __privateGet(c, _next),
          prev: __privateGet(c, _prev),
          get head() {
            return __privateGet(c, _head);
          },
          get tail() {
            return __privateGet(c, _tail);
          },
          free: __privateGet(c, _free),
          // methods
          isBackgroundFetch: (p) => {
            var _a3;
            return __privateMethod(_a3 = c, _LRUCache_instances, isBackgroundFetch_fn).call(_a3, p);
          },
          backgroundFetch: (k, index, options, context) => {
            var _a3;
            return __privateMethod(_a3 = c, _LRUCache_instances, backgroundFetch_fn).call(_a3, k, index, options, context);
          },
          moveToTail: (index) => {
            var _a3;
            return __privateMethod(_a3 = c, _LRUCache_instances, moveToTail_fn).call(_a3, index);
          },
          indexes: (options) => {
            var _a3;
            return __privateMethod(_a3 = c, _LRUCache_instances, indexes_fn).call(_a3, options);
          },
          rindexes: (options) => {
            var _a3;
            return __privateMethod(_a3 = c, _LRUCache_instances, rindexes_fn).call(_a3, options);
          },
          isStale: (index) => {
            var _a3;
            return __privateGet(_a3 = c, _isStale).call(_a3, index);
          }
        };
      }
      // Protected read-only members
      /**
       * {@link LRUCache.OptionsBase.max} (read-only)
       */
      get max() {
        return __privateGet(this, _max);
      }
      /**
       * {@link LRUCache.OptionsBase.maxSize} (read-only)
       */
      get maxSize() {
        return __privateGet(this, _maxSize);
      }
      /**
       * The total computed size of items in the cache (read-only)
       */
      get calculatedSize() {
        return __privateGet(this, _calculatedSize);
      }
      /**
       * The number of items stored in the cache (read-only)
       */
      get size() {
        return __privateGet(this, _size);
      }
      /**
       * {@link LRUCache.OptionsBase.fetchMethod} (read-only)
       */
      get fetchMethod() {
        return __privateGet(this, _fetchMethod);
      }
      get memoMethod() {
        return __privateGet(this, _memoMethod);
      }
      /**
       * {@link LRUCache.OptionsBase.dispose} (read-only)
       */
      get dispose() {
        return __privateGet(this, _dispose);
      }
      /**
       * {@link LRUCache.OptionsBase.disposeAfter} (read-only)
       */
      get disposeAfter() {
        return __privateGet(this, _disposeAfter);
      }
      /**
       * Return the number of ms left in the item's TTL. If item is not in cache,
       * returns `0`. Returns `Infinity` if item is in cache without a defined TTL.
       */
      getRemainingTTL(key) {
        return __privateGet(this, _keyMap).has(key) ? Infinity : 0;
      }
      /**
       * Return a generator yielding `[key, value]` pairs,
       * in order from most recently used to least recently used.
       */
      *entries() {
        for (const i of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
          if (__privateGet(this, _valList)[i] !== void 0 && __privateGet(this, _keyList)[i] !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
            yield [__privateGet(this, _keyList)[i], __privateGet(this, _valList)[i]];
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.entries}
       *
       * Return a generator yielding `[key, value]` pairs,
       * in order from least recently used to most recently used.
       */
      *rentries() {
        for (const i of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this)) {
          if (__privateGet(this, _valList)[i] !== void 0 && __privateGet(this, _keyList)[i] !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
            yield [__privateGet(this, _keyList)[i], __privateGet(this, _valList)[i]];
          }
        }
      }
      /**
       * Return a generator yielding the keys in the cache,
       * in order from most recently used to least recently used.
       */
      *keys() {
        for (const i of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
          const k = __privateGet(this, _keyList)[i];
          if (k !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
            yield k;
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.keys}
       *
       * Return a generator yielding the keys in the cache,
       * in order from least recently used to most recently used.
       */
      *rkeys() {
        for (const i of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this)) {
          const k = __privateGet(this, _keyList)[i];
          if (k !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
            yield k;
          }
        }
      }
      /**
       * Return a generator yielding the values in the cache,
       * in order from most recently used to least recently used.
       */
      *values() {
        for (const i of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
          const v = __privateGet(this, _valList)[i];
          if (v !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
            yield __privateGet(this, _valList)[i];
          }
        }
      }
      /**
       * Inverse order version of {@link LRUCache.values}
       *
       * Return a generator yielding the values in the cache,
       * in order from least recently used to most recently used.
       */
      *rvalues() {
        for (const i of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this)) {
          const v = __privateGet(this, _valList)[i];
          if (v !== void 0 && !__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, __privateGet(this, _valList)[i])) {
            yield __privateGet(this, _valList)[i];
          }
        }
      }
      /**
       * Iterating over the cache itself yields the same results as
       * {@link LRUCache.entries}
       */
      [(_b = Symbol.iterator, _a2 = Symbol.toStringTag, _b)]() {
        return this.entries();
      }
      /**
       * Find a value for which the supplied fn method returns a truthy value,
       * similar to `Array.find()`. fn is called as `fn(value, key, cache)`.
       */
      find(fn, getOptions = {}) {
        for (const i of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
          const v = __privateGet(this, _valList)[i];
          const value = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          if (fn(value, __privateGet(this, _keyList)[i], this)) {
            return this.get(__privateGet(this, _keyList)[i], getOptions);
          }
        }
      }
      /**
       * Call the supplied function on each item in the cache, in order from most
       * recently used to least recently used.
       *
       * `fn` is called as `fn(value, key, cache)`.
       *
       * If `thisp` is provided, function will be called in the `this`-context of
       * the provided object, or the cache if no `thisp` object is provided.
       *
       * Does not update age or recenty of use, or iterate over stale values.
       */
      forEach(fn, thisp = this) {
        for (const i of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this)) {
          const v = __privateGet(this, _valList)[i];
          const value = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          fn.call(thisp, value, __privateGet(this, _keyList)[i], this);
        }
      }
      /**
       * The same as {@link LRUCache.forEach} but items are iterated over in
       * reverse order.  (ie, less recently used items are iterated over first.)
       */
      rforEach(fn, thisp = this) {
        for (const i of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this)) {
          const v = __privateGet(this, _valList)[i];
          const value = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
          if (value === void 0)
            continue;
          fn.call(thisp, value, __privateGet(this, _keyList)[i], this);
        }
      }
      /**
       * Delete any stale entries. Returns true if anything was removed,
       * false otherwise.
       */
      purgeStale() {
        let deleted = false;
        for (const i of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this, { allowStale: true })) {
          if (__privateGet(this, _isStale).call(this, i)) {
            __privateMethod(this, _LRUCache_instances, delete_fn).call(this, __privateGet(this, _keyList)[i], "expire");
            deleted = true;
          }
        }
        return deleted;
      }
      /**
       * Get the extended info about a given entry, to get its value, size, and
       * TTL info simultaneously. Returns `undefined` if the key is not present.
       *
       * Unlike {@link LRUCache#dump}, which is designed to be portable and survive
       * serialization, the `start` value is always the current timestamp, and the
       * `ttl` is a calculated remaining time to live (negative if expired).
       *
       * Always returns stale values, if their info is found in the cache, so be
       * sure to check for expirations (ie, a negative {@link LRUCache.Entry#ttl})
       * if relevant.
       */
      info(key) {
        const i = __privateGet(this, _keyMap).get(key);
        if (i === void 0)
          return void 0;
        const v = __privateGet(this, _valList)[i];
        const value = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
        if (value === void 0)
          return void 0;
        const entry = { value };
        if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
          const ttl = __privateGet(this, _ttls)[i];
          const start = __privateGet(this, _starts)[i];
          if (ttl && start) {
            const remain = ttl - (perf.now() - start);
            entry.ttl = remain;
            entry.start = Date.now();
          }
        }
        if (__privateGet(this, _sizes)) {
          entry.size = __privateGet(this, _sizes)[i];
        }
        return entry;
      }
      /**
       * Return an array of [key, {@link LRUCache.Entry}] tuples which can be
       * passed to {@link LRLUCache#load}.
       *
       * The `start` fields are calculated relative to a portable `Date.now()`
       * timestamp, even if `performance.now()` is available.
       *
       * Stale entries are always included in the `dump`, even if
       * {@link LRUCache.OptionsBase.allowStale} is false.
       *
       * Note: this returns an actual array, not a generator, so it can be more
       * easily passed around.
       */
      dump() {
        const arr = [];
        for (const i of __privateMethod(this, _LRUCache_instances, indexes_fn).call(this, { allowStale: true })) {
          const key = __privateGet(this, _keyList)[i];
          const v = __privateGet(this, _valList)[i];
          const value = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
          if (value === void 0 || key === void 0)
            continue;
          const entry = { value };
          if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
            entry.ttl = __privateGet(this, _ttls)[i];
            const age = perf.now() - __privateGet(this, _starts)[i];
            entry.start = Math.floor(Date.now() - age);
          }
          if (__privateGet(this, _sizes)) {
            entry.size = __privateGet(this, _sizes)[i];
          }
          arr.unshift([key, entry]);
        }
        return arr;
      }
      /**
       * Reset the cache and load in the items in entries in the order listed.
       *
       * The shape of the resulting cache may be different if the same options are
       * not used in both caches.
       *
       * The `start` fields are assumed to be calculated relative to a portable
       * `Date.now()` timestamp, even if `performance.now()` is available.
       */
      load(arr) {
        this.clear();
        for (const [key, entry] of arr) {
          if (entry.start) {
            const age = Date.now() - entry.start;
            entry.start = perf.now() - age;
          }
          this.set(key, entry.value, entry);
        }
      }
      /**
       * Add a value to the cache.
       *
       * Note: if `undefined` is specified as a value, this is an alias for
       * {@link LRUCache#delete}
       *
       * Fields on the {@link LRUCache.SetOptions} options param will override
       * their corresponding values in the constructor options for the scope
       * of this single `set()` operation.
       *
       * If `start` is provided, then that will set the effective start
       * time for the TTL calculation. Note that this must be a previous
       * value of `performance.now()` if supported, or a previous value of
       * `Date.now()` if not.
       *
       * Options object may also include `size`, which will prevent
       * calling the `sizeCalculation` function and just use the specified
       * number if it is a positive integer, and `noDisposeOnSet` which
       * will prevent calling a `dispose` function in the case of
       * overwrites.
       *
       * If the `size` (or return value of `sizeCalculation`) for a given
       * entry is greater than `maxEntrySize`, then the item will not be
       * added to the cache.
       *
       * Will update the recency of the entry.
       *
       * If the value is `undefined`, then this is an alias for
       * `cache.delete(key)`. `undefined` is never stored in the cache.
       */
      set(k, v, setOptions = {}) {
        var _a3, _b2, _c, _d, _e;
        if (v === void 0) {
          this.delete(k);
          return this;
        }
        const { ttl = this.ttl, start, noDisposeOnSet = this.noDisposeOnSet, sizeCalculation = this.sizeCalculation, status } = setOptions;
        let { noUpdateTTL = this.noUpdateTTL } = setOptions;
        const size = __privateGet(this, _requireSize).call(this, k, v, setOptions.size || 0, sizeCalculation);
        if (this.maxEntrySize && size > this.maxEntrySize) {
          if (status) {
            status.set = "miss";
            status.maxEntrySizeExceeded = true;
          }
          __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k, "set");
          return this;
        }
        let index = __privateGet(this, _size) === 0 ? void 0 : __privateGet(this, _keyMap).get(k);
        if (index === void 0) {
          index = __privateGet(this, _size) === 0 ? __privateGet(this, _tail) : __privateGet(this, _free).length !== 0 ? __privateGet(this, _free).pop() : __privateGet(this, _size) === __privateGet(this, _max) ? __privateMethod(this, _LRUCache_instances, evict_fn).call(this, false) : __privateGet(this, _size);
          __privateGet(this, _keyList)[index] = k;
          __privateGet(this, _valList)[index] = v;
          __privateGet(this, _keyMap).set(k, index);
          __privateGet(this, _next)[__privateGet(this, _tail)] = index;
          __privateGet(this, _prev)[index] = __privateGet(this, _tail);
          __privateSet(this, _tail, index);
          __privateWrapper(this, _size)._++;
          __privateGet(this, _addItemSize).call(this, index, size, status);
          if (status)
            status.set = "add";
          noUpdateTTL = false;
        } else {
          __privateMethod(this, _LRUCache_instances, moveToTail_fn).call(this, index);
          const oldVal = __privateGet(this, _valList)[index];
          if (v !== oldVal) {
            if (__privateGet(this, _hasFetchMethod) && __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, oldVal)) {
              oldVal.__abortController.abort(new Error("replaced"));
              const { __staleWhileFetching: s } = oldVal;
              if (s !== void 0 && !noDisposeOnSet) {
                if (__privateGet(this, _hasDispose)) {
                  (_a3 = __privateGet(this, _dispose)) == null ? void 0 : _a3.call(this, s, k, "set");
                }
                if (__privateGet(this, _hasDisposeAfter)) {
                  (_b2 = __privateGet(this, _disposed)) == null ? void 0 : _b2.push([s, k, "set"]);
                }
              }
            } else if (!noDisposeOnSet) {
              if (__privateGet(this, _hasDispose)) {
                (_c = __privateGet(this, _dispose)) == null ? void 0 : _c.call(this, oldVal, k, "set");
              }
              if (__privateGet(this, _hasDisposeAfter)) {
                (_d = __privateGet(this, _disposed)) == null ? void 0 : _d.push([oldVal, k, "set"]);
              }
            }
            __privateGet(this, _removeItemSize).call(this, index);
            __privateGet(this, _addItemSize).call(this, index, size, status);
            __privateGet(this, _valList)[index] = v;
            if (status) {
              status.set = "replace";
              const oldValue = oldVal && __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, oldVal) ? oldVal.__staleWhileFetching : oldVal;
              if (oldValue !== void 0)
                status.oldValue = oldValue;
            }
          } else if (status) {
            status.set = "update";
          }
        }
        if (ttl !== 0 && !__privateGet(this, _ttls)) {
          __privateMethod(this, _LRUCache_instances, initializeTTLTracking_fn).call(this);
        }
        if (__privateGet(this, _ttls)) {
          if (!noUpdateTTL) {
            __privateGet(this, _setItemTTL).call(this, index, ttl, start);
          }
          if (status)
            __privateGet(this, _statusTTL).call(this, status, index);
        }
        if (!noDisposeOnSet && __privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
          const dt = __privateGet(this, _disposed);
          let task;
          while (task = dt == null ? void 0 : dt.shift()) {
            (_e = __privateGet(this, _disposeAfter)) == null ? void 0 : _e.call(this, ...task);
          }
        }
        return this;
      }
      /**
       * Evict the least recently used item, returning its value or
       * `undefined` if cache is empty.
       */
      pop() {
        var _a3;
        try {
          while (__privateGet(this, _size)) {
            const val = __privateGet(this, _valList)[__privateGet(this, _head)];
            __privateMethod(this, _LRUCache_instances, evict_fn).call(this, true);
            if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, val)) {
              if (val.__staleWhileFetching) {
                return val.__staleWhileFetching;
              }
            } else if (val !== void 0) {
              return val;
            }
          }
        } finally {
          if (__privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
            const dt = __privateGet(this, _disposed);
            let task;
            while (task = dt == null ? void 0 : dt.shift()) {
              (_a3 = __privateGet(this, _disposeAfter)) == null ? void 0 : _a3.call(this, ...task);
            }
          }
        }
      }
      /**
       * Check if a key is in the cache, without updating the recency of use.
       * Will return false if the item is stale, even though it is technically
       * in the cache.
       *
       * Check if a key is in the cache, without updating the recency of
       * use. Age is updated if {@link LRUCache.OptionsBase.updateAgeOnHas} is set
       * to `true` in either the options or the constructor.
       *
       * Will return `false` if the item is stale, even though it is technically in
       * the cache. The difference can be determined (if it matters) by using a
       * `status` argument, and inspecting the `has` field.
       *
       * Will not update item age unless
       * {@link LRUCache.OptionsBase.updateAgeOnHas} is set.
       */
      has(k, hasOptions = {}) {
        const { updateAgeOnHas = this.updateAgeOnHas, status } = hasOptions;
        const index = __privateGet(this, _keyMap).get(k);
        if (index !== void 0) {
          const v = __privateGet(this, _valList)[index];
          if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) && v.__staleWhileFetching === void 0) {
            return false;
          }
          if (!__privateGet(this, _isStale).call(this, index)) {
            if (updateAgeOnHas) {
              __privateGet(this, _updateItemAge).call(this, index);
            }
            if (status) {
              status.has = "hit";
              __privateGet(this, _statusTTL).call(this, status, index);
            }
            return true;
          } else if (status) {
            status.has = "stale";
            __privateGet(this, _statusTTL).call(this, status, index);
          }
        } else if (status) {
          status.has = "miss";
        }
        return false;
      }
      /**
       * Like {@link LRUCache#get} but doesn't update recency or delete stale
       * items.
       *
       * Returns `undefined` if the item is stale, unless
       * {@link LRUCache.OptionsBase.allowStale} is set.
       */
      peek(k, peekOptions = {}) {
        const { allowStale = this.allowStale } = peekOptions;
        const index = __privateGet(this, _keyMap).get(k);
        if (index === void 0 || !allowStale && __privateGet(this, _isStale).call(this, index)) {
          return;
        }
        const v = __privateGet(this, _valList)[index];
        return __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v) ? v.__staleWhileFetching : v;
      }
      async fetch(k, fetchOptions = {}) {
        const {
          // get options
          allowStale = this.allowStale,
          updateAgeOnGet = this.updateAgeOnGet,
          noDeleteOnStaleGet = this.noDeleteOnStaleGet,
          // set options
          ttl = this.ttl,
          noDisposeOnSet = this.noDisposeOnSet,
          size = 0,
          sizeCalculation = this.sizeCalculation,
          noUpdateTTL = this.noUpdateTTL,
          // fetch exclusive options
          noDeleteOnFetchRejection = this.noDeleteOnFetchRejection,
          allowStaleOnFetchRejection = this.allowStaleOnFetchRejection,
          ignoreFetchAbort = this.ignoreFetchAbort,
          allowStaleOnFetchAbort = this.allowStaleOnFetchAbort,
          context,
          forceRefresh = false,
          status,
          signal
        } = fetchOptions;
        if (!__privateGet(this, _hasFetchMethod)) {
          if (status)
            status.fetch = "get";
          return this.get(k, {
            allowStale,
            updateAgeOnGet,
            noDeleteOnStaleGet,
            status
          });
        }
        const options = {
          allowStale,
          updateAgeOnGet,
          noDeleteOnStaleGet,
          ttl,
          noDisposeOnSet,
          size,
          sizeCalculation,
          noUpdateTTL,
          noDeleteOnFetchRejection,
          allowStaleOnFetchRejection,
          allowStaleOnFetchAbort,
          ignoreFetchAbort,
          status,
          signal
        };
        let index = __privateGet(this, _keyMap).get(k);
        if (index === void 0) {
          if (status)
            status.fetch = "miss";
          const p = __privateMethod(this, _LRUCache_instances, backgroundFetch_fn).call(this, k, index, options, context);
          return p.__returned = p;
        } else {
          const v = __privateGet(this, _valList)[index];
          if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
            const stale = allowStale && v.__staleWhileFetching !== void 0;
            if (status) {
              status.fetch = "inflight";
              if (stale)
                status.returnedStale = true;
            }
            return stale ? v.__staleWhileFetching : v.__returned = v;
          }
          const isStale = __privateGet(this, _isStale).call(this, index);
          if (!forceRefresh && !isStale) {
            if (status)
              status.fetch = "hit";
            __privateMethod(this, _LRUCache_instances, moveToTail_fn).call(this, index);
            if (updateAgeOnGet) {
              __privateGet(this, _updateItemAge).call(this, index);
            }
            if (status)
              __privateGet(this, _statusTTL).call(this, status, index);
            return v;
          }
          const p = __privateMethod(this, _LRUCache_instances, backgroundFetch_fn).call(this, k, index, options, context);
          const hasStale = p.__staleWhileFetching !== void 0;
          const staleVal = hasStale && allowStale;
          if (status) {
            status.fetch = isStale ? "stale" : "refresh";
            if (staleVal && isStale)
              status.returnedStale = true;
          }
          return staleVal ? p.__staleWhileFetching : p.__returned = p;
        }
      }
      async forceFetch(k, fetchOptions = {}) {
        const v = await this.fetch(k, fetchOptions);
        if (v === void 0)
          throw new Error("fetch() returned undefined");
        return v;
      }
      memo(k, memoOptions = {}) {
        const memoMethod = __privateGet(this, _memoMethod);
        if (!memoMethod) {
          throw new Error("no memoMethod provided to constructor");
        }
        const { context, forceRefresh, ...options } = memoOptions;
        const v = this.get(k, options);
        if (!forceRefresh && v !== void 0)
          return v;
        const vv = memoMethod(k, v, {
          options,
          context
        });
        this.set(k, vv, options);
        return vv;
      }
      /**
       * Return a value from the cache. Will update the recency of the cache
       * entry found.
       *
       * If the key is not found, get() will return `undefined`.
       */
      get(k, getOptions = {}) {
        const { allowStale = this.allowStale, updateAgeOnGet = this.updateAgeOnGet, noDeleteOnStaleGet = this.noDeleteOnStaleGet, status } = getOptions;
        const index = __privateGet(this, _keyMap).get(k);
        if (index !== void 0) {
          const value = __privateGet(this, _valList)[index];
          const fetching = __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, value);
          if (status)
            __privateGet(this, _statusTTL).call(this, status, index);
          if (__privateGet(this, _isStale).call(this, index)) {
            if (status)
              status.get = "stale";
            if (!fetching) {
              if (!noDeleteOnStaleGet) {
                __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k, "expire");
              }
              if (status && allowStale)
                status.returnedStale = true;
              return allowStale ? value : void 0;
            } else {
              if (status && allowStale && value.__staleWhileFetching !== void 0) {
                status.returnedStale = true;
              }
              return allowStale ? value.__staleWhileFetching : void 0;
            }
          } else {
            if (status)
              status.get = "hit";
            if (fetching) {
              return value.__staleWhileFetching;
            }
            __privateMethod(this, _LRUCache_instances, moveToTail_fn).call(this, index);
            if (updateAgeOnGet) {
              __privateGet(this, _updateItemAge).call(this, index);
            }
            return value;
          }
        } else if (status) {
          status.get = "miss";
        }
      }
      /**
       * Deletes a key out of the cache.
       *
       * Returns true if the key was deleted, false otherwise.
       */
      delete(k) {
        return __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k, "delete");
      }
      /**
       * Clear the cache entirely, throwing away all values.
       */
      clear() {
        return __privateMethod(this, _LRUCache_instances, clear_fn).call(this, "delete");
      }
    };
    _max = new WeakMap();
    _maxSize = new WeakMap();
    _dispose = new WeakMap();
    _disposeAfter = new WeakMap();
    _fetchMethod = new WeakMap();
    _memoMethod = new WeakMap();
    _size = new WeakMap();
    _calculatedSize = new WeakMap();
    _keyMap = new WeakMap();
    _keyList = new WeakMap();
    _valList = new WeakMap();
    _next = new WeakMap();
    _prev = new WeakMap();
    _head = new WeakMap();
    _tail = new WeakMap();
    _free = new WeakMap();
    _disposed = new WeakMap();
    _sizes = new WeakMap();
    _starts = new WeakMap();
    _ttls = new WeakMap();
    _hasDispose = new WeakMap();
    _hasFetchMethod = new WeakMap();
    _hasDisposeAfter = new WeakMap();
    _LRUCache_instances = new WeakSet();
    initializeTTLTracking_fn = function() {
      const ttls = new ZeroArray(__privateGet(this, _max));
      const starts = new ZeroArray(__privateGet(this, _max));
      __privateSet(this, _ttls, ttls);
      __privateSet(this, _starts, starts);
      __privateSet(this, _setItemTTL, (index, ttl, start = perf.now()) => {
        starts[index] = ttl !== 0 ? start : 0;
        ttls[index] = ttl;
        if (ttl !== 0 && this.ttlAutopurge) {
          const t = setTimeout(() => {
            if (__privateGet(this, _isStale).call(this, index)) {
              __privateMethod(this, _LRUCache_instances, delete_fn).call(this, __privateGet(this, _keyList)[index], "expire");
            }
          }, ttl + 1);
          if (t.unref) {
            t.unref();
          }
        }
      });
      __privateSet(this, _updateItemAge, (index) => {
        starts[index] = ttls[index] !== 0 ? perf.now() : 0;
      });
      __privateSet(this, _statusTTL, (status, index) => {
        if (ttls[index]) {
          const ttl = ttls[index];
          const start = starts[index];
          if (!ttl || !start)
            return;
          status.ttl = ttl;
          status.start = start;
          status.now = cachedNow || getNow();
          const age = status.now - start;
          status.remainingTTL = ttl - age;
        }
      });
      let cachedNow = 0;
      const getNow = () => {
        const n = perf.now();
        if (this.ttlResolution > 0) {
          cachedNow = n;
          const t = setTimeout(() => cachedNow = 0, this.ttlResolution);
          if (t.unref) {
            t.unref();
          }
        }
        return n;
      };
      this.getRemainingTTL = (key) => {
        const index = __privateGet(this, _keyMap).get(key);
        if (index === void 0) {
          return 0;
        }
        const ttl = ttls[index];
        const start = starts[index];
        if (!ttl || !start) {
          return Infinity;
        }
        const age = (cachedNow || getNow()) - start;
        return ttl - age;
      };
      __privateSet(this, _isStale, (index) => {
        const s = starts[index];
        const t = ttls[index];
        return !!t && !!s && (cachedNow || getNow()) - s > t;
      });
    };
    _updateItemAge = new WeakMap();
    _statusTTL = new WeakMap();
    _setItemTTL = new WeakMap();
    _isStale = new WeakMap();
    initializeSizeTracking_fn = function() {
      const sizes = new ZeroArray(__privateGet(this, _max));
      __privateSet(this, _calculatedSize, 0);
      __privateSet(this, _sizes, sizes);
      __privateSet(this, _removeItemSize, (index) => {
        __privateSet(this, _calculatedSize, __privateGet(this, _calculatedSize) - sizes[index]);
        sizes[index] = 0;
      });
      __privateSet(this, _requireSize, (k, v, size, sizeCalculation) => {
        if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
          return 0;
        }
        if (!isPosInt(size)) {
          if (sizeCalculation) {
            if (typeof sizeCalculation !== "function") {
              throw new TypeError("sizeCalculation must be a function");
            }
            size = sizeCalculation(v, k);
            if (!isPosInt(size)) {
              throw new TypeError("sizeCalculation return invalid (expect positive integer)");
            }
          } else {
            throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");
          }
        }
        return size;
      });
      __privateSet(this, _addItemSize, (index, size, status) => {
        sizes[index] = size;
        if (__privateGet(this, _maxSize)) {
          const maxSize = __privateGet(this, _maxSize) - sizes[index];
          while (__privateGet(this, _calculatedSize) > maxSize) {
            __privateMethod(this, _LRUCache_instances, evict_fn).call(this, true);
          }
        }
        __privateSet(this, _calculatedSize, __privateGet(this, _calculatedSize) + sizes[index]);
        if (status) {
          status.entrySize = size;
          status.totalCalculatedSize = __privateGet(this, _calculatedSize);
        }
      });
    };
    _removeItemSize = new WeakMap();
    _addItemSize = new WeakMap();
    _requireSize = new WeakMap();
    indexes_fn = function* ({ allowStale = this.allowStale } = {}) {
      if (__privateGet(this, _size)) {
        for (let i = __privateGet(this, _tail); true; ) {
          if (!__privateMethod(this, _LRUCache_instances, isValidIndex_fn).call(this, i)) {
            break;
          }
          if (allowStale || !__privateGet(this, _isStale).call(this, i)) {
            yield i;
          }
          if (i === __privateGet(this, _head)) {
            break;
          } else {
            i = __privateGet(this, _prev)[i];
          }
        }
      }
    };
    rindexes_fn = function* ({ allowStale = this.allowStale } = {}) {
      if (__privateGet(this, _size)) {
        for (let i = __privateGet(this, _head); true; ) {
          if (!__privateMethod(this, _LRUCache_instances, isValidIndex_fn).call(this, i)) {
            break;
          }
          if (allowStale || !__privateGet(this, _isStale).call(this, i)) {
            yield i;
          }
          if (i === __privateGet(this, _tail)) {
            break;
          } else {
            i = __privateGet(this, _next)[i];
          }
        }
      }
    };
    isValidIndex_fn = function(index) {
      return index !== void 0 && __privateGet(this, _keyMap).get(__privateGet(this, _keyList)[index]) === index;
    };
    evict_fn = function(free) {
      var _a3, _b2;
      const head = __privateGet(this, _head);
      const k = __privateGet(this, _keyList)[head];
      const v = __privateGet(this, _valList)[head];
      if (__privateGet(this, _hasFetchMethod) && __privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
        v.__abortController.abort(new Error("evicted"));
      } else if (__privateGet(this, _hasDispose) || __privateGet(this, _hasDisposeAfter)) {
        if (__privateGet(this, _hasDispose)) {
          (_a3 = __privateGet(this, _dispose)) == null ? void 0 : _a3.call(this, v, k, "evict");
        }
        if (__privateGet(this, _hasDisposeAfter)) {
          (_b2 = __privateGet(this, _disposed)) == null ? void 0 : _b2.push([v, k, "evict"]);
        }
      }
      __privateGet(this, _removeItemSize).call(this, head);
      if (free) {
        __privateGet(this, _keyList)[head] = void 0;
        __privateGet(this, _valList)[head] = void 0;
        __privateGet(this, _free).push(head);
      }
      if (__privateGet(this, _size) === 1) {
        __privateSet(this, _head, __privateSet(this, _tail, 0));
        __privateGet(this, _free).length = 0;
      } else {
        __privateSet(this, _head, __privateGet(this, _next)[head]);
      }
      __privateGet(this, _keyMap).delete(k);
      __privateWrapper(this, _size)._--;
      return head;
    };
    backgroundFetch_fn = function(k, index, options, context) {
      const v = index === void 0 ? void 0 : __privateGet(this, _valList)[index];
      if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
        return v;
      }
      const ac = new AC();
      const { signal } = options;
      signal == null ? void 0 : signal.addEventListener("abort", () => ac.abort(signal.reason), {
        signal: ac.signal
      });
      const fetchOpts = {
        signal: ac.signal,
        options,
        context
      };
      const cb = (v2, updateCache = false) => {
        const { aborted } = ac.signal;
        const ignoreAbort = options.ignoreFetchAbort && v2 !== void 0;
        if (options.status) {
          if (aborted && !updateCache) {
            options.status.fetchAborted = true;
            options.status.fetchError = ac.signal.reason;
            if (ignoreAbort)
              options.status.fetchAbortIgnored = true;
          } else {
            options.status.fetchResolved = true;
          }
        }
        if (aborted && !ignoreAbort && !updateCache) {
          return fetchFail(ac.signal.reason);
        }
        const bf2 = p;
        if (__privateGet(this, _valList)[index] === p) {
          if (v2 === void 0) {
            if (bf2.__staleWhileFetching) {
              __privateGet(this, _valList)[index] = bf2.__staleWhileFetching;
            } else {
              __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k, "fetch");
            }
          } else {
            if (options.status)
              options.status.fetchUpdated = true;
            this.set(k, v2, fetchOpts.options);
          }
        }
        return v2;
      };
      const eb = (er) => {
        if (options.status) {
          options.status.fetchRejected = true;
          options.status.fetchError = er;
        }
        return fetchFail(er);
      };
      const fetchFail = (er) => {
        const { aborted } = ac.signal;
        const allowStaleAborted = aborted && options.allowStaleOnFetchAbort;
        const allowStale = allowStaleAborted || options.allowStaleOnFetchRejection;
        const noDelete = allowStale || options.noDeleteOnFetchRejection;
        const bf2 = p;
        if (__privateGet(this, _valList)[index] === p) {
          const del = !noDelete || bf2.__staleWhileFetching === void 0;
          if (del) {
            __privateMethod(this, _LRUCache_instances, delete_fn).call(this, k, "fetch");
          } else if (!allowStaleAborted) {
            __privateGet(this, _valList)[index] = bf2.__staleWhileFetching;
          }
        }
        if (allowStale) {
          if (options.status && bf2.__staleWhileFetching !== void 0) {
            options.status.returnedStale = true;
          }
          return bf2.__staleWhileFetching;
        } else if (bf2.__returned === bf2) {
          throw er;
        }
      };
      const pcall = (res, rej) => {
        var _a3;
        const fmp = (_a3 = __privateGet(this, _fetchMethod)) == null ? void 0 : _a3.call(this, k, v, fetchOpts);
        if (fmp && fmp instanceof Promise) {
          fmp.then((v2) => res(v2 === void 0 ? void 0 : v2), rej);
        }
        ac.signal.addEventListener("abort", () => {
          if (!options.ignoreFetchAbort || options.allowStaleOnFetchAbort) {
            res(void 0);
            if (options.allowStaleOnFetchAbort) {
              res = (v2) => cb(v2, true);
            }
          }
        });
      };
      if (options.status)
        options.status.fetchDispatched = true;
      const p = new Promise(pcall).then(cb, eb);
      const bf = Object.assign(p, {
        __abortController: ac,
        __staleWhileFetching: v,
        __returned: void 0
      });
      if (index === void 0) {
        this.set(k, bf, { ...fetchOpts.options, status: void 0 });
        index = __privateGet(this, _keyMap).get(k);
      } else {
        __privateGet(this, _valList)[index] = bf;
      }
      return bf;
    };
    isBackgroundFetch_fn = function(p) {
      if (!__privateGet(this, _hasFetchMethod))
        return false;
      const b = p;
      return !!b && b instanceof Promise && b.hasOwnProperty("__staleWhileFetching") && b.__abortController instanceof AC;
    };
    connect_fn = function(p, n) {
      __privateGet(this, _prev)[n] = p;
      __privateGet(this, _next)[p] = n;
    };
    moveToTail_fn = function(index) {
      if (index !== __privateGet(this, _tail)) {
        if (index === __privateGet(this, _head)) {
          __privateSet(this, _head, __privateGet(this, _next)[index]);
        } else {
          __privateMethod(this, _LRUCache_instances, connect_fn).call(this, __privateGet(this, _prev)[index], __privateGet(this, _next)[index]);
        }
        __privateMethod(this, _LRUCache_instances, connect_fn).call(this, __privateGet(this, _tail), index);
        __privateSet(this, _tail, index);
      }
    };
    delete_fn = function(k, reason) {
      var _a3, _b2, _c, _d;
      let deleted = false;
      if (__privateGet(this, _size) !== 0) {
        const index = __privateGet(this, _keyMap).get(k);
        if (index !== void 0) {
          deleted = true;
          if (__privateGet(this, _size) === 1) {
            __privateMethod(this, _LRUCache_instances, clear_fn).call(this, reason);
          } else {
            __privateGet(this, _removeItemSize).call(this, index);
            const v = __privateGet(this, _valList)[index];
            if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
              v.__abortController.abort(new Error("deleted"));
            } else if (__privateGet(this, _hasDispose) || __privateGet(this, _hasDisposeAfter)) {
              if (__privateGet(this, _hasDispose)) {
                (_a3 = __privateGet(this, _dispose)) == null ? void 0 : _a3.call(this, v, k, reason);
              }
              if (__privateGet(this, _hasDisposeAfter)) {
                (_b2 = __privateGet(this, _disposed)) == null ? void 0 : _b2.push([v, k, reason]);
              }
            }
            __privateGet(this, _keyMap).delete(k);
            __privateGet(this, _keyList)[index] = void 0;
            __privateGet(this, _valList)[index] = void 0;
            if (index === __privateGet(this, _tail)) {
              __privateSet(this, _tail, __privateGet(this, _prev)[index]);
            } else if (index === __privateGet(this, _head)) {
              __privateSet(this, _head, __privateGet(this, _next)[index]);
            } else {
              const pi = __privateGet(this, _prev)[index];
              __privateGet(this, _next)[pi] = __privateGet(this, _next)[index];
              const ni = __privateGet(this, _next)[index];
              __privateGet(this, _prev)[ni] = __privateGet(this, _prev)[index];
            }
            __privateWrapper(this, _size)._--;
            __privateGet(this, _free).push(index);
          }
        }
      }
      if (__privateGet(this, _hasDisposeAfter) && ((_c = __privateGet(this, _disposed)) == null ? void 0 : _c.length)) {
        const dt = __privateGet(this, _disposed);
        let task;
        while (task = dt == null ? void 0 : dt.shift()) {
          (_d = __privateGet(this, _disposeAfter)) == null ? void 0 : _d.call(this, ...task);
        }
      }
      return deleted;
    };
    clear_fn = function(reason) {
      var _a3, _b2, _c;
      for (const index of __privateMethod(this, _LRUCache_instances, rindexes_fn).call(this, { allowStale: true })) {
        const v = __privateGet(this, _valList)[index];
        if (__privateMethod(this, _LRUCache_instances, isBackgroundFetch_fn).call(this, v)) {
          v.__abortController.abort(new Error("deleted"));
        } else {
          const k = __privateGet(this, _keyList)[index];
          if (__privateGet(this, _hasDispose)) {
            (_a3 = __privateGet(this, _dispose)) == null ? void 0 : _a3.call(this, v, k, reason);
          }
          if (__privateGet(this, _hasDisposeAfter)) {
            (_b2 = __privateGet(this, _disposed)) == null ? void 0 : _b2.push([v, k, reason]);
          }
        }
      }
      __privateGet(this, _keyMap).clear();
      __privateGet(this, _valList).fill(void 0);
      __privateGet(this, _keyList).fill(void 0);
      if (__privateGet(this, _ttls) && __privateGet(this, _starts)) {
        __privateGet(this, _ttls).fill(0);
        __privateGet(this, _starts).fill(0);
      }
      if (__privateGet(this, _sizes)) {
        __privateGet(this, _sizes).fill(0);
      }
      __privateSet(this, _head, 0);
      __privateSet(this, _tail, 0);
      __privateGet(this, _free).length = 0;
      __privateSet(this, _calculatedSize, 0);
      __privateSet(this, _size, 0);
      if (__privateGet(this, _hasDisposeAfter) && __privateGet(this, _disposed)) {
        const dt = __privateGet(this, _disposed);
        let task;
        while (task = dt == null ? void 0 : dt.shift()) {
          (_c = __privateGet(this, _disposeAfter)) == null ? void 0 : _c.call(this, ...task);
        }
      }
    };
    var LRUCache = _LRUCache;
    exports.LRUCache = LRUCache;
  }
});

// node_modules/mariadb/lib/lru-prepare-cache.js
var require_lru_prepare_cache = __commonJS({
  "node_modules/mariadb/lib/lru-prepare-cache.js"(exports, module) {
    "use strict";
    var LRU = require_commonjs();
    var _lruCache, _info;
    var LruPrepareCache = class {
      /**
       * Creates a new LRU prepare cache
       *
       * @param {Object} info - Database connection information
       * @param {number} prepareCacheLength - Maximum number of prepared statements to cache
       */
      constructor(info, prepareCacheLength) {
        __privateAdd(this, _lruCache);
        __privateAdd(this, _info);
        if (!Number.isInteger(prepareCacheLength) || prepareCacheLength <= 0) {
          throw new TypeError("prepareCacheLength must be a positive integer");
        }
        __privateSet(this, _info, info);
        __privateSet(this, _lruCache, new LRU.LRUCache({
          max: prepareCacheLength,
          dispose: (value, key) => value.unCache()
        }));
      }
      /**
       * Gets a cached prepared statement
       *
       * @param {string} sql - SQL statement to retrieve
       * @returns {Object|null} Cached prepared statement or null if not found
       */
      get(sql) {
        const key = __privateGet(this, _info).database + "|" + sql;
        const cachedItem = __privateGet(this, _lruCache).get(key);
        if (cachedItem) {
          return cachedItem.incrementUse();
        }
        return null;
      }
      /**
       * Adds a prepared statement to the cache
       *
       * @param {string} sql - SQL statement
       * @param {Object} cache - Prepared statement object
       * @returns {void}
       */
      set(sql, cache) {
        const key = __privateGet(this, _info).database + "|" + sql;
        __privateGet(this, _lruCache).set(key, cache);
      }
      /**
       * Provides a string representation of the cache contents
       *
       * @returns {string} String representation of cache
       */
      toString() {
        const keys = [...__privateGet(this, _lruCache).keys()];
        const keyStr = keys.length ? keys.map((key) => `[${key}]`).join(",") : "";
        return `info{cache:${keyStr}}`;
      }
      /**
       * Clears all cached prepared statements
       *
       * @returns {void}
       */
      reset() {
        __privateGet(this, _lruCache).clear();
      }
    };
    _lruCache = new WeakMap();
    _info = new WeakMap();
    module.exports = LruPrepareCache;
  }
});

// node_modules/mariadb/lib/connection.js
var require_connection = __commonJS({
  "node_modules/mariadb/lib/connection.js"(exports, module) {
    "use strict";
    var EventEmitter = require_events();
    var Queue = require_denque();
    var Net = require_net();
    var PacketInputStream = require_packet_input_stream();
    var PacketOutputStream = require_packet_output_stream();
    var CompressionInputStream = require_compression_input_stream();
    var CompressionOutputStream = require_compression_output_stream();
    var ServerStatus = require_server_status();
    var ConnectionInformation = require_connection_information();
    var tls = require_tls();
    var Errors = require_errors();
    var Utils = require_utils();
    var Capabilities = require_capabilities();
    var ConnectionOptions = require_connection_options();
    var Authentication = require_authentication();
    var Quit = require_quit();
    var Ping = require_ping();
    var Reset = require_reset();
    var Query = require_query();
    var Prepare = require_prepare();
    var OkPacket = require_ok_packet();
    var Execute = require_execute();
    var ClosePrepare = require_close_prepare();
    var BatchBulk = require_batch_bulk();
    var ChangeUser = require_change_user();
    var { Status } = require_connection_status();
    var LruPrepareCache = require_lru_prepare_cache();
    var fsPromises = require_fs().promises;
    var Parse = require_parse();
    var Collations = require_collations();
    var ConnOptions = require_connection_options();
    var convertFixedTime = function(tz, conn) {
      if (tz === "UTC" || tz === "Etc/UTC" || tz === "Z" || tz === "Etc/GMT") {
        return "+00:00";
      } else if (tz.startsWith("Etc/GMT") || tz.startsWith("GMT")) {
        let tzdiff;
        let negate;
        if (tz.startsWith("Etc/GMT")) {
          tzdiff = tz.substring(7);
          negate = !tzdiff.startsWith("-");
        } else {
          tzdiff = tz.substring(3);
          negate = tzdiff.startsWith("-");
        }
        let diff = parseInt(tzdiff.substring(1));
        if (isNaN(diff)) {
          throw Errors.createFatalError(
            `Automatic timezone setting fails. wrong Server timezone '${tz}' conversion to +/-HH:00 conversion.`,
            Errors.ER_WRONG_AUTO_TIMEZONE,
            conn.info
          );
        }
        return (negate ? "-" : "+") + (diff >= 10 ? diff : "0" + diff) + ":00";
      }
      return tz;
    };
    var redirectUrlFormat = /(mariadb|mysql):\/\/(([^/@:]+)?(:([^/]+))?@)?(([^/:]+)(:([0-9]+))?)(\/([^?]+)(\?(.*))?)?$/;
    var Connection = class _Connection extends EventEmitter {
      constructor(options) {
        super();
        __publicField(this, "opts");
        __publicField(this, "sendQueue", new Queue());
        __publicField(this, "receiveQueue", new Queue());
        __publicField(this, "waitingAuthenticationQueue", new Queue());
        __publicField(this, "status", Status.NOT_CONNECTED);
        __publicField(this, "socket", null);
        __publicField(this, "timeout", null);
        __publicField(this, "addCommand");
        __publicField(this, "streamOut");
        __publicField(this, "streamIn");
        __publicField(this, "info");
        __publicField(this, "prepareCache");
        this.opts = Object.assign(new EventEmitter(), options);
        this.info = new ConnectionInformation(this.opts, this.redirect.bind(this));
        this.prepareCache = this.opts.prepareCacheLength > 0 ? new LruPrepareCache(this.info, this.opts.prepareCacheLength) : null;
        this.addCommand = this.addCommandQueue;
        this.streamOut = new PacketOutputStream(this.opts, this.info);
        this.streamIn = new PacketInputStream(
          this.unexpectedPacket.bind(this),
          this.receiveQueue,
          this.streamOut,
          this.opts,
          this.info
        );
        this.on("close_prepare", this._closePrepare.bind(this));
        this.escape = Utils.escape.bind(this, this.opts, this.info);
        this.escapeId = Utils.escapeId.bind(this, this.opts, this.info);
      }
      //*****************************************************************
      // public methods
      //*****************************************************************
      /**
       * Connect event
       *
       * @returns {Promise} promise
       */
      connect() {
        const conn = this;
        this.status = Status.CONNECTING;
        const authenticationParam = {
          opts: this.opts
        };
        return new Promise(function(resolve, reject) {
          conn.connectRejectFct = reject;
          conn.connectResolveFct = resolve;
          const authentication = new Authentication(
            authenticationParam,
            conn.authSucceedHandler.bind(conn),
            conn.authFailHandler.bind(conn),
            conn.createSecureContext.bind(conn),
            conn.getSocket.bind(conn)
          );
          Error.captureStackTrace(authentication);
          authentication.once("end", () => {
            conn.receiveQueue.shift();
            if (!conn.opts.collation && conn.info.collation) {
              conn.opts.emit("collation", conn.info.collation);
            }
            process.nextTick(conn.nextSendCmd.bind(conn));
          });
          conn.receiveQueue.push(authentication);
          conn.streamInitSocket.call(conn);
        });
      }
      /**
       * Execute a prepared statement with the given parameters
       *
       * @param {Object} cmdParam - Command parameters
       * @param {Object} prepare - Prepared statement
       * @param {Function} resolve - Promise resolve function
       * @param {Function} reject - Promise reject function
       */
      executePromise(cmdParam, prepare, resolve, reject) {
        const cmd = new Execute(resolve, this._logAndReject.bind(this, reject), this.opts, cmdParam, prepare);
        this.addCommand(cmd, true);
      }
      /**
       * Execute a batch of the same SQL statement with different parameter sets
       *
       * @param {Object|String} cmdParam - SQL statement or options object
       * @param {function} resolve - promise resolve function
       * @param {function} reject - promise reject function
       */
      batch(cmdParam, resolve, reject) {
        if (!cmdParam.sql) {
          return this.handleMissingSqlError(reject);
        }
        if (!cmdParam.values) {
          return this.handleMissingValuesError(cmdParam, reject);
        }
        this.prepare(
          cmdParam,
          (prepare) => this.executeBatch(cmdParam, prepare, resolve, reject),
          (err) => this._logAndReject(reject, err)
        );
      }
      /**
       * Handle missing SQL parameter error
       *
       * @param {Function} reject - Promise reject function
       * @private
       */
      handleMissingSqlError(reject) {
        const err = Errors.createError(
          "sql parameter is mandatory",
          Errors.ER_UNDEFINED_SQL,
          this.info,
          "HY000",
          null,
          false
        );
        Error.captureStackTrace(err, this.handleMissingSqlError);
        this._logAndReject(reject, err);
      }
      /**
       * Handle missing values parameter error
       *
       * @param {Object} cmdParam - Command parameters
       * @param {Function} reject - Promise reject function
       * @private
       */
      handleMissingValuesError(cmdParam, reject) {
        const sql = cmdParam.sql;
        const debugSql = sql.length > this.opts.debugLen ? sql.substring(0, this.opts.debugLen) + "..." : sql;
        const err = Errors.createError(
          "Batch must have values set",
          Errors.ER_BATCH_WITH_NO_VALUES,
          this.info,
          "HY000",
          debugSql,
          false,
          cmdParam.stack
        );
        this._logAndReject(reject, err);
      }
      /**
       * Execute batch operation with prepared statement
       *
       * @param {Object} cmdParam - Command parameters
       * @param {Object} prepare - Prepared statement
       * @param {Function} resolve - Promise resolve function
       * @param {Function} reject - Promise reject function
       * @private
       */
      executeBatch(cmdParam, prepare, resolve, reject) {
        const usePlaceHolder = cmdParam.opts && cmdParam.opts.namedPlaceholders || this.opts.namedPlaceholders;
        let values = this.formatBatchValues(cmdParam.values, usePlaceHolder, prepare.parameterCount);
        cmdParam.values = values;
        const useBulk = this._canUseBulk(values, cmdParam.opts);
        if (useBulk) {
          this.executeBulkPromise(cmdParam, prepare, this.opts, resolve, reject);
        } else {
          this.executeIndividualBatches(cmdParam, prepare, resolve, reject);
        }
      }
      /**
       * Execute bulk operation using specialized bulk protocol
       *
       * @param {Object} cmdParam - Command parameters
       * @param {Object} prepare - Prepared statement
       * @param {Object} opts - Options
       * @param {Function} resolve - Promise resolve function
       * @param {Function} reject - Promise reject function
       * @private
       */
      executeBulkPromise(cmdParam, prepare, opts, resolve, reject) {
        const cmd = new BatchBulk(
          (res) => {
            prepare.close();
            return resolve(res);
          },
          (err) => {
            prepare.close();
            if (opts.logger.error) opts.logger.error(err);
            reject(err);
          },
          opts,
          prepare,
          cmdParam
        );
        this.addCommand(cmd, true);
      }
      /**
       * Format batch values into the correct structure
       *
       * @param {Array} values - Original values array
       * @param {Boolean} usePlaceHolder - Whether named placeholders are used
       * @param {Number} parameterCount - Number of parameters in prepared statement
       * @returns {Array} Formatted values array
       * @private
       */
      formatBatchValues(values, usePlaceHolder, parameterCount) {
        if (!Array.isArray(values)) {
          return [[values]];
        }
        if (usePlaceHolder) {
          return values;
        }
        if (Array.isArray(values[0])) {
          return values;
        }
        if (parameterCount === 1) {
          const result = new Array(values.length);
          for (let i = 0; i < values.length; i++) {
            result[i] = [values[i]];
          }
          return result;
        }
        return [values];
      }
      /**
       * Execute individual batch operations when bulk protocol can't be used
       *
       * @param {Object} cmdParam - Command parameters
       * @param {Object} prepare - Prepared statement
       * @param {Function} resolve - Promise resolve function
       * @param {Function} reject - Promise reject function
       * @private
       */
      executeIndividualBatches(cmdParam, prepare, resolve, reject) {
        const results = [];
        const batchSize = 1e3;
        const totalBatches = Math.ceil(cmdParam.values.length / batchSize);
        this.executeBatchChunk(cmdParam, prepare, 0, batchSize, totalBatches, results, resolve, reject);
      }
      /**
       * Execute a chunk of the batch operations
       *
       * @param {Object} cmdParam - Command parameters
       * @param {Object} prepare - Prepared statement
       * @param {Number} chunkIndex - Current chunk index
       * @param {Number} batchSize - Size of each batch chunk
       * @param {Number} totalBatches - Total number of chunks
       * @param {Array} results - Accumulated results
       * @param {Function} resolve - Promise resolve function
       * @param {Function} reject - Promise reject function
       * @private
       */
      executeBatchChunk(cmdParam, prepare, chunkIndex, batchSize, totalBatches, results, resolve, reject) {
        const values = cmdParam.values;
        const startIdx = chunkIndex * batchSize;
        const endIdx = Math.min(startIdx + batchSize, values.length);
        const executes = [];
        for (let i = startIdx; i < endIdx; i++) {
          executes.push(prepare.execute(values[i], cmdParam.opts, null, cmdParam.stack));
        }
        Promise.all(executes).then(
          (chunkResults) => {
            results.push(...chunkResults);
            if (chunkIndex === totalBatches - 1) {
              const cmdOpt = Object.assign({}, this.opts, cmdParam.opts);
              this.processBatchResults(results, cmdOpt, cmdParam, resolve);
              prepare.close();
            } else {
              setImmediate(() => {
                this.executeBatchChunk(
                  cmdParam,
                  prepare,
                  chunkIndex + 1,
                  batchSize,
                  totalBatches,
                  results,
                  resolve,
                  reject
                );
              });
            }
          },
          (err) => {
            prepare.close();
            reject(err);
          }
        ).catch((err) => {
          prepare.close();
          reject(err);
        });
      }
      /**
       * Process batch results from individual executions
       *
       * @param {Array} results - Array of individual results
       * @param {Object} cmdOpt - Command options
       * @param {Object} cmdParam - Command parameters
       * @param {Function} resolve - Promise resolve function
       * @private
       */
      processBatchResults(results, cmdOpt, cmdParam, resolve) {
        if (!results.length) {
          resolve(cmdOpt.metaAsArray ? [[], []] : []);
          return;
        }
        const fullResult = cmdOpt.fullResult === void 0 || cmdOpt.fullResult;
        if (fullResult) {
          if (cmdOpt.metaAsArray) {
            const aggregateResults = results.reduce((accumulator, currentValue) => {
              if (Array.isArray(currentValue[0])) {
                accumulator.push(...currentValue[0]);
              } else if (currentValue[0] instanceof OkPacket) {
                accumulator.push(currentValue[0]);
              } else {
                accumulator.push([currentValue[0]]);
              }
              return accumulator;
            }, []);
            const meta = results[0][1];
            resolve([aggregateResults, meta]);
          } else {
            const aggregateResults = results.reduce((accumulator, currentValue) => {
              if (currentValue instanceof OkPacket) {
                accumulator.push(currentValue);
              } else if (!cmdOpt.rowsAsArray && Array.isArray(currentValue[0])) {
                accumulator.push(...currentValue[0]);
              } else {
                accumulator.push(currentValue[0]);
              }
              return accumulator;
            }, []);
            const meta = results[0].meta;
            Object.defineProperty(aggregateResults, "meta", {
              value: meta,
              writable: true,
              enumerable: cmdOpt.metaEnumerable
            });
            resolve(aggregateResults);
          }
          return;
        }
        const firstResult = cmdOpt.metaAsArray ? results[0][0] : results[0];
        if (firstResult instanceof OkPacket) {
          this.aggregateOkPackets(results, cmdOpt, resolve);
        } else {
          this.aggregateResultSets(results, cmdOpt, resolve);
        }
      }
      /**
       * Aggregate OK packets from multiple executions
       *
       * @param {Array} results - Array of individual results
       * @param {Object} cmdOpt - Command options
       * @param {Function} resolve - Promise resolve function
       * @private
       */
      aggregateOkPackets(results, cmdOpt, resolve) {
        const insertId = results[0].insertId;
        const warningStatus = results[results.length - 1].warningStatus;
        let affectedRows = 0;
        if (cmdOpt.metaAsArray) {
          affectedRows = results.reduce((sum, result) => sum + result[0].affectedRows, 0);
          resolve([new OkPacket(affectedRows, insertId, warningStatus), []]);
        } else {
          affectedRows = results.reduce((sum, result) => sum + result.affectedRows, 0);
          resolve(new OkPacket(affectedRows, insertId, warningStatus));
        }
      }
      /**
       * Aggregate result sets from multiple executions
       *
       * @param {Array} results - Array of individual results
       * @param {Object} cmdOpt - Command options
       * @param {Function} resolve - Promise resolve function
       * @private
       */
      aggregateResultSets(results, cmdOpt, resolve) {
        if (cmdOpt.metaAsArray) {
          const totalLength = results.reduce((sum, row) => {
            var _a;
            return sum + (((_a = row[0]) == null ? void 0 : _a.length) || 0);
          }, 0);
          const rs = new Array(totalLength);
          let index = 0;
          for (const row of results) {
            if (row[0] && row[0].length) {
              const rowData = row[0];
              for (let i = 0; i < rowData.length; i++) {
                rs[index++] = rowData[i];
              }
            }
          }
          resolve([rs.slice(0, index), results[0][1]]);
        } else {
          const totalLength = results.reduce((sum, row) => sum + (Array.isArray(row) ? row.length : 0), 0);
          const rs = new Array(totalLength);
          let index = 0;
          for (const row of results) {
            if (Array.isArray(row) && row.length) {
              for (let i = 0; i < row.length; i++) {
                rs[index++] = row[i];
              }
            }
          }
          const finalResult = rs.slice(0, index);
          if (results[0] && results[0].meta) {
            Object.defineProperty(finalResult, "meta", {
              value: results[0].meta,
              writable: true,
              enumerable: cmdOpt.metaEnumerable
            });
          }
          resolve(finalResult);
        }
      }
      /**
       * Send an empty MySQL packet to ensure connection is active, and reset @@wait_timeout
       * @param {Object} cmdParam - command context
       * @param {Function} resolve - success function
       * @param {Function} reject - rejection function
       */
      ping(cmdParam, resolve, reject) {
        if (cmdParam.opts && cmdParam.opts.timeout !== void 0) {
          if (cmdParam.opts.timeout < 0) {
            const err = Errors.createError(
              "Ping cannot have negative timeout value",
              Errors.ER_BAD_PARAMETER_VALUE,
              this.info,
              "0A000"
            );
            this._logAndReject(reject, err);
            return;
          }
          let timeoutRef = setTimeout(() => {
            timeoutRef = void 0;
            const err = Errors.createFatalError("Ping timeout", Errors.ER_PING_TIMEOUT, this.info, "0A000");
            this.addCommand = this.addCommandDisabled;
            clearTimeout(this.timeout);
            if (this.status !== Status.CLOSING && this.status !== Status.CLOSED) {
              this.sendQueue.clear();
              this.status = Status.CLOSED;
              this.socket.destroy();
            }
            this.clear();
            this._logAndReject(reject, err);
          }, cmdParam.opts.timeout);
          this.addCommand(
            new Ping(
              cmdParam,
              () => {
                if (timeoutRef) {
                  clearTimeout(timeoutRef);
                  resolve();
                }
              },
              (err) => {
                if (timeoutRef) {
                  clearTimeout(timeoutRef);
                  this._logAndReject(reject, err);
                }
              }
            ),
            true
          );
          return;
        }
        this.addCommand(new Ping(cmdParam, resolve, reject), true);
      }
      /**
       * Send a reset command that will
       * - rollback any open transaction
       * - reset transaction isolation level
       * - reset session variables
       * - delete user variables
       * - remove temporary tables
       * - remove all PREPARE statement
       */
      reset(cmdParam, resolve, reject) {
        if (this.info.isMariaDB() && this.info.hasMinVersion(10, 2, 4) || !this.info.isMariaDB() && this.info.hasMinVersion(5, 7, 3)) {
          const conn = this;
          const resetCmd = new Reset(
            cmdParam,
            () => {
              if (conn.prepareCache) conn.prepareCache.reset();
              let prom = Promise.resolve();
              prom.then(conn.handleCharset.bind(conn)).then(conn.handleTimezone.bind(conn)).then(conn.executeInitQuery.bind(conn)).then(conn.executeSessionTimeout.bind(conn)).then(resolve).catch(reject);
            },
            reject
          );
          this.addCommand(resetCmd, true);
          return;
        }
        const err = new Error(
          `Reset command not permitted for server ${this.info.serverVersion.raw} (requires server MariaDB version 10.2.4+ or MySQL 5.7.3+)`
        );
        err.stack = cmdParam.stack;
        this._logAndReject(reject, err);
      }
      /**
       * Indicates the state of the connection as the driver knows it
       * @returns {boolean}
       */
      isValid() {
        return this.status === Status.CONNECTED;
      }
      /**
       * Terminate connection gracefully.
       */
      end(cmdParam, resolve, reject) {
        this.addCommand = this.addCommandDisabled;
        clearTimeout(this.timeout);
        if (this.status < Status.CLOSING && this.status !== Status.NOT_CONNECTED) {
          this.status = Status.CLOSING;
          const ended = () => {
            this.status = Status.CLOSED;
            this.socket.destroy();
            this.socket.unref();
            this.clear();
            this.receiveQueue.clear();
            resolve();
          };
          const quitCmd = new Quit(cmdParam, ended, ended);
          this.sendQueue.push(quitCmd);
          this.receiveQueue.push(quitCmd);
          if (this.sendQueue.length === 1) {
            process.nextTick(this.nextSendCmd.bind(this));
          }
        } else resolve();
      }
      /**
       * Force connection termination by closing the underlying socket and killing server process if any.
       */
      destroy() {
        this.addCommand = this.addCommandDisabled;
        clearTimeout(this.timeout);
        if (this.status < Status.CLOSING) {
          this.status = Status.CLOSING;
          this.sendQueue.clear();
          if (this.receiveQueue.length > 0) {
            const self = this;
            const remoteAddress = this.socket.remoteAddress;
            const connOption = remoteAddress ? Object.assign({}, this.opts, { host: remoteAddress }) : this.opts;
            const killCon = new _Connection(connOption);
            killCon.connect().then(() => {
              new Promise(killCon.query.bind(killCon, { sql: `KILL ${self.info.threadId}` })).finally((err) => {
                const destroyError = Errors.createFatalError(
                  "Connection destroyed, command was killed",
                  Errors.ER_CMD_NOT_EXECUTED_DESTROYED,
                  self.info
                );
                if (self.opts.logger.error) self.opts.logger.error(destroyError);
                self.socketErrorDispatchToQueries(destroyError);
                if (self.socket) {
                  const sok = self.socket;
                  process.nextTick(() => {
                    sok.destroy();
                  });
                }
                self.status = Status.CLOSED;
                self.clear();
                new Promise(killCon.end.bind(killCon)).catch(() => {
                });
              });
            }).catch(() => {
              const ended = () => {
                let sock = self.socket;
                self.clear();
                self.status = Status.CLOSED;
                sock.destroy();
                self.receiveQueue.clear();
              };
              const quitCmd = new Quit(ended, ended);
              self.sendQueue.push(quitCmd);
              self.receiveQueue.push(quitCmd);
              if (self.sendQueue.length === 1) {
                process.nextTick(self.nextSendCmd.bind(self));
              }
            });
          } else {
            this.status = Status.CLOSED;
            this.socket.destroy();
            this.clear();
          }
        }
      }
      pause() {
        this.socket.pause();
      }
      resume() {
        this.socket.resume();
      }
      format(sql, values) {
        const err = Errors.createError(
          '"Connection.format intentionally not implemented. please use Connection.query(sql, values), it will be more secure and faster',
          Errors.ER_NOT_IMPLEMENTED_FORMAT,
          this.info,
          "0A000"
        );
        if (this.opts.logger.error) this.opts.logger.error(err);
        throw err;
      }
      //*****************************************************************
      // additional public methods
      //*****************************************************************
      /**
       * return current connected server version information.
       *
       * @returns {*}
       */
      serverVersion() {
        if (!this.info.serverVersion) {
          const err = new Error("cannot know if server information until connection is established");
          if (this.opts.logger.error) this.opts.logger.error(err);
          throw err;
        }
        return this.info.serverVersion.raw;
      }
      /**
       * Change option "debug" during connection.
       * @param val   debug value
       */
      debug(val) {
        if (typeof val === "boolean") {
          if (val && !this.opts.logger.network) this.opts.logger.network = console.log;
        } else if (typeof val === "function") {
          this.opts.logger.network = val;
        }
        this.opts.emit("debug", val);
      }
      debugCompress(val) {
        if (val) {
          if (typeof val === "boolean") {
            this.opts.debugCompress = val;
            if (val && !this.opts.logger.network) this.opts.logger.network = console.log;
          } else if (typeof val === "function") {
            this.opts.debugCompress = true;
            this.opts.logger.network = val;
          }
        } else this.opts.debugCompress = false;
      }
      //*****************************************************************
      // internal public testing methods
      //*****************************************************************
      get __tests() {
        return new TestMethods(this.info.collation, this.socket);
      }
      //*****************************************************************
      // internal methods
      //*****************************************************************
      /**
       * Determine if the bulk protocol can be used for batch operations
       *
       * @param {Array} values - Batch values array
       * @param {Object} options - Batch options
       * @return {boolean} Whether bulk protocol can be used
       * @private
       */
      _canUseBulk(values, options) {
        if (options && options.fullResult && (this.info.clientCapabilities & Capabilities.BULK_UNIT_RESULTS) === 0n) {
          return false;
        }
        const bulkEnable = options === void 0 || options === null ? this.opts.bulk : options.bulk !== void 0 && options.bulk !== null ? options.bulk : this.opts.bulk;
        const serverSupportsBulk = this.info.serverVersion && this.info.serverVersion.mariaDb && this.info.hasMinVersion(10, 2, 7) && (this.info.serverCapabilities & Capabilities.MARIADB_CLIENT_STMT_BULK_OPERATIONS) > 0n;
        if (!serverSupportsBulk || !bulkEnable) {
          return false;
        }
        if (values === void 0) {
          return true;
        }
        if (!this.opts.namedPlaceholders) {
          return this._validatePositionalParameters(values);
        } else {
          return this._validateNamedParameters(values);
        }
      }
      /**
       * Validate batch values for positional parameters
       *
       * @param {Array} values - Batch values array
       * @return {boolean} Whether values are valid for bulk protocol
       * @private
       */
      _validatePositionalParameters(values) {
        const paramLen = Array.isArray(values[0]) ? values[0].length : values[0] ? 1 : 0;
        if (paramLen === 0) {
          return false;
        }
        for (const row of values) {
          const rowArray = Array.isArray(row) ? row : [row];
          if (paramLen !== rowArray.length) {
            return false;
          }
          for (const val of rowArray) {
            if (this._isStreamingValue(val)) {
              return false;
            }
          }
        }
        return true;
      }
      /**
       * Validate batch values for named parameters
       *
       * @param {Array} values - Batch values array
       * @return {boolean} Whether values are valid for bulk protocol
       * @private
       */
      _validateNamedParameters(values) {
        for (const row of values) {
          for (const val of Object.values(row)) {
            if (this._isStreamingValue(val)) {
              return false;
            }
          }
        }
        return true;
      }
      /**
       * Check if a value is a streaming value
       *
       * @param {*} val - Value to check
       * @return {boolean} Whether value is a streaming value
       * @private
       */
      _isStreamingValue(val) {
        return val != null && typeof val === "object" && typeof val.pipe === "function" && typeof val.read === "function";
      }
      executeSessionVariableQuery() {
        if (this.opts.sessionVariables) {
          const values = [];
          let sessionQuery = "set ";
          let keys = Object.keys(this.opts.sessionVariables);
          if (keys.length > 0) {
            for (let k = 0; k < keys.length; ++k) {
              sessionQuery += (k !== 0 ? "," : "") + "@@" + keys[k].replace(/[^a-z0-9_]/gi, "") + "=?";
              values.push(this.opts.sessionVariables[keys[k]]);
            }
            return new Promise(
              this.query.bind(this, {
                sql: sessionQuery,
                values
              })
            ).catch((initialErr) => {
              const err = Errors.createFatalError(
                `Error setting session variable (value ${JSON.stringify(this.opts.sessionVariables)}). Error: ${initialErr.message}`,
                Errors.ER_SETTING_SESSION_ERROR,
                this.info,
                "08S01",
                sessionQuery
              );
              if (this.opts.logger.error) this.opts.logger.error(err);
              return Promise.reject(err);
            });
          }
        }
        return Promise.resolve();
      }
      /**
       * set charset to charset/collation if set or utf8mb4 if not.
       * @returns {Promise<void>}
       * @private
       */
      handleCharset() {
        if (this.opts.collation) {
          if (this.opts.collation.index <= 255) return Promise.resolve();
          const charset = this.opts.collation.charset === "utf8" && this.opts.collation.maxLength === 4 ? "utf8mb4" : this.opts.collation.charset;
          return new Promise(
            this.query.bind(this, {
              sql: `SET NAMES ${charset} COLLATE ${this.opts.collation.name}`
            })
          );
        }
        if (!this.opts.charset && this.info.collation && this.info.collation.charset === "utf8" && this.info.collation.maxLength === 4) {
          this.info.collation = Collations.fromCharset("utf8mb4");
          return Promise.resolve();
        }
        const connCharset = this.opts.charset ? this.opts.charset : "utf8mb4";
        this.info.collation = Collations.fromCharset(connCharset);
        return new Promise(
          this.query.bind(this, {
            sql: `SET NAMES ${connCharset}`
          })
        );
      }
      /**
       * Asking server timezone if not set in case of 'auto'
       * @returns {Promise<void>}
       * @private
       */
      handleTimezone() {
        const conn = this;
        if (this.opts.timezone === "local") this.opts.timezone = void 0;
        if (this.opts.timezone === "auto") {
          return new Promise(
            this.query.bind(this, {
              sql: "SELECT @@system_time_zone stz, @@time_zone tz"
            })
          ).then((res) => {
            const serverTimezone = res[0].tz === "SYSTEM" ? res[0].stz : res[0].tz;
            const localTz = Intl.DateTimeFormat().resolvedOptions().timeZone;
            if (serverTimezone === localTz || convertFixedTime(serverTimezone, conn) === convertFixedTime(localTz, conn)) {
              this.opts.timezone = localTz;
              return Promise.resolve();
            }
            return this._setSessionTimezone(convertFixedTime(localTz, conn));
          });
        }
        if (this.opts.timezone) {
          return this._setSessionTimezone(convertFixedTime(this.opts.timezone, conn));
        }
        return Promise.resolve();
      }
      _setSessionTimezone(tz) {
        return new Promise(
          this.query.bind(this, {
            sql: "SET time_zone=?",
            values: [tz]
          })
        ).catch((err) => {
          const er = Errors.createFatalError(
            `setting timezone '${tz}' fails on server.
 look at https://mariadb.com/kb/en/mysql_tzinfo_to_sql/ to load IANA timezone. `,
            Errors.ER_WRONG_IANA_TIMEZONE,
            this.info
          );
          if (this.opts.logger.error) this.opts.logger.error(er);
          return Promise.reject(er);
        });
      }
      checkServerVersion() {
        if (!this.opts.forceVersionCheck) {
          return Promise.resolve();
        }
        return new Promise(
          this.query.bind(this, {
            sql: "SELECT @@VERSION AS v"
          })
        ).then(
          (function(res) {
            this.info.serverVersion.raw = res[0].v;
            this.info.serverVersion.mariaDb = this.info.serverVersion.raw.includes("MariaDB");
            ConnectionInformation.parseVersionString(this.info);
            return Promise.resolve();
          }).bind(this)
        );
      }
      executeInitQuery() {
        if (this.opts.initSql) {
          const initialArr = Array.isArray(this.opts.initSql) ? this.opts.initSql : [this.opts.initSql];
          const initialPromises = [];
          initialArr.forEach((sql) => {
            initialPromises.push(
              new Promise(
                this.query.bind(this, {
                  sql
                })
              )
            );
          });
          return Promise.all(initialPromises).catch((initialErr) => {
            const err = Errors.createFatalError(
              `Error executing initial sql command: ${initialErr.message}`,
              Errors.ER_INITIAL_SQL_ERROR,
              this.info
            );
            if (this.opts.logger.error) this.opts.logger.error(err);
            return Promise.reject(err);
          });
        }
        return Promise.resolve();
      }
      executeSessionTimeout() {
        if (this.opts.queryTimeout) {
          if (this.info.isMariaDB() && this.info.hasMinVersion(10, 1, 2)) {
            const query = `SET max_statement_time=${this.opts.queryTimeout / 1e3}`;
            new Promise(
              this.query.bind(this, {
                sql: query
              })
            ).catch(
              (function(initialErr) {
                const err = Errors.createFatalError(
                  `Error setting session queryTimeout: ${initialErr.message}`,
                  Errors.ER_INITIAL_TIMEOUT_ERROR,
                  this.info,
                  "08S01",
                  query
                );
                if (this.opts.logger.error) this.opts.logger.error(err);
                return Promise.reject(err);
              }).bind(this)
            );
          } else {
            const err = Errors.createError(
              `Can only use queryTimeout for MariaDB server after 10.1.1. queryTimeout value: ${this.opts.queryTimeout}`,
              Errors.ER_TIMEOUT_NOT_SUPPORTED,
              this.info,
              "HY000",
              this.opts.queryTimeout
            );
            if (this.opts.logger.error) this.opts.logger.error(err);
            return Promise.reject(err);
          }
        }
        return Promise.resolve();
      }
      getSocket() {
        return this.socket;
      }
      /**
       * Initialize socket and associate events.
       * @private
       */
      streamInitSocket() {
        if (this.opts.connectTimeout) {
          this.timeout = setTimeout(this.connectTimeoutReached.bind(this), this.opts.connectTimeout, Date.now());
        }
        if (this.opts.socketPath) {
          this.socket = Net.connect(this.opts.socketPath);
        } else if (this.opts.stream) {
          if (typeof this.opts.stream === "function") {
            const tmpSocket = this.opts.stream(
              (function(err, stream) {
                if (err) {
                  this.authFailHandler(err);
                  return;
                }
                this.socket = stream ? stream : Net.connect(this.opts.port, this.opts.host);
                this.socketInit();
              }).bind(this)
            );
            if (tmpSocket) {
              this.socket = tmpSocket;
              this.socketInit();
            }
          } else {
            this.authFailHandler(
              Errors.createError(
                "stream option is not a function. stream must be a function with (error, callback) parameter",
                Errors.ER_BAD_PARAMETER_VALUE,
                this.info
              )
            );
          }
          return;
        } else {
          this.socket = Net.connect(this.opts.port, this.opts.host);
          this.socket.setNoDelay(true);
        }
        this.socketInit();
      }
      socketInit() {
        this.socket.on("data", this.streamIn.onData.bind(this.streamIn));
        this.socket.on("error", this.socketErrorHandler.bind(this));
        this.socket.on("end", this.socketErrorHandler.bind(this));
        this.socket.on(
          "connect",
          (function() {
            if (this.status === Status.CONNECTING) {
              this.status = Status.AUTHENTICATING;
              this.socket.setNoDelay(true);
              this.socket.setTimeout(this.opts.socketTimeout, this.socketTimeoutReached.bind(this));
              if (this.opts.keepAliveDelay >= 0) {
                this.socket.setKeepAlive(true, this.opts.keepAliveDelay);
              } else {
                this.socket.setKeepAlive(true);
              }
            }
          }).bind(this)
        );
        this.socket.writeBuf = (buf) => this.socket.write(buf);
        this.socket.flush = () => {
        };
        this.streamOut.setStream(this.socket);
      }
      /**
       * Authentication success result handler.
       *
       * @private
       */
      authSucceedHandler() {
        if (this.opts.compress) {
          if (this.info.serverCapabilities & Capabilities.COMPRESS) {
            this.streamOut.setStream(new CompressionOutputStream(this.socket, this.opts, this.info));
            this.streamIn = new CompressionInputStream(this.streamIn, this.receiveQueue, this.opts, this.info);
            this.socket.removeAllListeners("data");
            this.socket.on("data", this.streamIn.onData.bind(this.streamIn));
          } else if (this.opts.logger.error) {
            this.opts.logger.error(
              Errors.createError(
                "connection is configured to use packet compression, but the server doesn't have this capability",
                Errors.ER_COMPRESSION_NOT_SUPPORTED,
                this.info
              )
            );
          }
        }
        this.addCommand = this.opts.pipelining ? this.addCommandEnablePipeline : this.addCommandEnable;
        const conn = this;
        this.status = Status.INIT_CMD;
        this.executeSessionVariableQuery().then(conn.handleCharset.bind(conn)).then(this.handleTimezone.bind(this)).then(this.checkServerVersion.bind(this)).then(this.executeInitQuery.bind(this)).then(this.executeSessionTimeout.bind(this)).then(() => {
          clearTimeout(this.timeout);
          conn.status = Status.CONNECTED;
          process.nextTick(conn.connectResolveFct, conn);
          const commands = conn.waitingAuthenticationQueue.toArray();
          commands.forEach((cmd) => {
            conn.addCommand(cmd, true);
          });
          conn.waitingAuthenticationQueue = null;
          conn.connectRejectFct = null;
          conn.connectResolveFct = null;
        }).catch((err) => {
          if (!err.fatal) {
            const res = () => {
              conn.authFailHandler.call(conn, err);
            };
            conn.end(res, res);
          } else {
            conn.authFailHandler.call(conn, err);
          }
          return Promise.reject(err);
        });
      }
      /**
       * Authentication failed result handler.
       *
       * @private
       */
      authFailHandler(err) {
        clearTimeout(this.timeout);
        if (this.connectRejectFct) {
          if (this.opts.logger.error) this.opts.logger.error(err);
          this.receiveQueue.shift();
          this.fatalError(err, true);
          process.nextTick(this.connectRejectFct, err);
          this.connectRejectFct = null;
        }
      }
      /**
       * Create TLS socket and associate events.
       *
       * @param info current connection information
       * @param callback  callback function when done
       * @private
       */
      createSecureContext(info, callback) {
        info.requireValidCert = this.opts.ssl === true || this.opts.ssl.rejectUnauthorized === void 0 || this.opts.ssl.rejectUnauthorized === true;
        const baseConf = { socket: this.socket };
        if (info.isMariaDB()) {
          baseConf["rejectUnauthorized"] = false;
        }
        const sslOption = this.opts.ssl === true ? baseConf : Object.assign({}, this.opts.ssl, baseConf);
        try {
          const secureSocket = tls.connect(sslOption, callback);
          secureSocket.on("data", this.streamIn.onData.bind(this.streamIn));
          secureSocket.on("error", this.socketErrorHandler.bind(this));
          secureSocket.on("end", this.socketErrorHandler.bind(this));
          secureSocket.writeBuf = (buf) => secureSocket.write(buf);
          secureSocket.flush = () => {
          };
          this.socket.removeAllListeners("data");
          this.socket = secureSocket;
          this.streamOut.setStream(secureSocket);
        } catch (err) {
          this.socketErrorHandler(err);
        }
      }
      /**
       * Handle packet when no packet is expected.
       * (there can be an ERROR packet send by server/proxy to inform that connection is ending).
       *
       * @param packet  packet
       * @private
       */
      unexpectedPacket(packet) {
        if (packet && packet.peek() === 255) {
          let err = packet.readError(this.info);
          if (err.fatal && this.status < Status.CLOSING) {
            this.emit("error", err);
            if (this.opts.logger.error) this.opts.logger.error(err);
            this.end(
              () => {
              },
              () => {
              }
            );
          }
        } else if (this.status < Status.CLOSING) {
          const err = Errors.createFatalError(
            `receiving packet from server without active commands
conn:${this.info.threadId ? this.info.threadId : -1}(${packet.pos},${packet.end})
${Utils.log(this.opts, packet.buf, packet.pos, packet.end)}`,
            Errors.ER_UNEXPECTED_PACKET,
            this.info
          );
          if (this.opts.logger.error) this.opts.logger.error(err);
          this.emit("error", err);
          this.destroy();
        }
      }
      /**
       * Handle connection timeout.
       *
       * @private
       */
      connectTimeoutReached(initialConnectionTime) {
        this.timeout = null;
        const handshake = this.receiveQueue.peekFront();
        const err = Errors.createFatalError(
          `Connection timeout: failed to create socket after ${Date.now() - initialConnectionTime}ms`,
          Errors.ER_CONNECTION_TIMEOUT,
          this.info,
          "08S01",
          null,
          handshake ? handshake.stack : null
        );
        if (this.opts.logger.error) this.opts.logger.error(err);
        this.authFailHandler(err);
      }
      /**
       * Handle socket timeout.
       *
       * @private
       */
      socketTimeoutReached() {
        clearTimeout(this.timeout);
        const err = Errors.createFatalError("socket timeout", Errors.ER_SOCKET_TIMEOUT, this.info);
        if (this.opts.logger.error) this.opts.logger.error(err);
        this.fatalError(err, true);
      }
      /**
       * Add command to waiting queue until authentication.
       *
       * @param cmd         command
       * @private
       */
      addCommandQueue(cmd) {
        this.waitingAuthenticationQueue.push(cmd);
      }
      /**
       * Add command to command sending and receiving queue.
       *
       * @param cmd         command
       * @param expectResponse queue command response
       * @private
       */
      addCommandEnable(cmd, expectResponse) {
        cmd.once("end", this._sendNextCmdImmediate.bind(this));
        if (this.sendQueue.isEmpty() && this.receiveQueue.isEmpty()) {
          if (expectResponse) this.receiveQueue.push(cmd);
          cmd.start(this.streamOut, this.opts, this.info);
        } else {
          if (expectResponse) this.receiveQueue.push(cmd);
          this.sendQueue.push(cmd);
        }
      }
      /**
       * Add command to command sending and receiving queue using pipelining
       *
       * @param cmd             command
       * @param expectResponse queue command response
       * @private
       */
      addCommandEnablePipeline(cmd, expectResponse) {
        cmd.once("send_end", this._sendNextCmdImmediate.bind(this));
        if (expectResponse) this.receiveQueue.push(cmd);
        if (this.sendQueue.isEmpty()) {
          cmd.start(this.streamOut, this.opts, this.info);
          if (cmd.sending) {
            this.sendQueue.push(cmd);
            cmd.prependOnceListener("send_end", this.sendQueue.shift.bind(this.sendQueue));
          }
        } else {
          this.sendQueue.push(cmd);
        }
      }
      /**
       * Replacing command when connection is closing or closed to send a proper error message.
       *
       * @param cmd         command
       * @private
       */
      addCommandDisabled(cmd) {
        const err = cmd.throwNewError(
          "Cannot execute new commands: connection closed",
          true,
          this.info,
          "08S01",
          Errors.ER_CMD_CONNECTION_CLOSED
        );
        if (this.opts.logger.error) this.opts.logger.error(err);
      }
      /**
       * Handle socket error.
       *
       * @param err               socket error
       * @private
       */
      socketErrorHandler(err) {
        if (this.status >= Status.CLOSING) return;
        if (this.socket) {
          this.socket.writeBuf = () => {
          };
          this.socket.flush = () => {
          };
        }
        if (!err) {
          err = Errors.createFatalError(
            "socket has unexpectedly been closed",
            Errors.ER_SOCKET_UNEXPECTED_CLOSE,
            this.info
          );
        } else {
          err.fatal = true;
          err.sqlState = "HY000";
        }
        switch (this.status) {
          case Status.CONNECTING:
          case Status.AUTHENTICATING:
            const currentCmd = this.receiveQueue.peekFront();
            if (currentCmd && currentCmd.stack && err) {
              err.stack += "\n From event:\n" + currentCmd.stack.substring(currentCmd.stack.indexOf("\n") + 1);
            }
            this.authFailHandler(err);
            break;
          default:
            this.fatalError(err, false);
        }
      }
      /**
       * Fatal unexpected error : closing connection, and throw exception.
       */
      fatalError(err, avoidThrowError) {
        if (this.status >= Status.CLOSING) {
          this.socketErrorDispatchToQueries(err);
          return;
        }
        const mustThrowError = this.status !== Status.CONNECTING;
        this.status = Status.CLOSING;
        this.addCommand = this.addCommandDisabled;
        if (this.socket) {
          this.socket.removeAllListeners();
          if (!this.socket.destroyed) this.socket.destroy();
          this.socket = void 0;
        }
        this.status = Status.CLOSED;
        const errorThrownByCmd = this.socketErrorDispatchToQueries(err);
        if (mustThrowError) {
          if (this.opts.logger.error) this.opts.logger.error(err);
          if (this.listenerCount("error") > 0) {
            this.emit("error", err);
            this.emit("end");
            this.clear();
          } else {
            this.emit("end");
            this.clear();
            if (!avoidThrowError && !errorThrownByCmd) throw err;
          }
        } else {
          this.clear();
        }
      }
      /**
       * Dispatch fatal error to current running queries.
       *
       * @param err        the fatal error
       * @return {boolean} return if error has been relayed to queries
       */
      socketErrorDispatchToQueries(err) {
        let receiveCmd;
        let errorThrownByCmd = false;
        while (receiveCmd = this.receiveQueue.shift()) {
          if (receiveCmd && receiveCmd.onPacketReceive) {
            errorThrownByCmd = true;
            setImmediate(receiveCmd.throwError.bind(receiveCmd, err, this.info));
          }
        }
        return errorThrownByCmd;
      }
      /**
       * Will send next command in queue if any.
       *
       * @private
       */
      nextSendCmd() {
        let sendCmd;
        if (sendCmd = this.sendQueue.shift()) {
          if (sendCmd.sending) {
            this.sendQueue.unshift(sendCmd);
          } else {
            sendCmd.start(this.streamOut, this.opts, this.info);
            if (sendCmd.sending) {
              this.sendQueue.unshift(sendCmd);
              sendCmd.prependOnceListener("send_end", this.sendQueue.shift.bind(this.sendQueue));
            }
          }
        }
      }
      /**
       * Change transaction state.
       *
       * @param cmdParam command parameter
       * @param resolve success function to call
       * @param reject error function to call
       * @private
       */
      changeTransaction(cmdParam, resolve, reject) {
        if (this.status >= Status.CLOSING) {
          const err = Errors.createFatalError(
            "Cannot execute new commands: connection closed",
            Errors.ER_CMD_CONNECTION_CLOSED,
            this.info,
            "08S01",
            cmdParam.sql
          );
          this._logAndReject(reject, err);
          return;
        }
        if (this.receiveQueue.peekFront() || this.info.status & ServerStatus.STATUS_IN_TRANS) {
          const cmd = new Query(resolve, (err) => this._logAndReject(reject, err), this.opts, cmdParam);
          this.addCommand(cmd, true);
        } else resolve();
      }
      changeUser(cmdParam, resolve, reject) {
        if (!this.info.isMariaDB()) {
          const err = Errors.createError(
            "method changeUser not available for MySQL server due to Bug #83472",
            Errors.ER_MYSQL_CHANGE_USER_BUG,
            this.info,
            "0A000"
          );
          this._logAndReject(reject, err);
          return;
        }
        if (this.status < Status.CLOSING) {
          this.addCommand = this.addCommandEnable;
        }
        let conn = this;
        if (cmdParam.opts && cmdParam.opts.collation && typeof cmdParam.opts.collation === "string") {
          const val = cmdParam.opts.collation.toUpperCase();
          cmdParam.opts.collation = Collations.fromName(cmdParam.opts.collation.toUpperCase());
          if (cmdParam.opts.collation === void 0) return reject(new RangeError(`Unknown collation '${val}'`));
        }
        this.addCommand(
          new ChangeUser(
            cmdParam,
            this.opts,
            (res) => {
              if (conn.status < Status.CLOSING && conn.opts.pipelining) conn.addCommand = conn.addCommandEnablePipeline;
              if (cmdParam.opts && cmdParam.opts.collation) conn.opts.collation = cmdParam.opts.collation;
              conn.handleCharset().then(() => {
                if (cmdParam.opts && cmdParam.opts.collation) {
                  conn.info.collation = cmdParam.opts.collation;
                  conn.opts.emit("collation", cmdParam.opts.collation);
                }
                resolve(res);
              }).catch((err) => {
                const res2 = () => conn.authFailHandler.call(conn, err);
                if (!err.fatal) {
                  conn.end(res2, res2);
                } else {
                  res2();
                }
                reject(err);
              });
            },
            this.authFailHandler.bind(this, reject),
            this.getSocket.bind(this)
          ),
          true
        );
      }
      query(cmdParam, resolve, reject) {
        if (!cmdParam.sql)
          return reject(
            Errors.createError(
              "sql parameter is mandatory",
              Errors.ER_UNDEFINED_SQL,
              this.info,
              "HY000",
              null,
              false,
              cmdParam.stack
            )
          );
        const cmd = new Query(resolve, (err) => this._logAndReject(reject, err), this.opts, cmdParam);
        this.addCommand(cmd, true);
      }
      prepare(cmdParam, resolve, reject) {
        if (!cmdParam.sql) {
          reject(Errors.createError("sql parameter is mandatory", Errors.ER_UNDEFINED_SQL, this.info, "HY000"));
          return;
        }
        if (this.prepareCache && (this.sendQueue.isEmpty() || !this.receiveQueue.peekFront())) {
          const cachedPrepare = this.prepareCache.get(cmdParam.sql);
          if (cachedPrepare) {
            resolve(cachedPrepare);
            return;
          }
        }
        const cmd = new Prepare(resolve, (err) => this._logAndReject(reject, err), this.opts, cmdParam, this);
        this.addCommand(cmd, true);
      }
      prepareExecute(cmdParam, resolve, reject) {
        if (!cmdParam.sql) {
          reject(Errors.createError("sql parameter is mandatory", Errors.ER_UNDEFINED_SQL, this.info, "HY000"));
          return;
        }
        if (this.prepareCache && (this.sendQueue.isEmpty() || !this.receiveQueue.peekFront())) {
          const cachedPrepare = this.prepareCache.get(cmdParam.sql);
          if (cachedPrepare) {
            this.executePromise(
              cmdParam,
              cachedPrepare,
              (res) => {
                resolve(res);
                cachedPrepare.close();
              },
              (err) => {
                reject(err);
                cachedPrepare.close();
              }
            );
            return;
          }
        }
        const conn = this;
        if (this.opts.pipelining && this.info.isMariaDB() && this.info.hasMinVersion(10, 2, 4)) {
          let hasStreamingValue = false;
          const vals = cmdParam.values ? Array.isArray(cmdParam.values) ? cmdParam.values : [cmdParam.values] : [];
          for (let i = 0; i < vals.length; i++) {
            const val = vals[i];
            if (val != null && typeof val === "object" && typeof val.pipe === "function" && typeof val.read === "function") {
              hasStreamingValue = true;
            }
          }
          if (!hasStreamingValue) {
            let nbExecute = 0;
            const executeCommand = new Execute(
              (res) => {
                if (nbExecute++ === 0) {
                  executeCommand.prepare.close();
                  resolve(res);
                }
              },
              (err) => {
                if (nbExecute++ === 0) {
                  if (conn.opts.logger.error) conn.opts.logger.error(err);
                  reject(err);
                  if (executeCommand.prepare) {
                    executeCommand.prepare.close();
                  }
                }
              },
              conn.opts,
              cmdParam,
              null
            );
            cmdParam.executeCommand = executeCommand;
            const cmd2 = new Prepare(
              (prep) => {
                if (nbExecute > 0) prep.close();
              },
              (err) => {
                if (nbExecute++ === 0) {
                  if (conn.opts.logger.error) conn.opts.logger.error(err);
                  reject(err);
                }
              },
              conn.opts,
              cmdParam,
              conn
            );
            conn.addCommand(cmd2, true);
            conn.addCommand(executeCommand, true);
            return;
          }
        }
        const cmd = new Prepare(
          (prepare) => {
            conn.executePromise(
              cmdParam,
              prepare,
              (res) => {
                resolve(res);
                prepare.close();
              },
              (err) => {
                if (conn.opts.logger.error) conn.opts.logger.error(err);
                reject(err);
                prepare.close();
              }
            );
          },
          (err) => {
            if (conn.opts.logger.error) conn.opts.logger.error(err);
            reject(err);
          },
          this.opts,
          cmdParam,
          conn
        );
        conn.addCommand(cmd, true);
      }
      importFile(cmdParam, resolve, reject) {
        const conn = this;
        if (!cmdParam || !cmdParam.file) {
          return reject(
            Errors.createError(
              "SQL file parameter is mandatory",
              Errors.ER_MISSING_SQL_PARAMETER,
              conn.info,
              "HY000",
              null,
              false,
              cmdParam.stack
            )
          );
        }
        const prevAddCommand = this.addCommand.bind(conn);
        this.waitingAuthenticationQueue = new Queue();
        this.addCommand = this.addCommandQueue;
        const tmpQuery = function(sql, resolve2, reject2) {
          const cmd = new Query(
            resolve2,
            (err) => {
              if (conn.opts.logger.error) conn.opts.logger.error(err);
              reject2(err);
            },
            conn.opts,
            {
              sql,
              opts: {}
            }
          );
          prevAddCommand(cmd, true);
        };
        let prevDatabase = null;
        return (cmdParam.skipDbCheck ? Promise.resolve() : new Promise(tmpQuery.bind(conn, "SELECT DATABASE() as db"))).then((res) => {
          prevDatabase = res ? res[0].db : null;
          if (cmdParam.skipDbCheck && !conn.opts.database || !cmdParam.skipDbCheck && !cmdParam.database && !prevDatabase) {
            return reject(
              Errors.createError(
                "Database parameter is not set and no database is selected",
                Errors.ER_MISSING_DATABASE_PARAMETER,
                conn.info,
                "HY000",
                null,
                false,
                cmdParam.stack
              )
            );
          }
          const searchDbPromise = cmdParam.database ? new Promise(tmpQuery.bind(conn, `USE \`${cmdParam.database.replace(/`/gi, "``")}\``)) : Promise.resolve();
          return searchDbPromise.then(() => {
            const endingFunction = () => {
              if (conn.status < Status.CLOSING) {
                conn.addCommand = conn.addCommandEnable.bind(conn);
                if (conn.status < Status.CLOSING && conn.opts.pipelining) {
                  conn.addCommand = conn.addCommandEnablePipeline.bind(conn);
                }
                const commands = conn.waitingAuthenticationQueue.toArray();
                commands.forEach((cmd) => conn.addCommand(cmd, true));
                conn.waitingAuthenticationQueue = null;
              }
            };
            return fsPromises.open(cmdParam.file, "r").then(async (fd) => {
              const buf = {
                buffer: Buffer.allocUnsafe(16384),
                offset: 0,
                end: 0
              };
              const queryPromises = [];
              let cmdError = null;
              while (!cmdError) {
                try {
                  const res2 = await fd.read(buf.buffer, buf.end, buf.buffer.length - buf.end, null);
                  if (res2.bytesRead === 0) {
                    fd.close().catch(() => {
                    });
                    if (cmdError) {
                      endingFunction();
                      reject(cmdError);
                      return;
                    }
                    await Promise.allSettled(queryPromises).then(() => {
                      if (!cmdParam.skipDbCheck && prevDatabase && cmdParam.database && cmdParam.database !== prevDatabase) {
                        return new Promise(tmpQuery.bind(conn, `USE \`${prevDatabase.replace(/`/gi, "``")}\``));
                      }
                      return Promise.resolve();
                    }).then(() => {
                      endingFunction();
                      if (cmdError) {
                        reject(cmdError);
                      } else {
                        resolve();
                      }
                    }).catch((err) => {
                      endingFunction();
                      reject(err);
                    });
                    return;
                  } else {
                    buf.end += res2.bytesRead;
                    const queries = Parse.parseQueries(buf);
                    const queryIntermediatePromise = queries.flatMap((element) => {
                      return new Promise(tmpQuery.bind(conn, element)).catch((err) => {
                        cmdError = err;
                      });
                    });
                    queryPromises.push(...queryIntermediatePromise);
                    if (buf.offset === buf.end) {
                      buf.offset = 0;
                      buf.end = 0;
                    } else {
                      if (buf.offset > 8192) {
                        buf.buffer.copy(buf.buffer, 0, buf.offset, buf.end);
                        buf.end -= buf.offset;
                        buf.offset = 0;
                      } else if (buf.buffer.length - buf.end < 8192) {
                        const tmpBuf = Buffer.allocUnsafe(buf.buffer.length << 1);
                        buf.buffer.copy(tmpBuf, 0, buf.offset, buf.end);
                        buf.buffer = tmpBuf;
                        buf.end -= buf.offset;
                        buf.offset = 0;
                      }
                    }
                  }
                } catch (e) {
                  fd.close().catch(() => {
                  });
                  endingFunction();
                  Promise.allSettled(queryPromises).catch(() => {
                  });
                  return reject(
                    Errors.createError(
                      e.message,
                      Errors.ER_SQL_FILE_ERROR,
                      conn.info,
                      "HY000",
                      null,
                      false,
                      cmdParam.stack
                    )
                  );
                }
              }
              if (cmdError) {
                endingFunction();
                reject(cmdError);
              }
            }).catch((err) => {
              endingFunction();
              if (err.code === "ENOENT") {
                return reject(
                  Errors.createError(
                    `SQL file parameter '${cmdParam.file}' doesn't exists`,
                    Errors.ER_MISSING_SQL_FILE,
                    conn.info,
                    "HY000",
                    null,
                    false,
                    cmdParam.stack
                  )
                );
              }
              return reject(
                Errors.createError(err.message, Errors.ER_SQL_FILE_ERROR, conn.info, "HY000", null, false, cmdParam.stack)
              );
            });
          });
        });
      }
      /**
       * Clearing connection variables when ending.
       *
       * @private
       */
      clear() {
        this.sendQueue.clear();
        this.opts.removeAllListeners();
        this.streamOut = void 0;
        this.socket = void 0;
      }
      /**
       * Redirecting connection to server indicated value.
       * @param value server host string
       * @param resolve promise result when done
       */
      redirect(value, resolve) {
        if (this.opts.permitRedirect && value) {
          if (this.receiveQueue.length <= 1 && (this.info.status & ServerStatus.STATUS_IN_TRANS) === 0) {
            this.info.redirectRequest = null;
            const matchResults = value.match(redirectUrlFormat);
            if (!matchResults) {
              if (this.opts.logger.error)
                this.opts.logger.error(
                  new Error(
                    `error parsing redirection string '${value}'. format must be 'mariadb/mysql://[<user>[:<password>]@]<host>[:<port>]/[<db>[?<opt1>=<value1>[&<opt2>=<value2>]]]'`
                  )
                );
              return resolve();
            }
            const options = {
              host: matchResults[7] ? decodeURIComponent(matchResults[7]) : matchResults[6],
              port: matchResults[9] ? parseInt(matchResults[9]) : 3306
            };
            if (options.host === this.opts.host && options.port === this.opts.port) {
              return resolve();
            }
            if (matchResults[3]) options.user = matchResults[3];
            if (matchResults[5]) options.password = matchResults[5];
            const redirectOpts = ConnectionOptions.parseOptionDataType(options);
            const finalRedirectOptions = new ConnOptions(Object.assign({}, this.opts, redirectOpts));
            const conn = new _Connection(finalRedirectOptions);
            conn.connect().then(
              (async function() {
                await new Promise(this.end.bind(this, {}));
                this.status = Status.CONNECTED;
                this.info = conn.info;
                this.opts = conn.opts;
                this.socket = conn.socket;
                if (this.prepareCache) this.prepareCache.reset();
                this.streamOut = conn.streamOut;
                this.streamIn = conn.streamIn;
                resolve();
              }).bind(this)
            ).catch(
              (function(e) {
                if (this.opts.logger.error) {
                  const err = new Error(`fail to redirect to '${value}'`);
                  err.cause = e;
                  this.opts.logger.error(err);
                }
                resolve();
              }).bind(this)
            );
          } else {
            this.info.redirectRequest = value;
            resolve();
          }
        } else {
          this.info.redirectRequest = null;
          resolve();
        }
      }
      get threadId() {
        return this.info ? this.info.threadId : null;
      }
      _sendNextCmdImmediate() {
        if (!this.sendQueue.isEmpty()) {
          setImmediate(this.nextSendCmd.bind(this));
        }
      }
      _closePrepare(prepareResultPacket) {
        this.addCommand(
          new ClosePrepare(
            {},
            () => {
            },
            () => {
            },
            prepareResultPacket
          ),
          false
        );
      }
      _logAndReject(reject, err) {
        if (this.opts.logger.error) this.opts.logger.error(err);
        reject(err);
      }
    };
    var _collation, _socket;
    var TestMethods = class {
      constructor(collation, socket) {
        __privateAdd(this, _collation);
        __privateAdd(this, _socket);
        __privateSet(this, _collation, collation);
        __privateSet(this, _socket, socket);
      }
      getCollation() {
        return __privateGet(this, _collation);
      }
      getSocket() {
        return __privateGet(this, _socket);
      }
    };
    _collation = new WeakMap();
    _socket = new WeakMap();
    module.exports = Connection;
  }
});

// node_modules/mariadb/lib/cmd/stream.js
var require_stream2 = __commonJS({
  "node_modules/mariadb/lib/cmd/stream.js"(exports, module) {
    "use strict";
    var Query = require_query();
    var { Readable } = require_stream();
    var Stream = class extends Query {
      constructor(cmdParam, connOpts, socket) {
        super(
          () => {
          },
          () => {
          },
          connOpts,
          cmdParam
        );
        this.socket = socket;
        this.inStream = new Readable({
          objectMode: true,
          read: () => {
            this.socket.resume();
          }
        });
        this.on("fields", function(meta) {
          this.inStream.emit("fields", meta);
        });
        this.on("error", function(err) {
          this.inStream.emit("error", err);
        });
        this.on("close", function(err) {
          this.inStream.emit("error", err);
        });
        this.on("end", function(err) {
          if (err) this.inStream.emit("error", err);
          this.socket.resume();
          this.inStream.push(null);
        });
        this.inStream.close = (function() {
          this.handleNewRows = () => {
          };
          this.socket.resume();
        }).bind(this);
      }
      handleNewRows(row) {
        if (!this.inStream.push(row)) {
          this.socket.pause();
        }
      }
    };
    module.exports = Stream;
  }
});

// node_modules/mariadb/lib/connection-promise.js
var require_connection_promise = __commonJS({
  "node_modules/mariadb/lib/connection-promise.js"(exports, module) {
    "use strict";
    var Stream = require_stream2();
    var Errors = require_errors();
    var _conn, _capture;
    var ConnectionPromise = class {
      constructor(conn) {
        __privateAdd(this, _conn);
        __privateAdd(this, _capture);
        __privateSet(this, _conn, conn);
        __privateSet(this, _capture, conn.opts.trace ? Error.captureStackTrace : () => {
        });
      }
      get threadId() {
        return __privateGet(this, _conn).threadId;
      }
      get info() {
        return __privateGet(this, _conn).info;
      }
      get prepareCache() {
        return __privateGet(this, _conn).prepareCache;
      }
      /**
       * Permit to change user during connection.
       * All user variables will be reset, Prepare commands will be released.
       * !!! mysql has a bug when CONNECT_ATTRS capability is set, that is default !!!!
       *
       * @param options   connection options
       * @returns {Promise} promise
       */
      changeUser(options) {
        const param = { opts: options };
        __privateGet(this, _capture).call(this, param);
        return new Promise(__privateGet(this, _conn).changeUser.bind(__privateGet(this, _conn), param));
      }
      /**
       * Start transaction
       *
       * @returns {Promise} promise
       */
      beginTransaction() {
        const param = { sql: "START TRANSACTION" };
        __privateGet(this, _capture).call(this, param);
        return new Promise(__privateGet(this, _conn).query.bind(__privateGet(this, _conn), param));
      }
      /**
       * Commit a transaction.
       *
       * @returns {Promise} command if commit was needed only
       */
      commit() {
        const param = { sql: "COMMIT" };
        __privateGet(this, _capture).call(this, param);
        return new Promise(__privateGet(this, _conn).changeTransaction.bind(__privateGet(this, _conn), param));
      }
      /**
       * Roll back a transaction.
       *
       * @returns {Promise} promise
       */
      rollback() {
        const param = { sql: "ROLLBACK" };
        __privateGet(this, _capture).call(this, param);
        return new Promise(__privateGet(this, _conn).changeTransaction.bind(__privateGet(this, _conn), param));
      }
      /**
       * Execute query using text protocol.
       *
       * @param sql     sql parameter Object can be used to supersede default option.
       *                Object must then have sql property.
       * @param values  object / array of placeholder values (not mandatory)
       * @returns {Promise} promise
       */
      query(sql, values) {
        const cmdParam = paramSetter(sql, values);
        __privateGet(this, _capture).call(this, cmdParam);
        return new Promise(__privateGet(this, _conn).query.bind(__privateGet(this, _conn), cmdParam));
      }
      /**
       * Execute a query returning a Readable Object that will emit columns/data/end/error events
       * to permit streaming big result-set
       *
       * @param sql     sql parameter Object can be used to supersede the default option.
       *                Object must then have `sql` property.
       * @param values  object / array of placeholder values (not mandatory)
       * @returns {Readable}
       */
      queryStream(sql, values) {
        const cmdParam = paramSetter(sql, values);
        __privateGet(this, _capture).call(this, cmdParam);
        const cmd = new Stream(cmdParam, __privateGet(this, _conn).opts, __privateGet(this, _conn).socket);
        if (__privateGet(this, _conn).opts.logger.error) cmd.on("error", __privateGet(this, _conn).opts.logger.error);
        __privateGet(this, _conn).addCommand(cmd, true);
        return cmd.inStream;
      }
      static _PARAM_DEF(sql, values) {
        if (typeof sql === "object") {
          return { sql: sql.sql, values: sql.values ? sql.values : values, opts: sql };
        } else return { sql, values };
      }
      execute(sql, values) {
        const cmdParam = paramSetter(sql, values);
        __privateGet(this, _capture).call(this, cmdParam);
        return new Promise(__privateGet(this, _conn).prepareExecute.bind(__privateGet(this, _conn), cmdParam));
      }
      static _EXECUTE_CMD(conn, cmdParam) {
        return conn.prepareExecute(cmdParam);
      }
      prepare(sql) {
        let param;
        if (typeof sql === "object") {
          param = { sql: sql.sql, opts: sql };
        } else {
          param = { sql };
        }
        __privateGet(this, _capture).call(this, param);
        return new Promise(__privateGet(this, _conn).prepare.bind(__privateGet(this, _conn), param));
      }
      /**
       * Execute batch using text protocol.
       *
       * @param sql     sql parameter Object can be used to supersede default option.
       *                Object must then have sql property.
       * @param values  object / array of placeholder values
       * @returns {Promise} promise
       */
      batch(sql, values) {
        const cmdParam = paramSetter(sql, values);
        __privateGet(this, _capture).call(this, cmdParam);
        return new Promise(__privateGet(this, _conn).batch.bind(__privateGet(this, _conn), cmdParam));
      }
      /**
       * Import sql file.
       *
       * @param opts JSON array with 2 possible fields: file and database
       */
      importFile(opts) {
        if (!opts || !opts.file) {
          return Promise.reject(
            Errors.createError(
              "SQL file parameter is mandatory",
              Errors.ER_MISSING_SQL_PARAMETER,
              __privateGet(this, _conn).info,
              "HY000",
              null,
              false,
              null
            )
          );
        }
        return new Promise(__privateGet(this, _conn).importFile.bind(__privateGet(this, _conn), { file: opts.file, database: opts.database }));
      }
      /**
       * Send an empty MySQL packet to ensure connection is active, and reset @@wait_timeout
       * @param timeout (optional) timeout value in ms. If reached, throw error and close connection
       * @returns {Promise} promise
       */
      ping(timeout) {
        const cmdParam = {
          opts: { timeout }
        };
        __privateGet(this, _capture).call(this, cmdParam);
        return new Promise(__privateGet(this, _conn).ping.bind(__privateGet(this, _conn), cmdParam));
      }
      /**
       * Send a reset command that will
       * - rollback any open transaction
       * - reset transaction isolation level
       * - reset session variables
       * - delete user variables
       * - remove temporary tables
       * - remove all PREPARE statement
       *
       * @returns {Promise} promise
       */
      reset() {
        const cmdParam = {};
        __privateGet(this, _capture).call(this, cmdParam);
        return new Promise(__privateGet(this, _conn).reset.bind(__privateGet(this, _conn), cmdParam));
      }
      /**
       * Indicates the state of the connection as the driver knows it
       * @returns {boolean}
       */
      isValid() {
        return __privateGet(this, _conn).isValid();
      }
      /**
       * Terminate connection gracefully.
       *
       * @returns {Promise} promise
       */
      end() {
        const cmdParam = {};
        __privateGet(this, _capture).call(this, cmdParam);
        return new Promise(__privateGet(this, _conn).end.bind(__privateGet(this, _conn), cmdParam));
      }
      /**
       * Alias for destroy.
       */
      close() {
        this.destroy();
      }
      /**
       * Force connection termination by closing the underlying socket and killing server process if any.
       */
      destroy() {
        __privateGet(this, _conn).destroy();
      }
      pause() {
        __privateGet(this, _conn).pause();
      }
      resume() {
        __privateGet(this, _conn).resume();
      }
      format(sql, values) {
        __privateGet(this, _conn).format(sql, values);
      }
      /**
       * return current connected server version information.
       *
       * @returns {*}
       */
      serverVersion() {
        return __privateGet(this, _conn).serverVersion();
      }
      /**
       * Change option "debug" during connection.
       * @param val   debug value
       */
      debug(val) {
        return __privateGet(this, _conn).debug(val);
      }
      debugCompress(val) {
        return __privateGet(this, _conn).debugCompress(val);
      }
      escape(val) {
        return __privateGet(this, _conn).escape(val);
      }
      escapeId(val) {
        return __privateGet(this, _conn).escapeId(val);
      }
      //*****************************************************************
      // EventEmitter proxy methods
      //*****************************************************************
      on(eventName, listener) {
        __privateGet(this, _conn).on.call(__privateGet(this, _conn), eventName, listener);
        return this;
      }
      off(eventName, listener) {
        __privateGet(this, _conn).off.call(__privateGet(this, _conn), eventName, listener);
        return this;
      }
      once(eventName, listener) {
        __privateGet(this, _conn).once.call(__privateGet(this, _conn), eventName, listener);
        return this;
      }
      listeners(eventName) {
        return __privateGet(this, _conn).listeners.call(__privateGet(this, _conn), eventName);
      }
      addListener(eventName, listener) {
        __privateGet(this, _conn).addListener.call(__privateGet(this, _conn), eventName, listener);
        return this;
      }
      eventNames() {
        return __privateGet(this, _conn).eventNames.call(__privateGet(this, _conn));
      }
      getMaxListeners() {
        return __privateGet(this, _conn).getMaxListeners.call(__privateGet(this, _conn));
      }
      listenerCount(eventName, listener) {
        return __privateGet(this, _conn).listenerCount.call(__privateGet(this, _conn), eventName, listener);
      }
      prependListener(eventName, listener) {
        __privateGet(this, _conn).prependListener.call(__privateGet(this, _conn), eventName, listener);
        return this;
      }
      prependOnceListener(eventName, listener) {
        __privateGet(this, _conn).prependOnceListener.call(__privateGet(this, _conn), eventName, listener);
        return this;
      }
      removeAllListeners(eventName, listener) {
        __privateGet(this, _conn).removeAllListeners.call(__privateGet(this, _conn), eventName, listener);
        return this;
      }
      removeListener(eventName, listener) {
        __privateGet(this, _conn).removeListener.call(__privateGet(this, _conn), eventName, listener);
        return this;
      }
      setMaxListeners(n) {
        __privateGet(this, _conn).setMaxListeners.call(__privateGet(this, _conn), n);
        return this;
      }
      rawListeners(eventName) {
        return __privateGet(this, _conn).rawListeners.call(__privateGet(this, _conn), eventName);
      }
      //*****************************************************************
      // internal public testing methods
      //*****************************************************************
      get __tests() {
        return __privateGet(this, _conn).__tests;
      }
    };
    _conn = new WeakMap();
    _capture = new WeakMap();
    var paramSetter = function(sql, values) {
      if (typeof sql === "object") {
        return { sql: sql.sql, values: sql.values ? sql.values : values, opts: sql };
      } else return { sql, values };
    };
    module.exports = ConnectionPromise;
    module.exports.paramSetter = paramSetter;
  }
});

// node_modules/mariadb/lib/pool.js
var require_pool = __commonJS({
  "node_modules/mariadb/lib/pool.js"(exports, module) {
    "use strict";
    var { EventEmitter } = require_events();
    var Queue = require_denque();
    var Errors = require_errors();
    var Utils = require_utils();
    var Connection = require_connection();
    var _closed, _connectionInCreation, _errorCreatingConnection, _idleConnections, _activeConnections, _requests, _unusedConnectionRemoverId, _requestTimeoutId, _connErrorNumber, _initialized;
    var Pool = class extends EventEmitter {
      constructor(options) {
        super();
        __publicField(this, "opts");
        __privateAdd(this, _closed, false);
        __privateAdd(this, _connectionInCreation, false);
        __privateAdd(this, _errorCreatingConnection, null);
        __privateAdd(this, _idleConnections);
        __privateAdd(this, _activeConnections, {});
        __privateAdd(this, _requests, new Queue());
        __privateAdd(this, _unusedConnectionRemoverId);
        __privateAdd(this, _requestTimeoutId);
        __privateAdd(this, _connErrorNumber, 0);
        __privateAdd(this, _initialized, false);
        __publicField(this, "_managePoolSizeTask");
        __publicField(this, "_connectionCreationTask");
        this.opts = options;
        __privateSet(this, _idleConnections, new Queue(null, { capacity: this.opts.connectionLimit }));
        this.on("_idle", this._processNextPendingRequest);
        this.on("validateSize", this._managePoolSize);
        this._managePoolSize();
      }
      //*****************************************************************
      // pool automatic handlers
      //*****************************************************************
      /**
       * Manages pool size by creating new connections when needed
       */
      _managePoolSize() {
        if (!this._shouldCreateMoreConnections() || this._managePoolSizeTask) {
          return;
        }
        __privateSet(this, _connectionInCreation, true);
        const timeoutEnd = Date.now() + this.opts.initializationTimeout;
        this._initiateConnectionCreation(timeoutEnd);
      }
      /**
       * Initiates connection creation with proper error handling
       * @param {number} timeoutEnd - When the connection attempt should time out
       */
      _initiateConnectionCreation(timeoutEnd) {
        this._createPoolConnection(
          // Success callback
          () => this._onConnectionCreationSuccess(),
          // Error callback
          (err) => this._onConnectionCreationError(err, timeoutEnd),
          timeoutEnd
        );
      }
      /**
       * Handles successful connection creation
       */
      _onConnectionCreationSuccess() {
        __privateSet(this, _initialized, true);
        __privateSet(this, _errorCreatingConnection, null);
        __privateSet(this, _connErrorNumber, 0);
        this._connectionCreationTask = null;
        if (this._shouldCreateMoreConnections()) {
          this.emit("validateSize");
        }
        this._startConnectionReaping();
      }
      /**
       * Handles errors during connection creation
       * @param {Error} err - The error that occurred
       * @param {number} timeoutEnd - When the connection attempt should time out
       */
      _onConnectionCreationError(err, timeoutEnd) {
        __privateSet(this, _connectionInCreation, false);
        if (__privateGet(this, _closed)) {
          return;
        }
        if (__privateGet(this, _errorCreatingConnection)) err = __privateGet(this, _errorCreatingConnection);
        let error;
        if (!__privateGet(this, _initialized)) {
          error = Errors.createError(
            `Error during pool initialization`,
            Errors.ER_POOL_NOT_INITIALIZED,
            null,
            null,
            null,
            false,
            null,
            null,
            err
          );
        } else {
          error = Errors.createError(
            `Pool fails to create connection`,
            Errors.ER_POOL_NO_CONNECTION,
            null,
            null,
            null,
            false,
            null,
            null,
            err
          );
        }
        const backoffTime = Math.min(++__privateWrapper(this, _connErrorNumber)._ * 200, 1e4);
        this._scheduleRetryWithBackoff(backoffTime);
        this.emit("error", error);
      }
      /**
       * Schedules the next connection creation attempt with backoff
       * @param {number} delay - Time to wait before next attempt
       */
      _scheduleRetryWithBackoff(delay) {
        if (__privateGet(this, _closed)) {
          return;
        }
        this._managePoolSizeTask = setTimeout(() => {
          this._managePoolSizeTask = null;
          if (!__privateGet(this, _requests).isEmpty()) {
            this._managePoolSize();
          }
        }, delay);
      }
      /**
       * Creates a new connection for the pool with proper error handling
       * @param {Function} onSuccess - Success callback
       * @param {Function} onError - Error callback
       * @param {number} timeoutEnd - Timestamp when connection attempt should time out
       */
      _createPoolConnection(onSuccess, onError, timeoutEnd) {
        const minTimeout = timeoutEnd - Date.now();
        const connectionOpts = Object.assign({}, this.opts.connOptions, {
          connectTimeout: Math.max(1, Math.min(minTimeout, this.opts.connOptions.connectTimeout || Number.MAX_SAFE_INTEGER))
        });
        const conn = new Connection(connectionOpts);
        this._connectionCreationTask = null;
        conn.connect().then((conn2) => this._prepareNewConnection(conn2, onSuccess, onError)).catch((err) => this._handleConnectionCreationError(err, onSuccess, onError, timeoutEnd));
      }
      /**
       * Sets up a newly created connection for use in the pool
       * @param {Connection} conn - The new connection
       * @param {Function} onSuccess - Success callback
       * @param {Function} onError - Error callback
       */
      _prepareNewConnection(conn, onSuccess, onError) {
        if (__privateGet(this, _closed)) {
          this._cleanupConnection(conn, "pool_closed");
          onError(
            new Errors.createFatalError(
              "Cannot create new connection to pool, pool closed",
              Errors.ER_ADD_CONNECTION_CLOSED_POOL
            )
          );
          return;
        }
        conn.lastUse = Date.now();
        conn.forceEnd = conn.end;
        conn.release = (callback) => this._handleRelease(conn, callback);
        conn.end = conn.release;
        this._overrideConnectionMethods(conn);
        this._setupConnectionErrorHandler(conn);
        __privateGet(this, _idleConnections).push(conn);
        __privateSet(this, _connectionInCreation, false);
        this.emit("_idle");
        this.emit("connection", conn);
        onSuccess(conn);
      }
      /**
       * Overrides connection methods for pool integration
       * @param {Connection} conn - The connection to modify
       */
      _overrideConnectionMethods(conn) {
        const nativeDestroy = conn.destroy.bind(conn);
        const pool = this;
        conn.destroy = function() {
          pool._endLeak(conn);
          delete __privateGet(pool, _activeConnections)[conn.threadId];
          nativeDestroy();
          pool.emit("validateSize");
        };
      }
      /**
       * Sets up error handler for a connection
       * @param {Connection} conn - The connection to set up
       */
      _setupConnectionErrorHandler(conn) {
        const pool = this;
        conn.once("error", () => {
          pool._endLeak(conn);
          delete __privateGet(pool, _activeConnections)[conn.threadId];
          pool._processIdleConnectionsOnError(conn);
          setImmediate(() => {
            if (!__privateGet(pool, _requests).isEmpty()) {
              pool._managePoolSize();
            }
          });
        });
      }
      /**
       * Processes idle connections when an error occurs
       * @param {Connection} errorConn - The connection that had an error
       */
      _processIdleConnectionsOnError(errorConn) {
        let idx = 0;
        while (idx < __privateGet(this, _idleConnections).length) {
          const currConn = __privateGet(this, _idleConnections).peekAt(idx);
          if (currConn === errorConn) {
            __privateGet(this, _idleConnections).removeOne(idx);
            continue;
          }
          currConn.lastUse = Math.min(currConn.lastUse, Date.now() - this.opts.minDelayValidation);
          idx++;
        }
      }
      /**
       * Handles errors during connection creation
       * @param {Error} err - The error that occurred
       * @param {Function} onSuccess - Success callback
       * @param {Function} onError - Error callback
       * @param {number} timeoutEnd - Timestamp when connection attempt should time out
       */
      _handleConnectionCreationError(err, onSuccess, onError, timeoutEnd) {
        if (err instanceof AggregateError) {
          err = err.errors[0];
        }
        if (!__privateGet(this, _errorCreatingConnection)) __privateSet(this, _errorCreatingConnection, err);
        const isFatalError = __privateGet(this, _closed) || err.errno && [1524, 1045, 1698].includes(err.errno) || timeoutEnd < Date.now();
        if (isFatalError) {
          err.message = err.message + this._errorMsgAddon();
          this._connectionCreationTask = null;
          onError(err);
          return;
        }
        this._connectionCreationTask = setTimeout(
          () => this._createPoolConnection(onSuccess, onError, timeoutEnd),
          Math.min(500, timeoutEnd - Date.now())
        );
      }
      /**
       * Checks for timed-out requests and rejects them
       */
      _checkRequestTimeouts() {
        __privateSet(this, _requestTimeoutId, null);
        const currentTime = Date.now();
        while (__privateGet(this, _requests).length > 0) {
          const request = __privateGet(this, _requests).peekFront();
          if (this._hasRequestTimedOut(request, currentTime)) {
            this._rejectTimedOutRequest(request, currentTime);
            continue;
          }
          this._scheduleNextTimeoutCheck(request, currentTime);
          return;
        }
      }
      /**
       * Checks if a request has timed out
       * @param {Request} request - The request to check
       * @param {number} currentTime - Current timestamp
       * @returns {boolean} - True if request has timed out
       */
      _hasRequestTimedOut(request, currentTime) {
        return request.timeout <= currentTime;
      }
      /**
       * Rejects a timed out request
       * @param {Request} request - The request to reject
       * @param {number} currentTime - Current timestamp
       */
      _rejectTimedOutRequest(request, currentTime) {
        __privateGet(this, _requests).shift();
        const timeoutCause = this.activeConnections() === 0 ? __privateGet(this, _errorCreatingConnection) : null;
        const waitTime = Math.abs(currentTime - (request.timeout - this.opts.acquireTimeout));
        const timeoutError = Errors.createError(
          `pool timeout: failed to retrieve a connection from pool after ${waitTime}ms${this._errorMsgAddon()}`,
          Errors.ER_GET_CONNECTION_TIMEOUT,
          null,
          "HY000",
          null,
          false,
          request.stack,
          null,
          timeoutCause
        );
        request.reject(timeoutError);
      }
      /**
       * Schedules the next timeout check
       * @param {Request} request - The next request in queue
       * @param {number} currentTime - Current timestamp
       */
      _scheduleNextTimeoutCheck(request, currentTime) {
        const timeUntilNextTimeout = request.timeout - currentTime;
        __privateSet(this, _requestTimeoutId, setTimeout(() => this._checkRequestTimeouts(), timeUntilNextTimeout));
      }
      _destroy(conn) {
        this._endLeak(conn);
        delete __privateGet(this, _activeConnections)[conn.threadId];
        conn.lastUse = Date.now();
        conn.forceEnd(
          null,
          () => {
          },
          () => {
          }
        );
        if (this.totalConnections() === 0) {
          this._stopConnectionReaping();
        }
        this.emit("validateSize");
      }
      release(conn) {
        if (!__privateGet(this, _activeConnections)[conn.threadId]) {
          return;
        }
        this._endLeak(conn);
        __privateGet(this, _activeConnections)[conn.threadId] = null;
        conn.lastUse = Date.now();
        if (__privateGet(this, _closed)) {
          this._cleanupConnection(conn, "pool_closed");
          return;
        }
        if (conn.isValid()) {
          this.emit("release", conn);
          __privateGet(this, _idleConnections).push(conn);
          process.nextTick(this.emit.bind(this, "_idle"));
        } else {
          this._cleanupConnection(conn, "validation_failed");
        }
      }
      _endLeak(conn) {
        if (conn.leakProcess) {
          clearTimeout(conn.leakProcess);
          conn.leakProcess = null;
          if (conn.leaked) {
            conn.opts.logger.warning(
              `Previous possible leak connection with thread ${conn.info.threadId} was returned to pool`
            );
          }
        }
      }
      /**
       * Permit to remove idle connection if unused for some time.
       */
      _startConnectionReaping() {
        if (!__privateGet(this, _unusedConnectionRemoverId) && this.opts.idleTimeout > 0) {
          __privateSet(this, _unusedConnectionRemoverId, setInterval(this._removeIdleConnections.bind(this), 500));
        }
      }
      _stopConnectionReaping() {
        if (__privateGet(this, _unusedConnectionRemoverId) && this.totalConnections() === 0) {
          clearInterval(__privateGet(this, _unusedConnectionRemoverId));
        }
      }
      /**
       * Removes idle connections that have been unused for too long
       */
      _removeIdleConnections() {
        const idleTimeRemoval = Date.now() - this.opts.idleTimeout * 1e3;
        let maxRemoval = Math.max(0, __privateGet(this, _idleConnections).length - this.opts.minimumIdle);
        while (maxRemoval > 0) {
          const conn = __privateGet(this, _idleConnections).peek();
          maxRemoval--;
          if (conn && conn.lastUse < idleTimeRemoval) {
            __privateGet(this, _idleConnections).shift();
            conn.forceEnd(
              null,
              () => {
              },
              () => {
              }
            );
            continue;
          }
          break;
        }
        if (this.totalConnections() === 0) {
          this._stopConnectionReaping();
        }
        this.emit("validateSize");
      }
      _shouldCreateMoreConnections() {
        return !__privateGet(this, _connectionInCreation) && __privateGet(this, _idleConnections).length < this.opts.minimumIdle && this.totalConnections() < this.opts.connectionLimit && !__privateGet(this, _closed);
      }
      /**
       * Processes the next request in the queue if connections are available
       */
      _processNextPendingRequest() {
        clearTimeout(__privateGet(this, _requestTimeoutId));
        __privateSet(this, _requestTimeoutId, null);
        const request = __privateGet(this, _requests).shift();
        if (!request) return;
        const conn = __privateGet(this, _idleConnections).shift();
        if (conn) {
          if (this.opts.leakDetectionTimeout > 0) {
            this._startLeakDetection(conn);
          }
          __privateGet(this, _activeConnections)[conn.threadId] = conn;
          this.emit("acquire", conn);
          request.resolver(conn);
        } else {
          __privateGet(this, _requests).unshift(request);
        }
        this._checkRequestTimeouts();
      }
      _hasIdleConnection() {
        return !__privateGet(this, _idleConnections).isEmpty();
      }
      /**
       * Acquires an idle connection from the pool
       * @param {Function} callback - Callback function(err, conn)
       */
      _acquireIdleConnection(callback) {
        if (!this._hasIdleConnection() || __privateGet(this, _closed)) {
          callback(new Error("No idle connections available"));
          return;
        }
        this._findValidIdleConnection(callback, false);
      }
      /**
       * Search info object of an existing connection. to know server type and version.
       * @returns information object if connection available.
       */
      _searchInfo() {
        let info = null;
        let conn = __privateGet(this, _idleConnections).get(0);
        if (!conn) {
          for (const threadId in Object.keys(__privateGet(this, _activeConnections))) {
            conn = __privateGet(this, _activeConnections)[threadId];
            if (!conn) {
              break;
            }
          }
        }
        if (conn) {
          info = conn.info;
        }
        return info;
      }
      /**
       * Recursively searches for a valid idle connection
       * @param {Function} callback - Callback function(err, conn)
       * @param {boolean} needPoolSizeCheck - Whether to check pool size after
       */
      _findValidIdleConnection(callback, needPoolSizeCheck) {
        if (__privateGet(this, _idleConnections).isEmpty()) {
          if (needPoolSizeCheck) {
            setImmediate(() => this.emit("validateSize"));
          }
          callback(new Error("No valid connections found"));
          return;
        }
        const conn = __privateGet(this, _idleConnections).shift();
        __privateGet(this, _activeConnections)[conn.threadId] = conn;
        this._validateConnectionHealth(conn, (isValid) => {
          if (isValid) {
            if (this.opts.leakDetectionTimeout > 0) {
              this._startLeakDetection(conn);
            }
            if (needPoolSizeCheck) {
              setImmediate(() => this.emit("validateSize"));
            }
            callback(null, conn);
            return;
          } else {
            delete __privateGet(this, _activeConnections)[conn.threadId];
          }
          this._findValidIdleConnection(callback, true);
        });
      }
      /**
       * Validates if a connection is healthy and can be used
       * @param {Connection} conn - The connection to validate
       * @param {Function} callback - Callback function(isValid)
       */
      _validateConnectionHealth(conn, callback) {
        if (!conn) {
          callback(false);
          return;
        }
        const recentlyUsed = this.opts.minDelayValidation > 0 && Date.now() - conn.lastUse <= this.opts.minDelayValidation;
        if (!conn.isValid() || recentlyUsed) {
          callback(conn.isValid());
          return;
        }
        const pingOptions = { opts: { timeout: this.opts.pingTimeout } };
        conn.ping(
          pingOptions,
          () => callback(true),
          () => callback(false)
        );
      }
      _leakedConnections() {
        let counter = 0;
        for (const connection of Object.values(__privateGet(this, _activeConnections))) {
          if (connection && connection.leaked) counter++;
        }
        return counter;
      }
      _errorMsgAddon() {
        if (this.opts.leakDetectionTimeout > 0) {
          return `
    (pool connections: active=${this.activeConnections()} idle=${this.idleConnections()} leak=${this._leakedConnections()} limit=${this.opts.connectionLimit})`;
        }
        return `
    (pool connections: active=${this.activeConnections()} idle=${this.idleConnections()} limit=${this.opts.connectionLimit})`;
      }
      toString() {
        return `active=${this.activeConnections()} idle=${this.idleConnections()} limit=${this.opts.connectionLimit}`;
      }
      //*****************************************************************
      // public methods
      //*****************************************************************
      get closed() {
        return __privateGet(this, _closed);
      }
      /**
       * Get current total connection number.
       * @return {number}
       */
      totalConnections() {
        return this.activeConnections() + this.idleConnections();
      }
      /**
       * Get current active connections.
       * @return {number}
       */
      activeConnections() {
        let counter = 0;
        for (const connection of Object.values(__privateGet(this, _activeConnections))) {
          if (connection) counter++;
        }
        return counter;
      }
      /**
       * Get current idle connection number.
       * @return {number}
       */
      idleConnections() {
        return __privateGet(this, _idleConnections).length;
      }
      /**
       * Get current stacked connection request.
       * @return {number}
       */
      taskQueueSize() {
        return __privateGet(this, _requests).length;
      }
      escape(value) {
        return Utils.escape(this.opts.connOptions, this._searchInfo(), value);
      }
      escapeId(value) {
        return Utils.escapeId(this.opts.connOptions, this._searchInfo(), value);
      }
      //*****************************************************************
      // promise methods
      //*****************************************************************
      /**
       * Retrieve a connection from the pool.
       * Create a new one if limit is not reached.
       * wait until acquireTimeout.
       * @param cmdParam for stackTrace error
       * @param {Function} callback - Callback function(err, conn)
       */
      getConnection(cmdParam, callback) {
        if (typeof cmdParam === "function") {
          callback = cmdParam;
          cmdParam = {};
        }
        if (__privateGet(this, _closed)) {
          const err = Errors.createError(
            "pool is closed",
            Errors.ER_POOL_ALREADY_CLOSED,
            null,
            "HY000",
            cmdParam === null ? null : cmdParam.sql,
            false,
            cmdParam.stack
          );
          callback(err);
          return;
        }
        this._acquireIdleConnection((err, conn) => {
          if (!err && conn) {
            this.emit("acquire", conn);
            callback(null, conn);
            return;
          }
          if (__privateGet(this, _closed)) {
            callback(
              Errors.createError(
                "Cannot add request to pool, pool is closed",
                Errors.ER_POOL_ALREADY_CLOSED,
                null,
                "HY000",
                cmdParam === null ? null : cmdParam.sql,
                false,
                cmdParam.stack
              )
            );
            return;
          }
          setImmediate(this.emit.bind(this, "validateSize"));
          setImmediate(this.emit.bind(this, "enqueue"));
          const request = new Request(
            Date.now() + this.opts.acquireTimeout,
            cmdParam.stack,
            (conn2) => callback(null, conn2),
            (err2) => callback(err2)
          );
          __privateGet(this, _requests).push(request);
          if (!__privateGet(this, _requestTimeoutId)) {
            __privateSet(this, _requestTimeoutId, setTimeout(this._checkRequestTimeouts.bind(this), this.opts.acquireTimeout));
          }
        });
      }
      /**
       * Close all connection in pool
       * Ends in multiple step :
       * - close idle connections
       * - ensure that no new request is possible
       *   (active connection release are automatically closed on release)
       * - if remaining, after 10 seconds, close remaining active connections
       *
       * @return Promise
       */
      end() {
        if (__privateGet(this, _closed)) {
          return Promise.reject(Errors.createError("pool is already closed", Errors.ER_POOL_ALREADY_CLOSED));
        }
        __privateSet(this, _closed, true);
        clearInterval(__privateGet(this, _unusedConnectionRemoverId));
        clearInterval(this._managePoolSizeTask);
        clearTimeout(this._connectionCreationTask);
        clearTimeout(__privateGet(this, _requestTimeoutId));
        const cmdParam = {};
        if (this.opts.trace) Error.captureStackTrace(cmdParam);
        const idleConnectionsEndings = [];
        let conn;
        while (conn = __privateGet(this, _idleConnections).shift()) {
          idleConnectionsEndings.push(new Promise(conn.forceEnd.bind(conn, cmdParam)));
        }
        clearTimeout(__privateGet(this, _requestTimeoutId));
        __privateSet(this, _requestTimeoutId, null);
        if (!__privateGet(this, _requests).isEmpty()) {
          const err = Errors.createError(
            "pool is ending, connection request aborted",
            Errors.ER_CLOSING_POOL,
            null,
            "HY000",
            null,
            false,
            cmdParam.stack
          );
          let task;
          while (task = __privateGet(this, _requests).shift()) {
            task.reject(err);
          }
        }
        const pool = this;
        return Promise.all(idleConnectionsEndings).then(async () => {
          if (pool.activeConnections() > 0) {
            let remaining = 100;
            while (remaining-- > 0) {
              if (pool.activeConnections() > 0) {
                await new Promise((res) => setTimeout(() => res(), 100));
              }
            }
            for (const connection of Object.values(__privateGet(pool, _activeConnections))) {
              if (connection) connection.destroy();
            }
          }
          return Promise.resolve();
        });
      }
      _cleanupConnection(conn, reason = "") {
        if (!conn) return;
        this._endLeak(conn);
        delete __privateGet(this, _activeConnections)[conn.threadId];
        try {
          const endingFct = conn.forceEnd ? conn.forceEnd : conn.end;
          endingFct.call(
            conn,
            null,
            () => this.emit("connectionClosed", { threadId: conn.threadId, reason }),
            () => {
            }
          );
        } catch (err) {
          this.emit("error", new Error(`Failed to cleanup connection: ${err.message}`));
        }
        if (this.totalConnections() === 0) {
          this._stopConnectionReaping();
        }
        this.emit("validateSize");
      }
      /**
       * Handles the release of a connection back to the pool
       * @param {Connection} conn - The connection to release
       * @param {Function} callback - Callback function when complete
       */
      _handleRelease(conn, callback) {
        callback = callback || function() {
        };
        if (__privateGet(this, _closed) || !conn.isValid()) {
          this._destroy(conn);
          callback();
          return;
        }
        if (this.opts.noControlAfterUse) {
          this.release(conn);
          callback();
          return;
        }
        const resetFunction = this._getRevertFunction(conn);
        resetFunction((err) => {
          if (err) {
            this._destroy(conn);
          } else {
            this.release(conn);
          }
          callback();
        });
      }
      /**
       * Get the appropriate function to reset connection state
       * @returns {Function} Function that takes a callback
       */
      _getRevertFunction(conn) {
        const canUseReset = this.opts.resetAfterUse && conn.info.isMariaDB() && (conn.info.serverVersion.minor === 2 && conn.info.hasMinVersion(10, 2, 22) || conn.info.hasMinVersion(10, 3, 13));
        return canUseReset ? (callback) => conn.reset({}, callback) : (callback) => conn.changeTransaction(
          { sql: "ROLLBACK" },
          () => callback(null),
          (err) => callback(err)
        );
      }
      /**
       * Sets up leak detection for a connection
       * @param {Connection} conn - The connection to monitor
       */
      _startLeakDetection(conn) {
        conn.lastUse = Date.now();
        conn.leaked = false;
        conn.leakProcess = setTimeout(
          () => {
            conn.leaked = true;
            const unusedTime = Date.now() - conn.lastUse;
            conn.opts.logger.warning(
              `A possible connection leak on thread ${conn.info.threadId} (connection not returned to pool for ${unusedTime}ms). Has connection.release() been called?${this._errorMsgAddon()}`
            );
          },
          this.opts.leakDetectionTimeout,
          conn
        );
      }
    };
    _closed = new WeakMap();
    _connectionInCreation = new WeakMap();
    _errorCreatingConnection = new WeakMap();
    _idleConnections = new WeakMap();
    _activeConnections = new WeakMap();
    _requests = new WeakMap();
    _unusedConnectionRemoverId = new WeakMap();
    _requestTimeoutId = new WeakMap();
    _connErrorNumber = new WeakMap();
    _initialized = new WeakMap();
    var Request = class {
      constructor(timeout, stack, resolver, rejecter) {
        this.timeout = timeout;
        this.stack = stack;
        this.resolver = resolver;
        this.rejecter = rejecter;
      }
      reject(err) {
        process.nextTick(this.rejecter, err);
      }
    };
    module.exports = Pool;
  }
});

// node_modules/mariadb/lib/pool-promise.js
var require_pool_promise = __commonJS({
  "node_modules/mariadb/lib/pool-promise.js"(exports, module) {
    "use strict";
    var { EventEmitter } = require_events();
    var Pool = require_pool();
    var ConnectionPromise = require_connection_promise();
    var Errors = require_errors();
    var _pool;
    var PoolPromise = class extends EventEmitter {
      constructor(options) {
        super();
        __privateAdd(this, _pool);
        __privateSet(this, _pool, new Pool(options));
        __privateGet(this, _pool).on("acquire", this.emit.bind(this, "acquire"));
        __privateGet(this, _pool).on("connection", this.emit.bind(this, "connection"));
        __privateGet(this, _pool).on("enqueue", this.emit.bind(this, "enqueue"));
        __privateGet(this, _pool).on("release", this.emit.bind(this, "release"));
        __privateGet(this, _pool).on("error", this.emit.bind(this, "error"));
      }
      get closed() {
        return __privateGet(this, _pool).closed;
      }
      /**
       * Get current total connection number.
       * @return {number}
       */
      totalConnections() {
        return __privateGet(this, _pool).totalConnections();
      }
      /**
       * Get current active connections.
       * @return {number}
       */
      activeConnections() {
        return __privateGet(this, _pool).activeConnections();
      }
      /**
       * Get current idle connection number.
       * @return {number}
       */
      idleConnections() {
        return __privateGet(this, _pool).idleConnections();
      }
      /**
       * Get current stacked connection request.
       * @return {number}
       */
      taskQueueSize() {
        return __privateGet(this, _pool).taskQueueSize();
      }
      escape(value) {
        return __privateGet(this, _pool).escape(value);
      }
      escapeId(value) {
        return __privateGet(this, _pool).escapeId(value);
      }
      /**
       * Ends pool
       *
       * @return Promise
       **/
      end() {
        return __privateGet(this, _pool).end();
      }
      /**
       * Retrieve a connection from pool.
       * Create a new one, if limit is not reached.
       * wait until acquireTimeout.
       *
       */
      async getConnection() {
        const cmdParam = {};
        if (__privateGet(this, _pool).opts.connOptions.trace) Error.captureStackTrace(cmdParam);
        return new Promise((resolve, reject) => {
          __privateGet(this, _pool).getConnection(cmdParam, (err, baseConn) => {
            if (err) {
              reject(err);
            } else {
              const conn = new ConnectionPromise(baseConn);
              conn.release = () => new Promise(baseConn.release);
              conn.end = conn.release;
              conn.close = conn.release;
              resolve(conn);
            }
          });
        });
      }
      /**
       * Execute query using text protocol with callback emit columns/data/end/error
       * events to permit streaming big result-set
       *
       * @param sql     sql parameter Object can be used to supersede default option.
       *                Object must then have sql property.
       * @param values  object / array of placeholder values (not mandatory)
       */
      query(sql, values) {
        const cmdParam = ConnectionPromise.paramSetter(sql, values);
        if (__privateGet(this, _pool).opts.connOptions.trace) Error.captureStackTrace(cmdParam);
        return new Promise((resolve, reject) => {
          return __privateGet(this, _pool).getConnection(cmdParam, (err, baseConn) => {
            if (err) {
              reject(err);
            } else {
              baseConn.query(
                cmdParam,
                (res) => {
                  __privateGet(this, _pool).release(baseConn);
                  resolve(res);
                },
                (err2) => {
                  __privateGet(this, _pool).release(baseConn);
                  reject(err2);
                }
              );
            }
          });
        });
      }
      /**
       * Execute query using binary protocol with callback emit columns/data/end/error
       * events to permit streaming big result-set
       *
       * @param sql     sql parameter Object can be used to supersede default option.
       *                Object must then have sql property.
       * @param values  object / array of placeholder values (not mandatory)
       */
      execute(sql, values) {
        const cmdParam = ConnectionPromise.paramSetter(sql, values);
        if (__privateGet(this, _pool).opts.connOptions.trace) Error.captureStackTrace(cmdParam);
        return new Promise((resolve, reject) => {
          return __privateGet(this, _pool).getConnection(cmdParam, (err, baseConn) => {
            if (err) {
              reject(err);
            } else {
              baseConn.prepareExecute(
                cmdParam,
                (res) => {
                  __privateGet(this, _pool).release(baseConn);
                  resolve(res);
                },
                (err2) => {
                  __privateGet(this, _pool).release(baseConn);
                  reject(err2);
                }
              );
            }
          });
        });
      }
      /**
       * execute a batch
       *
       * @param sql     sql parameter Object can be used to supersede default option.
       *                Object must then have sql property.
       * @param values  array of placeholder values
       */
      batch(sql, values) {
        const cmdParam = ConnectionPromise.paramSetter(sql, values);
        if (__privateGet(this, _pool).opts.connOptions.trace) Error.captureStackTrace(cmdParam);
        return new Promise((resolve, reject) => {
          return __privateGet(this, _pool).getConnection(cmdParam, (err, baseConn) => {
            if (err) {
              reject(err);
            } else {
              baseConn.batch(
                cmdParam,
                (res) => {
                  __privateGet(this, _pool).release(baseConn);
                  resolve(res);
                },
                (err2) => {
                  __privateGet(this, _pool).release(baseConn);
                  reject(err2);
                }
              );
            }
          });
        });
      }
      /**
       * Import sql file.
       *
       * @param opts JSON array with 2 possible fields: file and database
       */
      importFile(opts) {
        if (!opts) {
          return Promise.reject(
            Errors.createError(
              "SQL file parameter is mandatory",
              Errors.ER_MISSING_SQL_PARAMETER,
              null,
              "HY000",
              null,
              false,
              null
            )
          );
        }
        return new Promise((resolve, reject) => {
          return __privateGet(this, _pool).getConnection({}, (err, baseConn) => {
            if (err) {
              reject(err);
            } else {
              baseConn.importFile(
                { file: opts.file, database: opts.database },
                (res) => {
                  __privateGet(this, _pool).release(baseConn);
                  resolve(res);
                },
                (err2) => {
                  __privateGet(this, _pool).release(baseConn);
                  reject(err2);
                }
              );
            }
          });
        });
      }
      toString() {
        return "poolPromise(" + __privateGet(this, _pool).toString() + ")";
      }
    };
    _pool = new WeakMap();
    module.exports = PoolPromise;
  }
});

// node_modules/mariadb/lib/config/cluster-options.js
var require_cluster_options = __commonJS({
  "node_modules/mariadb/lib/config/cluster-options.js"(exports, module) {
    "use strict";
    var ClusterOptions = class {
      constructor(opts) {
        if (opts) {
          this.canRetry = opts.canRetry === void 0 ? true : Boolean(opts.canRetry);
          this.removeNodeErrorCount = opts.removeNodeErrorCount === void 0 ? Number.POSITIVE_INFINITY : Number(opts.removeNodeErrorCount);
          this.restoreNodeTimeout = opts.restoreNodeTimeout === void 0 ? 1e3 : Number(opts.restoreNodeTimeout);
          this.defaultSelector = opts.defaultSelector || "RR";
        } else {
          this.canRetry = true;
          this.removeNodeErrorCount = Number.POSITIVE_INFINITY;
          this.restoreNodeTimeout = 1e3;
          this.defaultSelector = "RR";
        }
      }
    };
    module.exports = ClusterOptions;
  }
});

// node_modules/mariadb/lib/config/pool-options.js
var require_pool_options = __commonJS({
  "node_modules/mariadb/lib/config/pool-options.js"(exports, module) {
    "use strict";
    var ConnOptions = require_connection_options();
    var PoolOptions = class {
      constructor(opts) {
        if (typeof opts === "string") {
          opts = ConnOptions.parse(opts);
          if (opts.acquireTimeout) opts.acquireTimeout = parseInt(opts.acquireTimeout);
          if (opts.connectionLimit) opts.connectionLimit = parseInt(opts.connectionLimit);
          if (opts.idleTimeout) opts.idleTimeout = parseInt(opts.idleTimeout);
          if (opts.leakDetectionTimeout) opts.leakDetectionTimeout = parseInt(opts.leakDetectionTimeout);
          if (opts.initializationTimeout) opts.initializationTimeout = parseInt(opts.initializationTimeout);
          if (opts.minDelayValidation) opts.minDelayValidation = parseInt(opts.minDelayValidation);
          if (opts.minimumIdle) opts.minimumIdle = parseInt(opts.minimumIdle);
          if (opts.noControlAfterUse) opts.noControlAfterUse = opts.noControlAfterUse === "true";
          if (opts.resetAfterUse) opts.resetAfterUse = opts.resetAfterUse === "true";
          if (opts.pingTimeout) opts.pingTimeout = parseInt(opts.pingTimeout);
        }
        this.acquireTimeout = opts.acquireTimeout === void 0 ? 1e4 : Number(opts.acquireTimeout);
        this.connectionLimit = opts.connectionLimit === void 0 ? 10 : Number(opts.connectionLimit);
        this.idleTimeout = opts.idleTimeout === void 0 ? 1800 : Number(opts.idleTimeout);
        this.leakDetectionTimeout = Number(opts.leakDetectionTimeout) || 0;
        this.initializationTimeout = opts.initializationTimeout === void 0 ? Math.max(100, this.acquireTimeout - 100) : Number(opts.initializationTimeout);
        this.minDelayValidation = opts.minDelayValidation === void 0 ? 500 : Number(opts.minDelayValidation);
        this.minimumIdle = opts.minimumIdle === void 0 ? this.connectionLimit : Math.min(Number(opts.minimumIdle), this.connectionLimit);
        this.noControlAfterUse = Boolean(opts.noControlAfterUse) || false;
        this.resetAfterUse = Boolean(opts.resetAfterUse) || false;
        this.pingTimeout = Number(opts.pingTimeout) || 250;
        this.connOptions = new ConnOptions(opts);
        if (this.acquireTimeout > 0 && this.connOptions.connectTimeout > this.acquireTimeout) {
          this.connOptions.connectTimeout = this.acquireTimeout;
        }
      }
    };
    module.exports = PoolOptions;
  }
});

// node_modules/mariadb/lib/connection-callback.js
var require_connection_callback = __commonJS({
  "node_modules/mariadb/lib/connection-callback.js"(exports, module) {
    "use strict";
    var Errors = require_errors();
    var { Status } = require_connection_status();
    var Query = require_query();
    var _conn, _noop;
    var _ConnectionCallback = class _ConnectionCallback {
      constructor(conn) {
        __privateAdd(this, _conn);
        __privateAdd(this, _noop, () => {
        });
        __publicField(this, "release", (cb) => {
          __privateGet(this, _conn).release(() => {
            if (cb) cb();
          });
        });
        __privateSet(this, _conn, conn);
      }
      get threadId() {
        return __privateGet(this, _conn).info ? __privateGet(this, _conn).info.threadId : null;
      }
      get info() {
        return __privateGet(this, _conn).info;
      }
      /**
       * Permit changing user during connection.
       * All user variables will be reset, Prepare commands will be released.
       * !!! mysql has a bug when CONNECT_ATTRS capability is set, that is default !!!!
       *
       * @param options   connection options
       * @param callback  callback function
       */
      changeUser(options, callback) {
        let _options, _cb;
        if (typeof options === "function") {
          _cb = options;
          _options = void 0;
        } else {
          _options = options;
          _cb = callback;
        }
        const cmdParam = {
          opts: _options,
          callback: _cb
        };
        if (__privateGet(this, _conn).opts.trace) Error.captureStackTrace(cmdParam);
        new Promise(__privateGet(this, _conn).changeUser.bind(__privateGet(this, _conn), cmdParam)).then(() => {
          if (cmdParam.callback) cmdParam.callback(null, null, null);
        }).catch(cmdParam.callback || __privateGet(this, _noop));
      }
      /**
       * Start transaction
       *
       * @param callback  callback function
       */
      beginTransaction(callback) {
        this.query("START TRANSACTION", null, callback);
      }
      /**
       * Commit a transaction.
       *
       * @param callback  callback function
       */
      commit(callback) {
        __privateGet(this, _conn).changeTransaction(
          { sql: "COMMIT" },
          () => {
            if (callback) callback(null, null, null);
          },
          callback || __privateGet(this, _noop)
        );
      }
      /**
       * Roll back a transaction.
       *
       * @param callback  callback function
       */
      rollback(callback) {
        __privateGet(this, _conn).changeTransaction(
          { sql: "ROLLBACK" },
          () => {
            if (callback) callback(null, null, null);
          },
          callback || __privateGet(this, _noop)
        );
      }
      /**
       * Execute query using text protocol with callback emit columns/data/end/error
       * events to permit streaming big result-set
       *
       * @param sql     sql parameter Object can be used to supersede default option.
       *                Object must then have sql property.
       * @param values  object / array of placeholder values (not mandatory)
       * @param callback  callback function
       */
      query(sql, values, callback) {
        const cmdParam = _ConnectionCallback._PARAM(__privateGet(this, _conn).opts, sql, values, callback);
        return _ConnectionCallback._QUERY_CMD(__privateGet(this, _conn), cmdParam);
      }
      /**
       * Execute a query returning a Readable Object that will emit columns/data/end/error events
       * to permit streaming big result-set
       *
       * @param sql     sql parameter Object can be used to supersede the default option.
       *                Object must then have `sql` property.
       * @param values  object / array of placeholder values (not mandatory)
       * @returns {Readable}
       */
      queryStream(sql, values) {
        const cmdParam = _ConnectionCallback._PARAM(__privateGet(this, _conn).opts, sql, values);
        const cmd = _ConnectionCallback._QUERY_CMD(__privateGet(this, _conn), cmdParam);
        return cmd.stream();
      }
      static _QUERY_CMD(conn, cmdParam) {
        let cmd;
        if (cmdParam.callback) {
          cmdParam.opts = cmdParam.opts ? Object.assign(cmdParam.opts, { metaAsArray: true }) : { metaAsArray: true };
          cmd = new Query(
            ([rows, meta]) => {
              cmdParam.callback(null, rows, meta);
            },
            cmdParam.callback,
            conn.opts,
            cmdParam
          );
        } else {
          cmd = new Query(
            () => {
            },
            () => {
            },
            conn.opts,
            cmdParam
          );
        }
        cmd.handleNewRows = (row) => {
          cmd._rows[cmd._responseIndex].push(row);
          cmd.emit("data", row);
        };
        conn.addCommand(cmd, true);
        cmd.stream = (opt) => cmd._stream(conn.socket, opt);
        return cmd;
      }
      execute(sql, values, callback) {
        const cmdParam = _ConnectionCallback._PARAM(__privateGet(this, _conn).opts, sql, values, callback);
        cmdParam.opts = cmdParam.opts ? Object.assign(cmdParam.opts, { metaAsArray: true }) : { metaAsArray: true };
        __privateGet(this, _conn).prepareExecute(
          cmdParam,
          ([rows, meta]) => {
            if (cmdParam.callback) {
              cmdParam.callback(null, rows, meta);
            }
          },
          (err) => {
            if (cmdParam.callback) {
              cmdParam.callback(err);
            }
          }
        );
      }
      static _PARAM(options, sql, values, callback) {
        let _cmdOpt, _sql, _values = values, _cb = callback;
        if (typeof values === "function") {
          _cb = values;
          _values = void 0;
        }
        if (typeof sql === "object") {
          _cmdOpt = sql;
          _sql = _cmdOpt.sql;
          if (_cmdOpt.values) _values = _cmdOpt.values;
        } else {
          _sql = sql;
        }
        const cmdParam = {
          sql: _sql,
          values: _values,
          opts: _cmdOpt,
          callback: _cb
        };
        if (options.trace) Error.captureStackTrace(cmdParam, _ConnectionCallback._PARAM);
        return cmdParam;
      }
      static _EXECUTE_CMD(conn, cmdParam) {
        new Promise(conn.prepare.bind(conn, cmdParam)).then((prepare) => {
          const opts = cmdParam.opts ? Object.assign(cmdParam.opts, { metaAsArray: true }) : { metaAsArray: true };
          return prepare.execute(cmdParam.values, opts, null, cmdParam.stack).then(([rows, meta]) => {
            if (cmdParam.callback) {
              cmdParam.callback(null, rows, meta);
            }
          }).finally(() => prepare.close());
        }).catch((err) => {
          if (conn.opts.logger.error) conn.opts.logger.error(err);
          if (cmdParam.callback) cmdParam.callback(err);
        });
      }
      prepare(sql, callback) {
        let _cmdOpt, _sql;
        if (typeof sql === "object") {
          _cmdOpt = sql;
          _sql = _cmdOpt.sql;
        } else {
          _sql = sql;
        }
        const cmdParam = {
          sql: _sql,
          opts: _cmdOpt,
          callback
        };
        if (__privateGet(this, _conn).opts.trace) Error.captureStackTrace(cmdParam);
        return new Promise(__privateGet(this, _conn).prepare.bind(__privateGet(this, _conn), cmdParam)).then((prepare) => {
          if (callback) callback(null, prepare, null);
        }).catch(callback || __privateGet(this, _noop));
      }
      /**
       * Execute a batch
       * events to permit streaming big result-set
       *
       * @param sql     sql parameter Object can be used to supersede the default options.
       *                Object must then have `sql` property.
       * @param values  object / array of placeholder values (not mandatory)
       * @param callback callback
       */
      batch(sql, values, callback) {
        const cmdParam = _ConnectionCallback._PARAM(__privateGet(this, _conn).opts, sql, values, callback);
        __privateGet(this, _conn).batch(
          cmdParam,
          (res) => {
            if (cmdParam.callback) cmdParam.callback(null, res);
          },
          (err) => {
            if (cmdParam.callback) cmdParam.callback(err);
          }
        );
      }
      /**
       * Import sql file.
       *
       * @param opts JSON array with 2 possible fields: file and database
       * @param cb callback
       */
      importFile(opts, cb) {
        if (!opts || !opts.file) {
          if (cb)
            cb(
              Errors.createError(
                "SQL file parameter is mandatory",
                Errors.ER_MISSING_SQL_PARAMETER,
                __privateGet(this, _conn).info,
                "HY000",
                null,
                false,
                null
              )
            );
          return;
        }
        new Promise(__privateGet(this, _conn).importFile.bind(__privateGet(this, _conn), { file: opts.file, database: opts.database })).then(() => {
          if (cb) cb();
        }).catch((err) => {
          if (cb) cb(err);
        });
      }
      /**
       * Send an empty MySQL packet to ensure connection is active, and reset @@wait_timeout
       * @param timeout (optional) timeout value in ms. If reached, throw error and close connection
       * @param callback callback
       */
      ping(timeout, callback) {
        let _cmdOpt = {}, _cb;
        if (typeof timeout === "function") {
          _cb = timeout;
        } else {
          _cmdOpt.timeout = timeout;
          _cb = callback;
        }
        const cmdParam = {
          opts: _cmdOpt,
          callback: _cb
        };
        if (__privateGet(this, _conn).opts.trace) Error.captureStackTrace(cmdParam);
        new Promise(__privateGet(this, _conn).ping.bind(__privateGet(this, _conn), cmdParam)).then(_cb || __privateGet(this, _noop)).catch(_cb || __privateGet(this, _noop));
      }
      /**
       * Send a reset command that will
       * - rollback any open transaction
       * - reset transaction isolation level
       * - reset session variables
       * - delete user variables
       * - remove temporary tables
       * - remove all PREPARE statement
       *
       * @param callback callback
       */
      reset(callback) {
        const cmdParam = {};
        if (__privateGet(this, _conn).opts.trace) Error.captureStackTrace(cmdParam);
        return new Promise(__privateGet(this, _conn).reset.bind(__privateGet(this, _conn), cmdParam)).then(callback || __privateGet(this, _noop)).catch(callback || __privateGet(this, _noop));
      }
      /**
       * Indicates the state of the connection as the driver knows it
       * @returns {boolean}
       */
      isValid() {
        return __privateGet(this, _conn).isValid();
      }
      /**
       * Terminate connection gracefully.
       *
       * @param callback callback
       */
      end(callback) {
        const cmdParam = {};
        if (__privateGet(this, _conn).opts.trace) Error.captureStackTrace(cmdParam);
        new Promise(__privateGet(this, _conn).end.bind(__privateGet(this, _conn), cmdParam)).then(() => {
          if (callback) callback();
        }).catch(callback || __privateGet(this, _noop));
      }
      /**
       * Alias for destroy.
       */
      close() {
        this.destroy();
      }
      /**
       * Force connection termination by closing the underlying socket and killing server process if any.
       */
      destroy() {
        __privateGet(this, _conn).destroy();
      }
      pause() {
        __privateGet(this, _conn).pause();
      }
      resume() {
        __privateGet(this, _conn).resume();
      }
      format(sql, values) {
        __privateGet(this, _conn).format(sql, values);
      }
      /**
       * return current connected server version information.
       *
       * @returns {*}
       */
      serverVersion() {
        return __privateGet(this, _conn).serverVersion();
      }
      /**
       * Change option "debug" during connection.
       * @param val   debug value
       */
      debug(val) {
        return __privateGet(this, _conn).debug(val);
      }
      debugCompress(val) {
        return __privateGet(this, _conn).debugCompress(val);
      }
      escape(val) {
        return __privateGet(this, _conn).escape(val);
      }
      escapeId(val) {
        return __privateGet(this, _conn).escapeId(val);
      }
      //*****************************************************************
      // internal public testing methods
      //*****************************************************************
      get __tests() {
        return __privateGet(this, _conn).__tests;
      }
      connect(callback) {
        if (!callback) {
          throw new Errors.createError(
            "missing mandatory callback parameter",
            Errors.ER_MISSING_PARAMETER,
            __privateGet(this, _conn).info
          );
        }
        switch (__privateGet(this, _conn).status) {
          case Status.NOT_CONNECTED:
          case Status.CONNECTING:
          case Status.AUTHENTICATING:
          case Status.INIT_CMD:
            this.once("connect", callback);
            break;
          case Status.CONNECTED:
            callback.call(this);
            break;
          case Status.CLOSING:
          case Status.CLOSED:
            callback.call(
              this,
              Errors.createError(
                "Connection closed",
                Errors.ER_CONNECTION_ALREADY_CLOSED,
                __privateGet(this, _conn).info,
                "08S01",
                null,
                true
              )
            );
            break;
        }
      }
      //*****************************************************************
      // EventEmitter proxy methods
      //*****************************************************************
      on(eventName, listener) {
        __privateGet(this, _conn).on.call(__privateGet(this, _conn), eventName, listener);
        return this;
      }
      off(eventName, listener) {
        __privateGet(this, _conn).off.call(__privateGet(this, _conn), eventName, listener);
        return this;
      }
      once(eventName, listener) {
        __privateGet(this, _conn).once.call(__privateGet(this, _conn), eventName, listener);
        return this;
      }
      listeners(eventName) {
        return __privateGet(this, _conn).listeners.call(__privateGet(this, _conn), eventName);
      }
      addListener(eventName, listener) {
        __privateGet(this, _conn).addListener.call(__privateGet(this, _conn), eventName, listener);
        return this;
      }
      eventNames() {
        return __privateGet(this, _conn).eventNames.call(__privateGet(this, _conn));
      }
      getMaxListeners() {
        return __privateGet(this, _conn).getMaxListeners.call(__privateGet(this, _conn));
      }
      listenerCount(eventName, listener) {
        return __privateGet(this, _conn).listenerCount.call(__privateGet(this, _conn), eventName, listener);
      }
      prependListener(eventName, listener) {
        __privateGet(this, _conn).prependListener.call(__privateGet(this, _conn), eventName, listener);
        return this;
      }
      prependOnceListener(eventName, listener) {
        __privateGet(this, _conn).prependOnceListener.call(__privateGet(this, _conn), eventName, listener);
        return this;
      }
      removeAllListeners(eventName, listener) {
        __privateGet(this, _conn).removeAllListeners.call(__privateGet(this, _conn), eventName, listener);
        return this;
      }
      removeListener(eventName, listener) {
        __privateGet(this, _conn).removeListener.call(__privateGet(this, _conn), eventName, listener);
        return this;
      }
      setMaxListeners(n) {
        __privateGet(this, _conn).setMaxListeners.call(__privateGet(this, _conn), n);
        return this;
      }
      rawListeners(eventName) {
        return __privateGet(this, _conn).rawListeners.call(__privateGet(this, _conn), eventName);
      }
    };
    _conn = new WeakMap();
    _noop = new WeakMap();
    var ConnectionCallback = _ConnectionCallback;
    module.exports = ConnectionCallback;
  }
});

// node_modules/mariadb/lib/pool-callback.js
var require_pool_callback = __commonJS({
  "node_modules/mariadb/lib/pool-callback.js"(exports, module) {
    "use strict";
    var { EventEmitter } = require_events();
    var Pool = require_pool();
    var Errors = require_errors();
    var ConnectionCallback = require_connection_callback();
    var _pool, _noop;
    var PoolCallback = class extends EventEmitter {
      constructor(options) {
        super();
        __privateAdd(this, _pool);
        __privateAdd(this, _noop, () => {
        });
        __privateSet(this, _pool, new Pool(options));
        __privateGet(this, _pool).on("acquire", this.emit.bind(this, "acquire"));
        __privateGet(this, _pool).on("connection", this.emit.bind(this, "connection"));
        __privateGet(this, _pool).on("enqueue", this.emit.bind(this, "enqueue"));
        __privateGet(this, _pool).on("release", this.emit.bind(this, "release"));
        __privateGet(this, _pool).on("error", this.emit.bind(this, "error"));
      }
      get closed() {
        return __privateGet(this, _pool).closed;
      }
      /**
       * Get current total connection number.
       * @return {number}
       */
      totalConnections() {
        return __privateGet(this, _pool).totalConnections();
      }
      /**
       * Get current active connections.
       * @return {number}
       */
      activeConnections() {
        return __privateGet(this, _pool).activeConnections();
      }
      /**
       * Get current idle connection number.
       * @return {number}
       */
      idleConnections() {
        return __privateGet(this, _pool).idleConnections();
      }
      /**
       * Get current stacked connection request.
       * @return {number}
       */
      taskQueueSize() {
        return __privateGet(this, _pool).taskQueueSize();
      }
      escape(value) {
        return __privateGet(this, _pool).escape(value);
      }
      escapeId(value) {
        return __privateGet(this, _pool).escapeId(value);
      }
      /**
       * Ends pool
       *
       * @param callback
       */
      end(callback) {
        __privateGet(this, _pool).end().then(() => {
          if (callback) callback(null);
        }).catch(callback || __privateGet(this, _noop));
      }
      /**
       * Retrieve a connection from the pool.
       * Create a new one if the limit is not reached.
       * wait until acquireTimeout.
       *
       * @param cb callback
       */
      getConnection(cb) {
        if (!cb) {
          throw new Errors.createError("missing mandatory callback parameter", Errors.ER_MISSING_PARAMETER);
        }
        const cmdParam = {};
        if (__privateGet(this, _pool).opts.connOptions.trace) Error.captureStackTrace(cmdParam);
        __privateGet(this, _pool).getConnection(cmdParam, (err, baseConn) => {
          if (err) {
            cb(err);
          } else {
            const cc = new ConnectionCallback(baseConn);
            cc.end = (cb2) => cc.release(cb2);
            cc.close = (cb2) => cc.release(cb2);
            cb(null, cc);
          }
        });
      }
      /**
       * Execute query using text protocol with callback emit columns/data/end/error
       * events to permit streaming big result-set
       *
       * @param sql     sql parameter Object can be used to supersede default option.
       *                Object must then have sql property.
       * @param values  object / array of placeholder values (not mandatory)
       * @param cb      callback
       */
      query(sql, values, cb) {
        const cmdParam = ConnectionCallback._PARAM(__privateGet(this, _pool).opts.connOptions, sql, values, cb);
        __privateGet(this, _pool).getConnection(cmdParam, (err, baseConn) => {
          if (err) {
            if (cmdParam.callback) cmdParam.callback(err);
          } else {
            const _cb = cmdParam.callback;
            cmdParam.callback = (err2, rows, meta) => {
              __privateGet(this, _pool).release(baseConn);
              if (_cb) _cb(err2, rows, meta);
            };
            ConnectionCallback._QUERY_CMD(baseConn, cmdParam);
          }
        });
      }
      /**
       * Execute query using binary protocol with callback emit columns/data/end/error
       * events to permit streaming big result-set
       *
       * @param sql     sql parameter Object can be used to supersede default option.
       *                Object must then have sql property.
       * @param values  object / array of placeholder values (not mandatory)
       * @param cb      callback
       */
      execute(sql, values, cb) {
        const cmdParam = ConnectionCallback._PARAM(__privateGet(this, _pool).opts.connOptions, sql, values, cb);
        __privateGet(this, _pool).getConnection(cmdParam, (err, baseConn) => {
          if (err) {
            if (cmdParam.callback) cmdParam.callback(err);
          } else {
            const _cb = cmdParam.callback;
            baseConn.prepareExecute(
              cmdParam,
              (res) => {
                __privateGet(this, _pool).release(baseConn);
                if (_cb) _cb(null, res, res.meta);
              },
              (err2) => {
                __privateGet(this, _pool).release(baseConn);
                if (_cb) _cb(err2);
              }
            );
          }
        });
      }
      /**
       * execute a batch
       *
       * @param sql     sql parameter Object can be used to supersede default option.
       *                Object must then have sql property.
       * @param values  array of placeholder values
       * @param cb      callback
       */
      batch(sql, values, cb) {
        const cmdParam = ConnectionCallback._PARAM(__privateGet(this, _pool).opts.connOptions, sql, values, cb);
        __privateGet(this, _pool).getConnection(cmdParam, (err, baseConn) => {
          if (err) {
            if (cmdParam.callback) cmdParam.callback(err);
          } else {
            const _cb = cmdParam.callback;
            baseConn.batch(
              cmdParam,
              (res) => {
                __privateGet(this, _pool).release(baseConn);
                if (_cb) _cb(null, res);
              },
              (err2) => {
                __privateGet(this, _pool).release(baseConn);
                if (_cb) _cb(err2);
              }
            );
          }
        });
      }
      /**
       * Import sql file.
       *
       * @param opts JSON array with 2 possible fields: file and database
       * @param cb callback
       */
      importFile(opts, cb) {
        if (!opts) {
          if (cb)
            cb(
              Errors.createError(
                "SQL file parameter is mandatory",
                Errors.ER_MISSING_SQL_PARAMETER,
                null,
                "HY000",
                null,
                false,
                null
              )
            );
          return;
        }
        __privateGet(this, _pool).getConnection({}, (err, baseConn) => {
          if (err) {
            if (cb) cb(err);
          } else {
            baseConn.importFile(
              { file: opts.file, database: opts.database },
              (res) => {
                __privateGet(this, _pool).release(baseConn);
                if (cb) cb(null, res);
              },
              (err2) => {
                __privateGet(this, _pool).release(baseConn);
                if (cb) cb(err2);
              }
            );
          }
        });
      }
      toString() {
        return "poolCallback(" + __privateGet(this, _pool).toString() + ")";
      }
    };
    _pool = new WeakMap();
    _noop = new WeakMap();
    module.exports = PoolCallback;
  }
});

// node_modules/mariadb/lib/filtered-cluster.js
var require_filtered_cluster = __commonJS({
  "node_modules/mariadb/lib/filtered-cluster.js"(exports, module) {
    var _cluster, _pattern, _selector;
    var FilteredCluster = class {
      constructor(poolCluster, patternArg, selectorArg) {
        __privateAdd(this, _cluster);
        __privateAdd(this, _pattern);
        __privateAdd(this, _selector);
        __privateSet(this, _cluster, poolCluster);
        __privateSet(this, _pattern, patternArg);
        __privateSet(this, _selector, selectorArg);
      }
      /**
       * Get a connection according to a previously indicated pattern and selector.
       *
       * @return {Promise}
       */
      getConnection() {
        return __privateGet(this, _cluster).getConnection(__privateGet(this, _pattern), __privateGet(this, _selector));
      }
      /**
       * Execute a text query on one connection from an available pools matching pattern
       * in cluster.
       *
       * @param sql   sql command
       * @param value parameter value of sql command (not mandatory)
       * @return {Promise}
       */
      query(sql, value) {
        return __privateGet(this, _cluster).getConnection(__privateGet(this, _pattern), __privateGet(this, _selector)).then((conn) => {
          return conn.query(sql, value).then((res) => {
            conn.release();
            return res;
          }).catch((err) => {
            conn.release();
            return Promise.reject(err);
          });
        }).catch((err) => {
          return Promise.reject(err);
        });
      }
      /**
       * Execute a binary query on one connection from available pools matching pattern
       * in cluster.
       *
       * @param sql   sql command
       * @param value parameter value of sql command (not mandatory)
       * @return {Promise}
       */
      execute(sql, value) {
        return __privateGet(this, _cluster).getConnection(__privateGet(this, _pattern), __privateGet(this, _selector)).then((conn) => {
          return conn.execute(sql, value).then((res) => {
            conn.release();
            return res;
          }).catch((err) => {
            conn.release();
            return Promise.reject(err);
          });
        }).catch((err) => {
          return Promise.reject(err);
        });
      }
      /**
       * Execute a batch on one connection from available pools matching pattern
       * in cluster.
       *
       * @param sql   sql command
       * @param value parameter value of sql command
       * @return {Promise}
       */
      batch(sql, value) {
        return __privateGet(this, _cluster).getConnection(__privateGet(this, _pattern), __privateGet(this, _selector)).then((conn) => {
          return conn.batch(sql, value).then((res) => {
            conn.release();
            return res;
          }).catch((err) => {
            conn.release();
            return Promise.reject(err);
          });
        }).catch((err) => {
          return Promise.reject(err);
        });
      }
    };
    _cluster = new WeakMap();
    _pattern = new WeakMap();
    _selector = new WeakMap();
    module.exports = FilteredCluster;
  }
});

// node_modules/mariadb/lib/filtered-cluster-callback.js
var require_filtered_cluster_callback = __commonJS({
  "node_modules/mariadb/lib/filtered-cluster-callback.js"(exports, module) {
    var _cluster, _pattern, _selector;
    var FilteredClusterCallback = class {
      constructor(poolCluster, patternArg, selectorArg) {
        __privateAdd(this, _cluster);
        __privateAdd(this, _pattern);
        __privateAdd(this, _selector);
        __privateSet(this, _cluster, poolCluster);
        __privateSet(this, _pattern, patternArg);
        __privateSet(this, _selector, selectorArg);
      }
      /**
       * Get a connection according to a previously indicated pattern and selector.
       */
      getConnection(callback) {
        const cal = callback ? callback : (err, conn) => {
        };
        return __privateGet(this, _cluster).getConnection(__privateGet(this, _pattern), __privateGet(this, _selector), cal);
      }
      /**
       * Execute a text query on one connection from an available pools matching pattern
       * in cluster.
       *
       * @param sql   sql command
       * @param value parameter value of SQL command (not mandatory)
       * @param callback callback parameters
       * @return {Promise}
       */
      query(sql, value, callback) {
        let sq = sql, val = value, cal = callback;
        if (typeof value === "function") {
          val = null;
          cal = value;
        }
        const endingFct = cal ? cal : () => {
        };
        this.getConnection((err, conn) => {
          if (err) {
            endingFct(err);
          } else {
            conn.query(sq, val, (err2, res, meta) => {
              conn.release(() => {
              });
              if (err2) {
                endingFct(err2);
              } else {
                endingFct(null, res, meta);
              }
            });
          }
        });
      }
      /**
       * Execute a binary query on one connection from an available pools matching pattern
       * in cluster.
       *
       * @param sql   sql command
       * @param value parameter value of SQL command (not mandatory)
       * @param callback callback function
       */
      execute(sql, value, callback) {
        let sq = sql, val = value, cal = callback;
        if (typeof value === "function") {
          val = null;
          cal = value;
        }
        const endingFct = cal ? cal : () => {
        };
        this.getConnection((err, conn) => {
          if (err) {
            endingFct(err);
          } else {
            conn.execute(sq, val, (err2, res, meta) => {
              conn.release(() => {
              });
              if (err2) {
                endingFct(err2);
              } else {
                endingFct(null, res, meta);
              }
            });
          }
        });
      }
      /**
       * Execute a batch on one connection from an available pools matching pattern
       * in cluster.
       *
       * @param sql   sql command
       * @param value parameter value of SQL command
       * @param callback callback function
       */
      batch(sql, value, callback) {
        let sq = sql, val = value, cal = callback;
        if (typeof value === "function") {
          val = null;
          cal = value;
        }
        const endingFct = cal ? cal : () => {
        };
        this.getConnection((err, conn) => {
          if (err) {
            endingFct(err);
          } else {
            conn.batch(sq, val, (err2, res, meta) => {
              conn.release(() => {
              });
              if (err2) {
                endingFct(err2);
              } else {
                endingFct(null, res, meta);
              }
            });
          }
        });
      }
    };
    _cluster = new WeakMap();
    _pattern = new WeakMap();
    _selector = new WeakMap();
    module.exports = FilteredClusterCallback;
  }
});

// node_modules/mariadb/lib/cluster.js
var require_cluster = __commonJS({
  "node_modules/mariadb/lib/cluster.js"(exports, module) {
    "use strict";
    var ClusterOptions = require_cluster_options();
    var PoolOptions = require_pool_options();
    var PoolCallback = require_pool_callback();
    var PoolPromise = require_pool_promise();
    var FilteredCluster = require_filtered_cluster();
    var FilteredClusterCallback = require_filtered_cluster_callback();
    var EventEmitter = require_events();
    var _opts, _nodes, _cachedPatterns, _nodeCounter;
    var Cluster = class extends EventEmitter {
      constructor(args) {
        super();
        __privateAdd(this, _opts);
        __privateAdd(this, _nodes, {});
        __privateAdd(this, _cachedPatterns, {});
        __privateAdd(this, _nodeCounter, 0);
        __privateSet(this, _opts, new ClusterOptions(args));
      }
      /**
       * Add a new pool node to the cluster.
       *
       * @param id      identifier
       * @param config  pool configuration
       */
      add(id, config) {
        let identifier;
        if (typeof id === "string" || id instanceof String) {
          identifier = id;
          if (__privateGet(this, _nodes)[identifier]) throw new Error(`Node identifier '${identifier}' already exist !`);
        } else {
          identifier = "PoolNode-" + __privateWrapper(this, _nodeCounter)._++;
          config = id;
        }
        const options = new PoolOptions(config);
        __privateGet(this, _nodes)[identifier] = this._createPool(options);
      }
      /**
       * End cluster (and underlying pools).
       *
       * @return {Promise<any[]>}
       */
      end() {
        const cluster = this;
        __privateSet(this, _cachedPatterns, {});
        const poolEndPromise = [];
        Object.keys(__privateGet(this, _nodes)).forEach((pool) => {
          const res = __privateGet(cluster, _nodes)[pool].end();
          if (res) poolEndPromise.push(res);
        });
        __privateSet(this, _nodes, null);
        return Promise.all(poolEndPromise);
      }
      of(pattern, selector) {
        return new FilteredCluster(this, pattern, selector);
      }
      _ofCallback(pattern, selector) {
        return new FilteredClusterCallback(this, pattern, selector);
      }
      /**
       * Remove nodes according to pattern.
       *
       * @param pattern  pattern
       */
      remove(pattern) {
        if (!pattern) throw new Error("pattern parameter in Cluster.remove(pattern)  is mandatory");
        const regex = RegExp(pattern);
        Object.keys(__privateGet(this, _nodes)).forEach(
          (function(key) {
            if (regex.test(key)) {
              __privateGet(this, _nodes)[key].end();
              delete __privateGet(this, _nodes)[key];
              __privateSet(this, _cachedPatterns, {});
            }
          }).bind(this)
        );
      }
      /**
       * Get connection from an available pools matching pattern, according to selector
       *
       * @param pattern       pattern filter (not mandatory)
       * @param selector      node selector ('RR','RANDOM' or 'ORDER')
       * @return {Promise}
       */
      getConnection(pattern, selector) {
        return this._getConnection(pattern, selector, void 0, void 0, void 0);
      }
      /**
       * Force using callback methods.
       */
      _setCallback() {
        this.getConnection = this._getConnectionCallback;
        this._createPool = this._createPoolCallback;
        this.of = this._ofCallback;
      }
      /**
       * Get connection from an available pools matching pattern, according to selector
       * with additional parameter to avoid reusing failing node
       *
       * @param pattern       pattern filter (not mandatory)
       * @param selector      node selector ('RR','RANDOM' or 'ORDER')
       * @param avoidNodeKey  failing node
       * @param lastError     last error
       * @param remainingRetry remaining possible retry
       * @return {Promise}
       * @private
       */
      _getConnection(pattern, selector, remainingRetry, avoidNodeKey, lastError) {
        const matchingNodeList = this._matchingNodes(pattern || /^/);
        if (matchingNodeList.length === 0) {
          if (Object.keys(__privateGet(this, _nodes)).length === 0 && !lastError) {
            return Promise.reject(
              new Error("No node have been added to cluster or nodes have been removed due to too much connection error")
            );
          }
          if (avoidNodeKey === void 0) return Promise.reject(new Error(`No node found for pattern '${pattern}'`));
          const errMsg = `No Connection available for '${pattern}'${lastError ? ". Last connection error was: " + lastError.message : ""}`;
          return Promise.reject(new Error(errMsg));
        }
        if (remainingRetry === void 0) remainingRetry = matchingNodeList.length;
        const retry = --remainingRetry >= 0 ? this._getConnection.bind(this, pattern, selector, remainingRetry) : null;
        try {
          const nodeKey = this._selectPool(matchingNodeList, selector, avoidNodeKey);
          return this._handleConnectionError(matchingNodeList, nodeKey, retry);
        } catch (e) {
          return Promise.reject(e);
        }
      }
      _createPool(options) {
        const pool = new PoolPromise(options);
        pool.on("error", (err) => {
        });
        return pool;
      }
      _createPoolCallback(options) {
        const pool = new PoolCallback(options);
        pool.on("error", (err) => {
        });
        return pool;
      }
      /**
       * Get connection from an available pools matching pattern, according to selector
       * with additional parameter to avoid reusing failing node
       *
       * @param pattern       pattern filter (not mandatory)
       * @param selector      node selector ('RR','RANDOM' or 'ORDER')
       * @param callback      callback function
       * @param remainingRetry remaining retry
       * @param avoidNodeKey  failing node
       * @param lastError     last error
       * @private
       */
      _getConnectionCallback(pattern, selector, callback, remainingRetry, avoidNodeKey, lastError) {
        const matchingNodeList = this._matchingNodes(pattern || /^/);
        if (matchingNodeList.length === 0) {
          if (Object.keys(__privateGet(this, _nodes)).length === 0 && !lastError) {
            callback(
              new Error("No node have been added to cluster or nodes have been removed due to too much connection error")
            );
            return;
          }
          if (avoidNodeKey === void 0) callback(new Error(`No node found for pattern '${pattern}'`));
          const errMsg = `No Connection available for '${pattern}'${lastError ? ". Last connection error was: " + lastError.message : ""}`;
          callback(new Error(errMsg));
          return;
        }
        if (remainingRetry === void 0) remainingRetry = matchingNodeList.length;
        const retry = --remainingRetry >= 0 ? this._getConnectionCallback.bind(this, pattern, selector, callback, remainingRetry) : null;
        try {
          const nodeKey = this._selectPool(matchingNodeList, selector, avoidNodeKey);
          this._handleConnectionCallbackError(matchingNodeList, nodeKey, retry, callback);
        } catch (e) {
          callback(e);
        }
      }
      /**
       * Selecting nodes according to pattern.
       *
       * @param pattern pattern
       * @return {*}
       * @private
       */
      _matchingNodes(pattern) {
        if (__privateGet(this, _cachedPatterns)[pattern]) return __privateGet(this, _cachedPatterns)[pattern];
        const regex = RegExp(pattern);
        const matchingNodeList = [];
        Object.keys(__privateGet(this, _nodes)).forEach((key) => {
          if (regex.test(key)) {
            matchingNodeList.push(key);
          }
        });
        __privateGet(this, _cachedPatterns)[pattern] = matchingNodeList;
        return matchingNodeList;
      }
      /**
       * Select the next node to be chosen in the nodeList according to selector and failed nodes.
       *
       * @param nodeList        current node list
       * @param selectorParam   selector
       * @param avoidNodeKey    last failing node to avoid selecting this one.
       * @return {Promise}
       * @private
       */
      _selectPool(nodeList, selectorParam, avoidNodeKey) {
        const selector = selectorParam || __privateGet(this, _opts).defaultSelector;
        let selectorFct;
        switch (selector) {
          case "RR":
            selectorFct = roundRobinSelector;
            break;
          case "RANDOM":
            selectorFct = randomSelector;
            break;
          case "ORDER":
            selectorFct = orderedSelector;
            break;
          default:
            throw new Error(`Wrong selector value '${selector}'. Possible values are 'RR','RANDOM' or 'ORDER'`);
        }
        let nodeIdx = 0;
        let nodeKey = selectorFct(nodeList, nodeIdx);
        while ((avoidNodeKey === nodeKey || __privateGet(this, _nodes)[nodeKey].blacklistedUntil && __privateGet(this, _nodes)[nodeKey].blacklistedUntil > Date.now()) && nodeIdx < nodeList.length - 1) {
          nodeIdx++;
          nodeKey = selectorFct(nodeList, nodeIdx);
        }
        if (avoidNodeKey === nodeKey) {
          nodeIdx = 0;
          while (avoidNodeKey === nodeKey && nodeIdx < nodeList.length - 1) {
            nodeIdx++;
            nodeKey = selectorFct(nodeList, nodeIdx);
          }
        }
        return nodeKey;
      }
      /**
       * Handle node blacklisting and potential removal after a connection error
       *
       * @param {string} nodeKey - The key of the node that failed
       * @param {Array<string>} nodeList - List of available nodes
       * @returns {void}
       * @private
       */
      _handleNodeFailure(nodeKey, nodeList) {
        const node = __privateGet(this, _nodes)[nodeKey];
        if (!node) return;
        const cluster = this;
        node.errorCount = node.errorCount ? node.errorCount + 1 : 1;
        node.blacklistedUntil = Date.now() + __privateGet(cluster, _opts).restoreNodeTimeout;
        if (__privateGet(cluster, _opts).removeNodeErrorCount && node.errorCount >= __privateGet(cluster, _opts).removeNodeErrorCount && __privateGet(cluster, _nodes)[nodeKey]) {
          delete __privateGet(cluster, _nodes)[nodeKey];
          __privateSet(cluster, _cachedPatterns, {});
          delete nodeList.lastRrIdx;
          setImmediate(cluster.emit.bind(cluster, "remove", nodeKey));
          if (node instanceof PoolCallback) {
            node.end(() => {
            });
          } else {
            node.end().catch((err) => {
            });
          }
        }
      }
      /**
       * Connect, or if fail handle retry / set timeout error
       *
       * @param nodeList    current node list
       * @param nodeKey     node name to connect
       * @param retryFct    retry function
       * @return {Promise}
       * @private
       */
      _handleConnectionError(nodeList, nodeKey, retryFct) {
        const cluster = this;
        const node = __privateGet(this, _nodes)[nodeKey];
        return node.getConnection().then((conn) => {
          node.blacklistedUntil = null;
          node.errorCount = 0;
          return conn;
        }).catch((err) => {
          this._handleNodeFailure(nodeKey, nodeList);
          if (nodeList.length !== 0 && __privateGet(cluster, _opts).canRetry && retryFct) {
            return retryFct(nodeKey, err);
          }
          return Promise.reject(err);
        });
      }
      /**
       * Connect, or if fail handle retry / set timeout error
       *
       * @param nodeList    current node list
       * @param nodeKey     node name to connect
       * @param retryFct    retry function
       * @param callback    callback function
       * @private
       */
      _handleConnectionCallbackError(nodeList, nodeKey, retryFct, callback) {
        const cluster = this;
        const node = __privateGet(this, _nodes)[nodeKey];
        node.getConnection((err, conn) => {
          if (err) {
            this._handleNodeFailure(nodeKey, nodeList);
            if (nodeList.length !== 0 && __privateGet(cluster, _opts).canRetry && retryFct) {
              return retryFct(nodeKey, err);
            }
            callback(err);
          } else {
            node.blacklistedUntil = null;
            node.errorCount = 0;
            callback(null, conn);
          }
        });
      }
      //*****************************************************************
      // internal public testing methods
      //*****************************************************************
      get __tests() {
        return new TestMethods(__privateGet(this, _nodes));
      }
    };
    _opts = new WeakMap();
    _nodes = new WeakMap();
    _cachedPatterns = new WeakMap();
    _nodeCounter = new WeakMap();
    var _nodes2;
    var TestMethods = class {
      constructor(nodes) {
        __privateAdd(this, _nodes2);
        __privateSet(this, _nodes2, nodes);
      }
      getNodes() {
        return __privateGet(this, _nodes2);
      }
    };
    _nodes2 = new WeakMap();
    var roundRobinSelector = (nodeList) => {
      let lastRoundRobin = nodeList.lastRrIdx;
      if (lastRoundRobin === void 0) lastRoundRobin = -1;
      if (++lastRoundRobin >= nodeList.length) lastRoundRobin = 0;
      nodeList.lastRrIdx = lastRoundRobin;
      return nodeList[lastRoundRobin];
    };
    var randomSelector = (nodeList) => {
      const randomIdx = Math.floor(Math.random() * nodeList.length);
      return nodeList[randomIdx];
    };
    var orderedSelector = (nodeList, retry) => {
      return nodeList[retry];
    };
    module.exports = Cluster;
  }
});

// node_modules/mariadb/promise.js
var require_promise = __commonJS({
  "node_modules/mariadb/promise.js"(exports, module) {
    require_check_node();
    var Connection = require_connection();
    var ConnectionPromise = require_connection_promise();
    var PoolPromise = require_pool_promise();
    var Cluster = require_cluster();
    var ConnOptions = require_connection_options();
    var PoolOptions = require_pool_options();
    var ClusterOptions = require_cluster_options();
    module.exports.version = require_package().version;
    module.exports.SqlError = require_errors().SqlError;
    module.exports.defaultOptions = function defaultOptions(opts) {
      const connOpts = new ConnOptions(opts);
      const res = {};
      for (const [key, value] of Object.entries(connOpts)) {
        if (!key.startsWith("_")) {
          res[key] = value;
        }
      }
      return res;
    };
    module.exports.createConnection = function createConnection(opts) {
      try {
        const options = new ConnOptions(opts);
        const conn = new Connection(options);
        const connPromise = new ConnectionPromise(conn);
        return conn.connect().then(() => Promise.resolve(connPromise));
      } catch (err) {
        return Promise.reject(err);
      }
    };
    module.exports.createPool = function createPool(opts) {
      const options = new PoolOptions(opts);
      const pool = new PoolPromise(options);
      pool.on("error", (err) => {
      });
      return pool;
    };
    module.exports.createPoolCluster = function createPoolCluster(opts) {
      const options = new ClusterOptions(opts);
      return new Cluster(options);
    };
    module.exports.importFile = function importFile(opts) {
      try {
        const options = new ConnOptions(opts);
        const conn = new Connection(options);
        return conn.connect().then(() => {
          return new Promise(conn.importFile.bind(conn, Object.assign({ skipDbCheck: true }, opts)));
        }).finally(() => {
          new Promise(conn.end.bind(conn, {})).catch(console.log);
        });
      } catch (err) {
        return Promise.reject(err);
      }
    };
  }
});
export default require_promise();
//# sourceMappingURL=mariadb.js.map
